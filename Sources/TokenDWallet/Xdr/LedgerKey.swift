// Automatically generated by xdrgen
// DO NOT EDIT or your changes may be overwritten

import Foundation

// === xdr source ============================================================

//  union LedgerKey switch (LedgerEntryType type)
//  {
//  case ACCOUNT:
//      struct
//      {
//          AccountID accountID;
//          union switch (LedgerVersion v)
//         {
//         case EMPTY_VERSION:
//            void;
//         }
//         ext;
//      } account;
//  case SIGNER:
//      struct
//      {
//          PublicKey pubKey;
//          AccountID accountID;
//  
//          union switch (LedgerVersion v)
//          {
//          case EMPTY_VERSION:
//              void;
//          }
//          ext;
//      } signer;
//  case FEE:
//      struct {
//          Hash hash;
//          int64 lowerBound;
//          int64 upperBound;
//          union switch (LedgerVersion v)
//          {
//          case EMPTY_VERSION:
//              void;
//          }
//          ext;
//      } feeState;
//  case BALANCE:
//      struct
//      {
//          BalanceID balanceID;
//          union switch (LedgerVersion v)
//          {
//          case EMPTY_VERSION:
//              void;
//          }
//          ext;
//      } balance;
//  case ASSET:
//      struct
//      {
//          AssetCode code;
//          union switch (LedgerVersion v)
//          {
//          case EMPTY_VERSION:
//              void;
//          }
//          ext;
//      } asset;
//  case REFERENCE_ENTRY:
//      struct
//      {
//  		AccountID sender;
//  		string64 reference;
//  		union switch (LedgerVersion v)
//  		{
//  		case EMPTY_VERSION:
//  			void;
//  		}
//  		ext;
//      } reference;
//  case STATISTICS:
//      struct {
//          AccountID accountID;
//  		union switch (LedgerVersion v)
//  		{
//  		case EMPTY_VERSION:
//  			void;
//  		}
//  		ext;
//      } stats;
//  case ACCOUNT_LIMITS:
//      struct {
//          AccountID accountID;
//  		union switch (LedgerVersion v)
//  		{
//  		case EMPTY_VERSION:
//  			void;
//  		}
//  		ext;
//      } accountLimits;
//  case ASSET_PAIR:
//      struct {
//          AssetCode base;
//          AssetCode quote;
//          union switch (LedgerVersion v)
//          {
//          case EMPTY_VERSION:
//              void;
//          }
//          ext;
//      } assetPair;
//  case OFFER_ENTRY:
//      struct {
//          uint64 offerID;
//          AccountID ownerID;
//      } offer;
//  case REVIEWABLE_REQUEST:
//      struct {
//          uint64 requestID;
//          union switch (LedgerVersion v)
//          {
//          case EMPTY_VERSION:
//              void;
//          }
//          ext;
//      } reviewableRequest;
//  case EXTERNAL_SYSTEM_ACCOUNT_ID:
//  	struct {
//  		AccountID accountID;
//  		int32 externalSystemType;
//  		union switch (LedgerVersion v)
//  		{
//  		case EMPTY_VERSION:
//  			void;
//  		}
//  		ext;
//  	} externalSystemAccountID;
//  case SALE:
//      struct {
//          uint64 saleID;
//          union switch (LedgerVersion v)
//          {
//          case EMPTY_VERSION:
//              void;
//          }
//          ext;
//      } sale;
//  case KEY_VALUE:
//      struct {
//          longstring key;
//          union switch (LedgerVersion v)
//          {
//          case EMPTY_VERSION:
//              void;
//          }
//          ext;
//      } keyValue;
//  case ACCOUNT_KYC:
//      struct {
//          AccountID accountID;
//          union switch(LedgerVersion v)
//          {
//          case EMPTY_VERSION:
//              void;
//          }
//          ext;
//      } accountKYC;
//  case EXTERNAL_SYSTEM_ACCOUNT_ID_POOL_ENTRY:
//      struct {
//  		uint64 poolEntryID;
//  		union switch (LedgerVersion v)
//  		{
//  		case EMPTY_VERSION:
//  			void;
//  		}
//  		ext;
//  	} externalSystemAccountIDPoolEntry;
//  case LIMITS_V2:
//      struct {
//          uint64 id;
//          union switch (LedgerVersion v)
//          {
//          case EMPTY_VERSION:
//              void;
//          } ext;
//      } limitsV2;
//  case STATISTICS_V2:
//      struct {
//          uint64 id;
//          union switch (LedgerVersion v)
//          {
//          case EMPTY_VERSION:
//              void;
//          }
//          ext;
//      } statisticsV2;
//  case PENDING_STATISTICS:
//      struct {
//          uint64 statisticsID;
//          uint64 requestID;
//          union switch (LedgerVersion v)
//          {
//          case EMPTY_VERSION:
//              void;
//          }
//          ext;
//      } pendingStatistics;
//  case CONTRACT:
//      struct {
//          uint64 contractID;
//          union switch (LedgerVersion v)
//          {
//          case EMPTY_VERSION:
//              void;
//          }
//          ext;
//      } contract;
//  case ATOMIC_SWAP_ASK:
//      struct {
//          uint64 id;
//          union switch (LedgerVersion v)
//          {
//          case EMPTY_VERSION:
//              void;
//          }
//          ext;
//      } atomicSwapAsk;
//  case ACCOUNT_ROLE:
//      struct {
//          uint64 id;
//          union switch (LedgerVersion v)
//          {
//          case EMPTY_VERSION:
//              void;
//          }
//          ext;
//      } accountRole;
//  case ACCOUNT_RULE:
//      struct {
//          uint64 id;
//          union switch (LedgerVersion v)
//          {
//          case EMPTY_VERSION:
//              void;
//          }
//          ext;
//      } accountRule;
//  case SIGNER_ROLE:
//      struct {
//          uint64 id;
//          union switch (LedgerVersion v)
//          {
//          case EMPTY_VERSION:
//              void;
//          }
//          ext;
//      } signerRole;
//  case SIGNER_RULE:
//      struct {
//          uint64 id;
//          union switch (LedgerVersion v)
//          {
//          case EMPTY_VERSION:
//              void;
//          }
//          ext;
//      } signerRule;
//  case STAMP:
//      struct {
//          Hash ledgerHash;
//          Hash licenseHash;
//          union switch (LedgerVersion v)
//          {
//          case EMPTY_VERSION:
//              void;
//          }
//          ext;
//      } stamp;
//  case LICENSE:
//      struct {
//          Hash licenseHash;
//          union switch (LedgerVersion v)
//          {
//          case EMPTY_VERSION:
//              void;
//          } ext;
//      } license;
//  case POLL:
//      struct {
//          uint64 id;
//  
//          EmptyExt ext;
//      } poll;
//  case VOTE:
//      struct {
//          uint64 pollID;
//          AccountID voterID;
//  
//          EmptyExt ext;
//      } vote;
//  case ACCOUNT_SPECIFIC_RULE:
//      struct {
//          uint64 id;
//  
//          EmptyExt ext;
//      } accountSpecificRule;
//  };

//  ===========================================================================
public enum LedgerKey: XDRDiscriminatedUnion {
  case account(LedgerKeyAccount)
  case signer(LedgerKeySigner)
  case fee(LedgerKeyFeeState)
  case balance(LedgerKeyBalance)
  case asset(LedgerKeyAsset)
  case referenceEntry(LedgerKeyReference)
  case statistics(LedgerKeyStats)
  case accountLimits(LedgerKeyAccountLimits)
  case assetPair(LedgerKeyAssetPair)
  case offerEntry(LedgerKeyOffer)
  case reviewableRequest(LedgerKeyReviewableRequest)
  case externalSystemAccountId(LedgerKeyExternalSystemAccountID)
  case sale(LedgerKeySale)
  case keyValue(LedgerKeyKeyValue)
  case accountKyc(LedgerKeyAccountKYC)
  case externalSystemAccountIdPoolEntry(LedgerKeyExternalSystemAccountIDPoolEntry)
  case limitsV2(LedgerKeyLimitsV2)
  case statisticsV2(LedgerKeyStatisticsV2)
  case pendingStatistics(LedgerKeyPendingStatistics)
  case contract(LedgerKeyContract)
  case atomicSwapAsk(LedgerKeyAtomicSwapAsk)
  case accountRole(LedgerKeyAccountRole)
  case accountRule(LedgerKeyAccountRule)
  case signerRole(LedgerKeySignerRole)
  case signerRule(LedgerKeySignerRule)
  case stamp(LedgerKeyStamp)
  case license(LedgerKeyLicense)
  case poll(LedgerKeyPoll)
  case vote(LedgerKeyVote)
  case accountSpecificRule(LedgerKeyAccountSpecificRule)

  public var discriminant: Int32 {
    switch self {
    case .account: return LedgerEntryType.account.rawValue
    case .signer: return LedgerEntryType.signer.rawValue
    case .fee: return LedgerEntryType.fee.rawValue
    case .balance: return LedgerEntryType.balance.rawValue
    case .asset: return LedgerEntryType.asset.rawValue
    case .referenceEntry: return LedgerEntryType.referenceEntry.rawValue
    case .statistics: return LedgerEntryType.statistics.rawValue
    case .accountLimits: return LedgerEntryType.accountLimits.rawValue
    case .assetPair: return LedgerEntryType.assetPair.rawValue
    case .offerEntry: return LedgerEntryType.offerEntry.rawValue
    case .reviewableRequest: return LedgerEntryType.reviewableRequest.rawValue
    case .externalSystemAccountId: return LedgerEntryType.externalSystemAccountId.rawValue
    case .sale: return LedgerEntryType.sale.rawValue
    case .keyValue: return LedgerEntryType.keyValue.rawValue
    case .accountKyc: return LedgerEntryType.accountKyc.rawValue
    case .externalSystemAccountIdPoolEntry: return LedgerEntryType.externalSystemAccountIdPoolEntry.rawValue
    case .limitsV2: return LedgerEntryType.limitsV2.rawValue
    case .statisticsV2: return LedgerEntryType.statisticsV2.rawValue
    case .pendingStatistics: return LedgerEntryType.pendingStatistics.rawValue
    case .contract: return LedgerEntryType.contract.rawValue
    case .atomicSwapAsk: return LedgerEntryType.atomicSwapAsk.rawValue
    case .accountRole: return LedgerEntryType.accountRole.rawValue
    case .accountRule: return LedgerEntryType.accountRule.rawValue
    case .signerRole: return LedgerEntryType.signerRole.rawValue
    case .signerRule: return LedgerEntryType.signerRule.rawValue
    case .stamp: return LedgerEntryType.stamp.rawValue
    case .license: return LedgerEntryType.license.rawValue
    case .poll: return LedgerEntryType.poll.rawValue
    case .vote: return LedgerEntryType.vote.rawValue
    case .accountSpecificRule: return LedgerEntryType.accountSpecificRule.rawValue
    }
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.discriminant.toXDR())

    switch self {
    case .account(let data): xdr.append(data.toXDR())
    case .signer(let data): xdr.append(data.toXDR())
    case .fee(let data): xdr.append(data.toXDR())
    case .balance(let data): xdr.append(data.toXDR())
    case .asset(let data): xdr.append(data.toXDR())
    case .referenceEntry(let data): xdr.append(data.toXDR())
    case .statistics(let data): xdr.append(data.toXDR())
    case .accountLimits(let data): xdr.append(data.toXDR())
    case .assetPair(let data): xdr.append(data.toXDR())
    case .offerEntry(let data): xdr.append(data.toXDR())
    case .reviewableRequest(let data): xdr.append(data.toXDR())
    case .externalSystemAccountId(let data): xdr.append(data.toXDR())
    case .sale(let data): xdr.append(data.toXDR())
    case .keyValue(let data): xdr.append(data.toXDR())
    case .accountKyc(let data): xdr.append(data.toXDR())
    case .externalSystemAccountIdPoolEntry(let data): xdr.append(data.toXDR())
    case .limitsV2(let data): xdr.append(data.toXDR())
    case .statisticsV2(let data): xdr.append(data.toXDR())
    case .pendingStatistics(let data): xdr.append(data.toXDR())
    case .contract(let data): xdr.append(data.toXDR())
    case .atomicSwapAsk(let data): xdr.append(data.toXDR())
    case .accountRole(let data): xdr.append(data.toXDR())
    case .accountRule(let data): xdr.append(data.toXDR())
    case .signerRole(let data): xdr.append(data.toXDR())
    case .signerRule(let data): xdr.append(data.toXDR())
    case .stamp(let data): xdr.append(data.toXDR())
    case .license(let data): xdr.append(data.toXDR())
    case .poll(let data): xdr.append(data.toXDR())
    case .vote(let data): xdr.append(data.toXDR())
    case .accountSpecificRule(let data): xdr.append(data.toXDR())
    }

    return xdr
  }
  public struct LedgerKeyAccount: XDREncodable {
    public var accountID: AccountID
    public var ext: LedgerKeyAccountExt

    public init(
        accountID: AccountID,
        ext: LedgerKeyAccountExt) {

      self.accountID = accountID
      self.ext = ext
    }

    public func toXDR() -> Data {
      var xdr = Data()

      xdr.append(self.accountID.toXDR())
      xdr.append(self.ext.toXDR())

      return xdr
    }

    public enum LedgerKeyAccountExt: XDRDiscriminatedUnion {
      case emptyVersion()

      public var discriminant: Int32 {
        switch self {
        case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
        }
      }

      public func toXDR() -> Data {
        var xdr = Data()

        xdr.append(self.discriminant.toXDR())

        switch self {
        case .emptyVersion(): xdr.append(Data())
        }

        return xdr
      }

    }
  }
  public struct LedgerKeySigner: XDREncodable {
    public var pubKey: PublicKey
    public var accountID: AccountID
    public var ext: LedgerKeySignerExt

    public init(
        pubKey: PublicKey,
        accountID: AccountID,
        ext: LedgerKeySignerExt) {

      self.pubKey = pubKey
      self.accountID = accountID
      self.ext = ext
    }

    public func toXDR() -> Data {
      var xdr = Data()

      xdr.append(self.pubKey.toXDR())
      xdr.append(self.accountID.toXDR())
      xdr.append(self.ext.toXDR())

      return xdr
    }

    public enum LedgerKeySignerExt: XDRDiscriminatedUnion {
      case emptyVersion()

      public var discriminant: Int32 {
        switch self {
        case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
        }
      }

      public func toXDR() -> Data {
        var xdr = Data()

        xdr.append(self.discriminant.toXDR())

        switch self {
        case .emptyVersion(): xdr.append(Data())
        }

        return xdr
      }

    }
  }
  public struct LedgerKeyFeeState: XDREncodable {
    public var hash: Hash
    public var lowerBound: Int64
    public var upperBound: Int64
    public var ext: LedgerKeyFeeStateExt

    public init(
        hash: Hash,
        lowerBound: Int64,
        upperBound: Int64,
        ext: LedgerKeyFeeStateExt) {

      self.hash = hash
      self.lowerBound = lowerBound
      self.upperBound = upperBound
      self.ext = ext
    }

    public func toXDR() -> Data {
      var xdr = Data()

      xdr.append(self.hash.toXDR())
      xdr.append(self.lowerBound.toXDR())
      xdr.append(self.upperBound.toXDR())
      xdr.append(self.ext.toXDR())

      return xdr
    }

    public enum LedgerKeyFeeStateExt: XDRDiscriminatedUnion {
      case emptyVersion()

      public var discriminant: Int32 {
        switch self {
        case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
        }
      }

      public func toXDR() -> Data {
        var xdr = Data()

        xdr.append(self.discriminant.toXDR())

        switch self {
        case .emptyVersion(): xdr.append(Data())
        }

        return xdr
      }

    }
  }
  public struct LedgerKeyBalance: XDREncodable {
    public var balanceID: BalanceID
    public var ext: LedgerKeyBalanceExt

    public init(
        balanceID: BalanceID,
        ext: LedgerKeyBalanceExt) {

      self.balanceID = balanceID
      self.ext = ext
    }

    public func toXDR() -> Data {
      var xdr = Data()

      xdr.append(self.balanceID.toXDR())
      xdr.append(self.ext.toXDR())

      return xdr
    }

    public enum LedgerKeyBalanceExt: XDRDiscriminatedUnion {
      case emptyVersion()

      public var discriminant: Int32 {
        switch self {
        case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
        }
      }

      public func toXDR() -> Data {
        var xdr = Data()

        xdr.append(self.discriminant.toXDR())

        switch self {
        case .emptyVersion(): xdr.append(Data())
        }

        return xdr
      }

    }
  }
  public struct LedgerKeyAsset: XDREncodable {
    public var code: AssetCode
    public var ext: LedgerKeyAssetExt

    public init(
        code: AssetCode,
        ext: LedgerKeyAssetExt) {

      self.code = code
      self.ext = ext
    }

    public func toXDR() -> Data {
      var xdr = Data()

      xdr.append(self.code.toXDR())
      xdr.append(self.ext.toXDR())

      return xdr
    }

    public enum LedgerKeyAssetExt: XDRDiscriminatedUnion {
      case emptyVersion()

      public var discriminant: Int32 {
        switch self {
        case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
        }
      }

      public func toXDR() -> Data {
        var xdr = Data()

        xdr.append(self.discriminant.toXDR())

        switch self {
        case .emptyVersion(): xdr.append(Data())
        }

        return xdr
      }

    }
  }
  public struct LedgerKeyReference: XDREncodable {
    public var sender: AccountID
    public var reference: String64
    public var ext: LedgerKeyReferenceExt

    public init(
        sender: AccountID,
        reference: String64,
        ext: LedgerKeyReferenceExt) {

      self.sender = sender
      self.reference = reference
      self.ext = ext
    }

    public func toXDR() -> Data {
      var xdr = Data()

      xdr.append(self.sender.toXDR())
      xdr.append(self.reference.toXDR())
      xdr.append(self.ext.toXDR())

      return xdr
    }

    public enum LedgerKeyReferenceExt: XDRDiscriminatedUnion {
      case emptyVersion()

      public var discriminant: Int32 {
        switch self {
        case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
        }
      }

      public func toXDR() -> Data {
        var xdr = Data()

        xdr.append(self.discriminant.toXDR())

        switch self {
        case .emptyVersion(): xdr.append(Data())
        }

        return xdr
      }

    }
  }
  public struct LedgerKeyStats: XDREncodable {
    public var accountID: AccountID
    public var ext: LedgerKeyStatsExt

    public init(
        accountID: AccountID,
        ext: LedgerKeyStatsExt) {

      self.accountID = accountID
      self.ext = ext
    }

    public func toXDR() -> Data {
      var xdr = Data()

      xdr.append(self.accountID.toXDR())
      xdr.append(self.ext.toXDR())

      return xdr
    }

    public enum LedgerKeyStatsExt: XDRDiscriminatedUnion {
      case emptyVersion()

      public var discriminant: Int32 {
        switch self {
        case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
        }
      }

      public func toXDR() -> Data {
        var xdr = Data()

        xdr.append(self.discriminant.toXDR())

        switch self {
        case .emptyVersion(): xdr.append(Data())
        }

        return xdr
      }

    }
  }
  public struct LedgerKeyAccountLimits: XDREncodable {
    public var accountID: AccountID
    public var ext: LedgerKeyAccountLimitsExt

    public init(
        accountID: AccountID,
        ext: LedgerKeyAccountLimitsExt) {

      self.accountID = accountID
      self.ext = ext
    }

    public func toXDR() -> Data {
      var xdr = Data()

      xdr.append(self.accountID.toXDR())
      xdr.append(self.ext.toXDR())

      return xdr
    }

    public enum LedgerKeyAccountLimitsExt: XDRDiscriminatedUnion {
      case emptyVersion()

      public var discriminant: Int32 {
        switch self {
        case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
        }
      }

      public func toXDR() -> Data {
        var xdr = Data()

        xdr.append(self.discriminant.toXDR())

        switch self {
        case .emptyVersion(): xdr.append(Data())
        }

        return xdr
      }

    }
  }
  public struct LedgerKeyAssetPair: XDREncodable {
    public var base: AssetCode
    public var quote: AssetCode
    public var ext: LedgerKeyAssetPairExt

    public init(
        base: AssetCode,
        quote: AssetCode,
        ext: LedgerKeyAssetPairExt) {

      self.base = base
      self.quote = quote
      self.ext = ext
    }

    public func toXDR() -> Data {
      var xdr = Data()

      xdr.append(self.base.toXDR())
      xdr.append(self.quote.toXDR())
      xdr.append(self.ext.toXDR())

      return xdr
    }

    public enum LedgerKeyAssetPairExt: XDRDiscriminatedUnion {
      case emptyVersion()

      public var discriminant: Int32 {
        switch self {
        case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
        }
      }

      public func toXDR() -> Data {
        var xdr = Data()

        xdr.append(self.discriminant.toXDR())

        switch self {
        case .emptyVersion(): xdr.append(Data())
        }

        return xdr
      }

    }
  }
  public struct LedgerKeyOffer: XDREncodable {
    public var offerID: Uint64
    public var ownerID: AccountID

    public init(
        offerID: Uint64,
        ownerID: AccountID) {

      self.offerID = offerID
      self.ownerID = ownerID
    }

    public func toXDR() -> Data {
      var xdr = Data()

      xdr.append(self.offerID.toXDR())
      xdr.append(self.ownerID.toXDR())

      return xdr
    }

  }
  public struct LedgerKeyReviewableRequest: XDREncodable {
    public var requestID: Uint64
    public var ext: LedgerKeyReviewableRequestExt

    public init(
        requestID: Uint64,
        ext: LedgerKeyReviewableRequestExt) {

      self.requestID = requestID
      self.ext = ext
    }

    public func toXDR() -> Data {
      var xdr = Data()

      xdr.append(self.requestID.toXDR())
      xdr.append(self.ext.toXDR())

      return xdr
    }

    public enum LedgerKeyReviewableRequestExt: XDRDiscriminatedUnion {
      case emptyVersion()

      public var discriminant: Int32 {
        switch self {
        case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
        }
      }

      public func toXDR() -> Data {
        var xdr = Data()

        xdr.append(self.discriminant.toXDR())

        switch self {
        case .emptyVersion(): xdr.append(Data())
        }

        return xdr
      }

    }
  }
  public struct LedgerKeyExternalSystemAccountID: XDREncodable {
    public var accountID: AccountID
    public var externalSystemType: Int32
    public var ext: LedgerKeyExternalSystemAccountIDExt

    public init(
        accountID: AccountID,
        externalSystemType: Int32,
        ext: LedgerKeyExternalSystemAccountIDExt) {

      self.accountID = accountID
      self.externalSystemType = externalSystemType
      self.ext = ext
    }

    public func toXDR() -> Data {
      var xdr = Data()

      xdr.append(self.accountID.toXDR())
      xdr.append(self.externalSystemType.toXDR())
      xdr.append(self.ext.toXDR())

      return xdr
    }

    public enum LedgerKeyExternalSystemAccountIDExt: XDRDiscriminatedUnion {
      case emptyVersion()

      public var discriminant: Int32 {
        switch self {
        case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
        }
      }

      public func toXDR() -> Data {
        var xdr = Data()

        xdr.append(self.discriminant.toXDR())

        switch self {
        case .emptyVersion(): xdr.append(Data())
        }

        return xdr
      }

    }
  }
  public struct LedgerKeySale: XDREncodable {
    public var saleID: Uint64
    public var ext: LedgerKeySaleExt

    public init(
        saleID: Uint64,
        ext: LedgerKeySaleExt) {

      self.saleID = saleID
      self.ext = ext
    }

    public func toXDR() -> Data {
      var xdr = Data()

      xdr.append(self.saleID.toXDR())
      xdr.append(self.ext.toXDR())

      return xdr
    }

    public enum LedgerKeySaleExt: XDRDiscriminatedUnion {
      case emptyVersion()

      public var discriminant: Int32 {
        switch self {
        case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
        }
      }

      public func toXDR() -> Data {
        var xdr = Data()

        xdr.append(self.discriminant.toXDR())

        switch self {
        case .emptyVersion(): xdr.append(Data())
        }

        return xdr
      }

    }
  }
  public struct LedgerKeyKeyValue: XDREncodable {
    public var key: Longstring
    public var ext: LedgerKeyKeyValueExt

    public init(
        key: Longstring,
        ext: LedgerKeyKeyValueExt) {

      self.key = key
      self.ext = ext
    }

    public func toXDR() -> Data {
      var xdr = Data()

      xdr.append(self.key.toXDR())
      xdr.append(self.ext.toXDR())

      return xdr
    }

    public enum LedgerKeyKeyValueExt: XDRDiscriminatedUnion {
      case emptyVersion()

      public var discriminant: Int32 {
        switch self {
        case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
        }
      }

      public func toXDR() -> Data {
        var xdr = Data()

        xdr.append(self.discriminant.toXDR())

        switch self {
        case .emptyVersion(): xdr.append(Data())
        }

        return xdr
      }

    }
  }
  public struct LedgerKeyAccountKYC: XDREncodable {
    public var accountID: AccountID
    public var ext: LedgerKeyAccountKYCExt

    public init(
        accountID: AccountID,
        ext: LedgerKeyAccountKYCExt) {

      self.accountID = accountID
      self.ext = ext
    }

    public func toXDR() -> Data {
      var xdr = Data()

      xdr.append(self.accountID.toXDR())
      xdr.append(self.ext.toXDR())

      return xdr
    }

    public enum LedgerKeyAccountKYCExt: XDRDiscriminatedUnion {
      case emptyVersion()

      public var discriminant: Int32 {
        switch self {
        case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
        }
      }

      public func toXDR() -> Data {
        var xdr = Data()

        xdr.append(self.discriminant.toXDR())

        switch self {
        case .emptyVersion(): xdr.append(Data())
        }

        return xdr
      }

    }
  }
  public struct LedgerKeyExternalSystemAccountIDPoolEntry: XDREncodable {
    public var poolEntryID: Uint64
    public var ext: LedgerKeyExternalSystemAccountIDPoolEntryExt

    public init(
        poolEntryID: Uint64,
        ext: LedgerKeyExternalSystemAccountIDPoolEntryExt) {

      self.poolEntryID = poolEntryID
      self.ext = ext
    }

    public func toXDR() -> Data {
      var xdr = Data()

      xdr.append(self.poolEntryID.toXDR())
      xdr.append(self.ext.toXDR())

      return xdr
    }

    public enum LedgerKeyExternalSystemAccountIDPoolEntryExt: XDRDiscriminatedUnion {
      case emptyVersion()

      public var discriminant: Int32 {
        switch self {
        case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
        }
      }

      public func toXDR() -> Data {
        var xdr = Data()

        xdr.append(self.discriminant.toXDR())

        switch self {
        case .emptyVersion(): xdr.append(Data())
        }

        return xdr
      }

    }
  }
  public struct LedgerKeyLimitsV2: XDREncodable {
    public var id: Uint64
    public var ext: LedgerKeyLimitsV2Ext

    public init(
        id: Uint64,
        ext: LedgerKeyLimitsV2Ext) {

      self.id = id
      self.ext = ext
    }

    public func toXDR() -> Data {
      var xdr = Data()

      xdr.append(self.id.toXDR())
      xdr.append(self.ext.toXDR())

      return xdr
    }

    public enum LedgerKeyLimitsV2Ext: XDRDiscriminatedUnion {
      case emptyVersion()

      public var discriminant: Int32 {
        switch self {
        case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
        }
      }

      public func toXDR() -> Data {
        var xdr = Data()

        xdr.append(self.discriminant.toXDR())

        switch self {
        case .emptyVersion(): xdr.append(Data())
        }

        return xdr
      }

    }
  }
  public struct LedgerKeyStatisticsV2: XDREncodable {
    public var id: Uint64
    public var ext: LedgerKeyStatisticsV2Ext

    public init(
        id: Uint64,
        ext: LedgerKeyStatisticsV2Ext) {

      self.id = id
      self.ext = ext
    }

    public func toXDR() -> Data {
      var xdr = Data()

      xdr.append(self.id.toXDR())
      xdr.append(self.ext.toXDR())

      return xdr
    }

    public enum LedgerKeyStatisticsV2Ext: XDRDiscriminatedUnion {
      case emptyVersion()

      public var discriminant: Int32 {
        switch self {
        case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
        }
      }

      public func toXDR() -> Data {
        var xdr = Data()

        xdr.append(self.discriminant.toXDR())

        switch self {
        case .emptyVersion(): xdr.append(Data())
        }

        return xdr
      }

    }
  }
  public struct LedgerKeyPendingStatistics: XDREncodable {
    public var statisticsID: Uint64
    public var requestID: Uint64
    public var ext: LedgerKeyPendingStatisticsExt

    public init(
        statisticsID: Uint64,
        requestID: Uint64,
        ext: LedgerKeyPendingStatisticsExt) {

      self.statisticsID = statisticsID
      self.requestID = requestID
      self.ext = ext
    }

    public func toXDR() -> Data {
      var xdr = Data()

      xdr.append(self.statisticsID.toXDR())
      xdr.append(self.requestID.toXDR())
      xdr.append(self.ext.toXDR())

      return xdr
    }

    public enum LedgerKeyPendingStatisticsExt: XDRDiscriminatedUnion {
      case emptyVersion()

      public var discriminant: Int32 {
        switch self {
        case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
        }
      }

      public func toXDR() -> Data {
        var xdr = Data()

        xdr.append(self.discriminant.toXDR())

        switch self {
        case .emptyVersion(): xdr.append(Data())
        }

        return xdr
      }

    }
  }
  public struct LedgerKeyContract: XDREncodable {
    public var contractID: Uint64
    public var ext: LedgerKeyContractExt

    public init(
        contractID: Uint64,
        ext: LedgerKeyContractExt) {

      self.contractID = contractID
      self.ext = ext
    }

    public func toXDR() -> Data {
      var xdr = Data()

      xdr.append(self.contractID.toXDR())
      xdr.append(self.ext.toXDR())

      return xdr
    }

    public enum LedgerKeyContractExt: XDRDiscriminatedUnion {
      case emptyVersion()

      public var discriminant: Int32 {
        switch self {
        case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
        }
      }

      public func toXDR() -> Data {
        var xdr = Data()

        xdr.append(self.discriminant.toXDR())

        switch self {
        case .emptyVersion(): xdr.append(Data())
        }

        return xdr
      }

    }
  }
  public struct LedgerKeyAtomicSwapAsk: XDREncodable {
    public var id: Uint64
    public var ext: LedgerKeyAtomicSwapAskExt

    public init(
        id: Uint64,
        ext: LedgerKeyAtomicSwapAskExt) {

      self.id = id
      self.ext = ext
    }

    public func toXDR() -> Data {
      var xdr = Data()

      xdr.append(self.id.toXDR())
      xdr.append(self.ext.toXDR())

      return xdr
    }

    public enum LedgerKeyAtomicSwapAskExt: XDRDiscriminatedUnion {
      case emptyVersion()

      public var discriminant: Int32 {
        switch self {
        case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
        }
      }

      public func toXDR() -> Data {
        var xdr = Data()

        xdr.append(self.discriminant.toXDR())

        switch self {
        case .emptyVersion(): xdr.append(Data())
        }

        return xdr
      }

    }
  }
  public struct LedgerKeyAccountRole: XDREncodable {
    public var id: Uint64
    public var ext: LedgerKeyAccountRoleExt

    public init(
        id: Uint64,
        ext: LedgerKeyAccountRoleExt) {

      self.id = id
      self.ext = ext
    }

    public func toXDR() -> Data {
      var xdr = Data()

      xdr.append(self.id.toXDR())
      xdr.append(self.ext.toXDR())

      return xdr
    }

    public enum LedgerKeyAccountRoleExt: XDRDiscriminatedUnion {
      case emptyVersion()

      public var discriminant: Int32 {
        switch self {
        case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
        }
      }

      public func toXDR() -> Data {
        var xdr = Data()

        xdr.append(self.discriminant.toXDR())

        switch self {
        case .emptyVersion(): xdr.append(Data())
        }

        return xdr
      }

    }
  }
  public struct LedgerKeyAccountRule: XDREncodable {
    public var id: Uint64
    public var ext: LedgerKeyAccountRuleExt

    public init(
        id: Uint64,
        ext: LedgerKeyAccountRuleExt) {

      self.id = id
      self.ext = ext
    }

    public func toXDR() -> Data {
      var xdr = Data()

      xdr.append(self.id.toXDR())
      xdr.append(self.ext.toXDR())

      return xdr
    }

    public enum LedgerKeyAccountRuleExt: XDRDiscriminatedUnion {
      case emptyVersion()

      public var discriminant: Int32 {
        switch self {
        case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
        }
      }

      public func toXDR() -> Data {
        var xdr = Data()

        xdr.append(self.discriminant.toXDR())

        switch self {
        case .emptyVersion(): xdr.append(Data())
        }

        return xdr
      }

    }
  }
  public struct LedgerKeySignerRole: XDREncodable {
    public var id: Uint64
    public var ext: LedgerKeySignerRoleExt

    public init(
        id: Uint64,
        ext: LedgerKeySignerRoleExt) {

      self.id = id
      self.ext = ext
    }

    public func toXDR() -> Data {
      var xdr = Data()

      xdr.append(self.id.toXDR())
      xdr.append(self.ext.toXDR())

      return xdr
    }

    public enum LedgerKeySignerRoleExt: XDRDiscriminatedUnion {
      case emptyVersion()

      public var discriminant: Int32 {
        switch self {
        case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
        }
      }

      public func toXDR() -> Data {
        var xdr = Data()

        xdr.append(self.discriminant.toXDR())

        switch self {
        case .emptyVersion(): xdr.append(Data())
        }

        return xdr
      }

    }
  }
  public struct LedgerKeySignerRule: XDREncodable {
    public var id: Uint64
    public var ext: LedgerKeySignerRuleExt

    public init(
        id: Uint64,
        ext: LedgerKeySignerRuleExt) {

      self.id = id
      self.ext = ext
    }

    public func toXDR() -> Data {
      var xdr = Data()

      xdr.append(self.id.toXDR())
      xdr.append(self.ext.toXDR())

      return xdr
    }

    public enum LedgerKeySignerRuleExt: XDRDiscriminatedUnion {
      case emptyVersion()

      public var discriminant: Int32 {
        switch self {
        case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
        }
      }

      public func toXDR() -> Data {
        var xdr = Data()

        xdr.append(self.discriminant.toXDR())

        switch self {
        case .emptyVersion(): xdr.append(Data())
        }

        return xdr
      }

    }
  }
  public struct LedgerKeyStamp: XDREncodable {
    public var ledgerHash: Hash
    public var licenseHash: Hash
    public var ext: LedgerKeyStampExt

    public init(
        ledgerHash: Hash,
        licenseHash: Hash,
        ext: LedgerKeyStampExt) {

      self.ledgerHash = ledgerHash
      self.licenseHash = licenseHash
      self.ext = ext
    }

    public func toXDR() -> Data {
      var xdr = Data()

      xdr.append(self.ledgerHash.toXDR())
      xdr.append(self.licenseHash.toXDR())
      xdr.append(self.ext.toXDR())

      return xdr
    }

    public enum LedgerKeyStampExt: XDRDiscriminatedUnion {
      case emptyVersion()

      public var discriminant: Int32 {
        switch self {
        case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
        }
      }

      public func toXDR() -> Data {
        var xdr = Data()

        xdr.append(self.discriminant.toXDR())

        switch self {
        case .emptyVersion(): xdr.append(Data())
        }

        return xdr
      }

    }
  }
  public struct LedgerKeyLicense: XDREncodable {
    public var licenseHash: Hash
    public var ext: LedgerKeyLicenseExt

    public init(
        licenseHash: Hash,
        ext: LedgerKeyLicenseExt) {

      self.licenseHash = licenseHash
      self.ext = ext
    }

    public func toXDR() -> Data {
      var xdr = Data()

      xdr.append(self.licenseHash.toXDR())
      xdr.append(self.ext.toXDR())

      return xdr
    }

    public enum LedgerKeyLicenseExt: XDRDiscriminatedUnion {
      case emptyVersion()

      public var discriminant: Int32 {
        switch self {
        case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
        }
      }

      public func toXDR() -> Data {
        var xdr = Data()

        xdr.append(self.discriminant.toXDR())

        switch self {
        case .emptyVersion(): xdr.append(Data())
        }

        return xdr
      }

    }
  }
  public struct LedgerKeyPoll: XDREncodable {
    public var id: Uint64
    public var ext: EmptyExt

    public init(
        id: Uint64,
        ext: EmptyExt) {

      self.id = id
      self.ext = ext
    }

    public func toXDR() -> Data {
      var xdr = Data()

      xdr.append(self.id.toXDR())
      xdr.append(self.ext.toXDR())

      return xdr
    }

  }
  public struct LedgerKeyVote: XDREncodable {
    public var pollID: Uint64
    public var voterID: AccountID
    public var ext: EmptyExt

    public init(
        pollID: Uint64,
        voterID: AccountID,
        ext: EmptyExt) {

      self.pollID = pollID
      self.voterID = voterID
      self.ext = ext
    }

    public func toXDR() -> Data {
      var xdr = Data()

      xdr.append(self.pollID.toXDR())
      xdr.append(self.voterID.toXDR())
      xdr.append(self.ext.toXDR())

      return xdr
    }

  }
  public struct LedgerKeyAccountSpecificRule: XDREncodable {
    public var id: Uint64
    public var ext: EmptyExt

    public init(
        id: Uint64,
        ext: EmptyExt) {

      self.id = id
      self.ext = ext
    }

    public func toXDR() -> Data {
      var xdr = Data()

      xdr.append(self.id.toXDR())
      xdr.append(self.ext.toXDR())

      return xdr
    }

  }
}

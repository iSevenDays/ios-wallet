// Automatically generated by xdrgen
// DO NOT EDIT or your changes may be overwritten

import Foundation

// === xdr source ============================================================

//  struct LedgerEntry
//  {
//      uint32 lastModifiedLedgerSeq; // ledger the LedgerEntry was last changed
//  
//      union switch (LedgerEntryType type)
//      {
//      case ACCOUNT:
//          AccountEntry account;
//      case SIGNER:
//          SignerEntry signer;
//      case FEE:
//          FeeEntry feeState;
//      case BALANCE:
//          BalanceEntry balance;
//      case ASSET:
//          AssetEntry asset;
//      case REFERENCE_ENTRY:
//          ReferenceEntry reference;
//      case STATISTICS:
//          StatisticsEntry stats;
//      case ACCOUNT_LIMITS:
//          AccountLimitsEntry accountLimits;
//  	case ASSET_PAIR: 
//  		AssetPairEntry assetPair;
//  	case OFFER_ENTRY:
//  		OfferEntry offer;
//  	case REVIEWABLE_REQUEST:
//  		ReviewableRequestEntry reviewableRequest;
//  	case EXTERNAL_SYSTEM_ACCOUNT_ID:
//  		ExternalSystemAccountID externalSystemAccountID;
//  	case SALE:
//  		SaleEntry sale;
//  	case KEY_VALUE:
//  	    KeyValueEntry keyValue;
//  	case ACCOUNT_KYC:
//          AccountKYCEntry accountKYC;
//      case EXTERNAL_SYSTEM_ACCOUNT_ID_POOL_ENTRY:
//          ExternalSystemAccountIDPoolEntry externalSystemAccountIDPoolEntry;
//      case LIMITS_V2:
//          LimitsV2Entry limitsV2;
//      case STATISTICS_V2:
//          StatisticsV2Entry statisticsV2;
//      case PENDING_STATISTICS:
//          PendingStatisticsEntry pendingStatistics;
//      case CONTRACT:
//          ContractEntry contract;
//      case ATOMIC_SWAP_ASK:
//          AtomicSwapAskEntry atomicSwapAsk;
//      case ACCOUNT_ROLE:
//          AccountRoleEntry accountRole;
//      case ACCOUNT_RULE:
//          AccountRuleEntry accountRule;
//      case SIGNER_RULE:
//          SignerRuleEntry signerRule;
//      case SIGNER_ROLE:
//          SignerRoleEntry signerRole;
//      case LICENSE:
//          LicenseEntry license;
//      case STAMP:
//          StampEntry stamp;
//      case POLL:
//          PollEntry poll;
//      case VOTE:
//          VoteEntry vote;
//      case ACCOUNT_SPECIFIC_RULE:
//          AccountSpecificRuleEntry accountSpecificRule;
//      }
//      data;
//  
//      // reserved for future use
//      union switch (LedgerVersion v)
//      {
//      case EMPTY_VERSION:
//          void;
//      }
//      ext;
//  };

//  ===========================================================================
public struct LedgerEntry: XDREncodable {
  public var lastModifiedLedgerSeq: Uint32
  public var data: LedgerEntryData
  public var ext: LedgerEntryExt

  public init(
      lastModifiedLedgerSeq: Uint32,
      data: LedgerEntryData,
      ext: LedgerEntryExt) {

    self.lastModifiedLedgerSeq = lastModifiedLedgerSeq
    self.data = data
    self.ext = ext
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.lastModifiedLedgerSeq.toXDR())
    xdr.append(self.data.toXDR())
    xdr.append(self.ext.toXDR())

    return xdr
  }

  public enum LedgerEntryData: XDRDiscriminatedUnion {
    case account(AccountEntry)
    case signer(SignerEntry)
    case fee(FeeEntry)
    case balance(BalanceEntry)
    case asset(AssetEntry)
    case referenceEntry(ReferenceEntry)
    case statistics(StatisticsEntry)
    case accountLimits(AccountLimitsEntry)
    case assetPair(AssetPairEntry)
    case offerEntry(OfferEntry)
    case reviewableRequest(ReviewableRequestEntry)
    case externalSystemAccountId(ExternalSystemAccountID)
    case sale(SaleEntry)
    case keyValue(KeyValueEntry)
    case accountKyc(AccountKYCEntry)
    case externalSystemAccountIdPoolEntry(ExternalSystemAccountIDPoolEntry)
    case limitsV2(LimitsV2Entry)
    case statisticsV2(StatisticsV2Entry)
    case pendingStatistics(PendingStatisticsEntry)
    case contract(ContractEntry)
    case atomicSwapAsk(AtomicSwapAskEntry)
    case accountRole(AccountRoleEntry)
    case accountRule(AccountRuleEntry)
    case signerRule(SignerRuleEntry)
    case signerRole(SignerRoleEntry)
    case license(LicenseEntry)
    case stamp(StampEntry)
    case poll(PollEntry)
    case vote(VoteEntry)
    case accountSpecificRule(AccountSpecificRuleEntry)

    public var discriminant: Int32 {
      switch self {
      case .account: return LedgerEntryType.account.rawValue
      case .signer: return LedgerEntryType.signer.rawValue
      case .fee: return LedgerEntryType.fee.rawValue
      case .balance: return LedgerEntryType.balance.rawValue
      case .asset: return LedgerEntryType.asset.rawValue
      case .referenceEntry: return LedgerEntryType.referenceEntry.rawValue
      case .statistics: return LedgerEntryType.statistics.rawValue
      case .accountLimits: return LedgerEntryType.accountLimits.rawValue
      case .assetPair: return LedgerEntryType.assetPair.rawValue
      case .offerEntry: return LedgerEntryType.offerEntry.rawValue
      case .reviewableRequest: return LedgerEntryType.reviewableRequest.rawValue
      case .externalSystemAccountId: return LedgerEntryType.externalSystemAccountId.rawValue
      case .sale: return LedgerEntryType.sale.rawValue
      case .keyValue: return LedgerEntryType.keyValue.rawValue
      case .accountKyc: return LedgerEntryType.accountKyc.rawValue
      case .externalSystemAccountIdPoolEntry: return LedgerEntryType.externalSystemAccountIdPoolEntry.rawValue
      case .limitsV2: return LedgerEntryType.limitsV2.rawValue
      case .statisticsV2: return LedgerEntryType.statisticsV2.rawValue
      case .pendingStatistics: return LedgerEntryType.pendingStatistics.rawValue
      case .contract: return LedgerEntryType.contract.rawValue
      case .atomicSwapAsk: return LedgerEntryType.atomicSwapAsk.rawValue
      case .accountRole: return LedgerEntryType.accountRole.rawValue
      case .accountRule: return LedgerEntryType.accountRule.rawValue
      case .signerRule: return LedgerEntryType.signerRule.rawValue
      case .signerRole: return LedgerEntryType.signerRole.rawValue
      case .license: return LedgerEntryType.license.rawValue
      case .stamp: return LedgerEntryType.stamp.rawValue
      case .poll: return LedgerEntryType.poll.rawValue
      case .vote: return LedgerEntryType.vote.rawValue
      case .accountSpecificRule: return LedgerEntryType.accountSpecificRule.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()

      xdr.append(self.discriminant.toXDR())

      switch self {
      case .account(let data): xdr.append(data.toXDR())
      case .signer(let data): xdr.append(data.toXDR())
      case .fee(let data): xdr.append(data.toXDR())
      case .balance(let data): xdr.append(data.toXDR())
      case .asset(let data): xdr.append(data.toXDR())
      case .referenceEntry(let data): xdr.append(data.toXDR())
      case .statistics(let data): xdr.append(data.toXDR())
      case .accountLimits(let data): xdr.append(data.toXDR())
      case .assetPair(let data): xdr.append(data.toXDR())
      case .offerEntry(let data): xdr.append(data.toXDR())
      case .reviewableRequest(let data): xdr.append(data.toXDR())
      case .externalSystemAccountId(let data): xdr.append(data.toXDR())
      case .sale(let data): xdr.append(data.toXDR())
      case .keyValue(let data): xdr.append(data.toXDR())
      case .accountKyc(let data): xdr.append(data.toXDR())
      case .externalSystemAccountIdPoolEntry(let data): xdr.append(data.toXDR())
      case .limitsV2(let data): xdr.append(data.toXDR())
      case .statisticsV2(let data): xdr.append(data.toXDR())
      case .pendingStatistics(let data): xdr.append(data.toXDR())
      case .contract(let data): xdr.append(data.toXDR())
      case .atomicSwapAsk(let data): xdr.append(data.toXDR())
      case .accountRole(let data): xdr.append(data.toXDR())
      case .accountRule(let data): xdr.append(data.toXDR())
      case .signerRule(let data): xdr.append(data.toXDR())
      case .signerRole(let data): xdr.append(data.toXDR())
      case .license(let data): xdr.append(data.toXDR())
      case .stamp(let data): xdr.append(data.toXDR())
      case .poll(let data): xdr.append(data.toXDR())
      case .vote(let data): xdr.append(data.toXDR())
      case .accountSpecificRule(let data): xdr.append(data.toXDR())
      }

      return xdr
    }

  }
  public enum LedgerEntryExt: XDRDiscriminatedUnion {
    case emptyVersion()

    public var discriminant: Int32 {
      switch self {
      case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()

      xdr.append(self.discriminant.toXDR())

      switch self {
      case .emptyVersion(): xdr.append(Data())
      }

      return xdr
    }

  }
}

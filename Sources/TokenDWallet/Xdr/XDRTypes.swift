// Automatically generated by xdrgen 
// DO NOT EDIT or your changes may be overwritten

import Foundation

// === xdr source ============================================================

//  typedef opaque Value<>;

//  ===========================================================================
public typealias Value = Data

// === xdr source ============================================================

//  struct SCPBallot
//  {
//      uint32 counter; // n
//      Value value;    // x
//  };

//  ===========================================================================
public struct SCPBallot: XDREncodable {
  public var counter: Uint32
  public var value: Value

  public init(
      counter: Uint32,
      value: Value) {

    self.counter = counter
    self.value = value
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.counter.toXDR())
    xdr.append(self.value.toXDR())

    return xdr
  }
}

// === xdr source ============================================================

//  enum SCPStatementType
//  {
//      PREPARE = 0,
//      CONFIRM = 1,
//      EXTERNALIZE = 2,
//      NOMINATE = 3
//  };

//  ===========================================================================
public enum SCPStatementType: Int32, XDREnum {
  case prepare = 0
  case confirm = 1
  case externalize = 2
  case nominate = 3
}

// === xdr source ============================================================

//  struct SCPNomination
//  {
//      Hash quorumSetHash; // D
//      Value votes<>;      // X
//      Value accepted<>;   // Y
//  };

//  ===========================================================================
public struct SCPNomination: XDREncodable {
  public var quorumSetHash: Hash
  public var votes: [Value]
  public var accepted: [Value]

  public init(
      quorumSetHash: Hash,
      votes: [Value],
      accepted: [Value]) {

    self.quorumSetHash = quorumSetHash
    self.votes = votes
    self.accepted = accepted
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.quorumSetHash.toXDR())
    xdr.append(self.votes.toXDR())
    xdr.append(self.accepted.toXDR())

    return xdr
  }
}

// === xdr source ============================================================

//  struct SCPStatement
//  {
//      NodeID nodeID;    // v
//      uint64 slotIndex; // i
//  
//      union switch (SCPStatementType type)
//      {
//      case PREPARE:
//          struct
//          {
//              Hash quorumSetHash;       // D
//              SCPBallot ballot;         // b
//              SCPBallot* prepared;      // p
//              SCPBallot* preparedPrime; // p'
//              uint32 nC;                // c.n
//              uint32 nH;                // h.n
//          } prepare;
//      case CONFIRM:
//          struct
//          {
//              SCPBallot ballot;   // b
//              uint32 nPrepared;   // p.n
//              uint32 nCommit;     // c.n
//              uint32 nH;          // h.n
//              Hash quorumSetHash; // D
//          } confirm;
//      case EXTERNALIZE:
//          struct
//          {
//              SCPBallot commit;         // c
//              uint32 nH;                // h.n
//              Hash commitQuorumSetHash; // D used before EXTERNALIZE
//          } externalize;
//      case NOMINATE:
//          SCPNomination nominate;
//      }
//      pledges;
//  };

//  ===========================================================================
public struct SCPStatement: XDREncodable {
  public var nodeID: NodeID
  public var slotIndex: Uint64
  public var pledges: SCPStatementPledges

  public init(
      nodeID: NodeID,
      slotIndex: Uint64,
      pledges: SCPStatementPledges) {

    self.nodeID = nodeID
    self.slotIndex = slotIndex
    self.pledges = pledges
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.nodeID.toXDR())
    xdr.append(self.slotIndex.toXDR())
    xdr.append(self.pledges.toXDR())

    return xdr
  }

  public enum SCPStatementPledges: XDRDiscriminatedUnion {
    case prepare(SCPStatementPrepare)
    case confirm(SCPStatementConfirm)
    case externalize(SCPStatementExternalize)
    case nominate(SCPNomination)

    public var discriminant: Int32 {
      switch self {
      case .prepare: return SCPStatementType.prepare.rawValue
      case .confirm: return SCPStatementType.confirm.rawValue
      case .externalize: return SCPStatementType.externalize.rawValue
      case .nominate: return SCPStatementType.nominate.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .prepare(let data): xdr.append(data.toXDR())
      case .confirm(let data): xdr.append(data.toXDR())
      case .externalize(let data): xdr.append(data.toXDR())
      case .nominate(let data): xdr.append(data.toXDR())
      }

      return xdr
    }

    public struct SCPStatementPrepare: XDREncodable {
      public var quorumSetHash: Hash
      public var ballot: SCPBallot
      public var prepared: SCPBallot?
      public var preparedPrime: SCPBallot?
      public var nC: Uint32
      public var nH: Uint32

      public init(
          quorumSetHash: Hash,
          ballot: SCPBallot,
          prepared: SCPBallot?,
          preparedPrime: SCPBallot?,
          nC: Uint32,
          nH: Uint32) {

        self.quorumSetHash = quorumSetHash
        self.ballot = ballot
        self.prepared = prepared
        self.preparedPrime = preparedPrime
        self.nC = nC
        self.nH = nH
      }

      public func toXDR() -> Data {
        var xdr = Data()

        xdr.append(self.quorumSetHash.toXDR())
        xdr.append(self.ballot.toXDR())
        xdr.append(self.prepared.toXDR())
        xdr.append(self.preparedPrime.toXDR())
        xdr.append(self.nC.toXDR())
        xdr.append(self.nH.toXDR())

        return xdr
      }

    }
    public struct SCPStatementConfirm: XDREncodable {
      public var ballot: SCPBallot
      public var nPrepared: Uint32
      public var nCommit: Uint32
      public var nH: Uint32
      public var quorumSetHash: Hash

      public init(
          ballot: SCPBallot,
          nPrepared: Uint32,
          nCommit: Uint32,
          nH: Uint32,
          quorumSetHash: Hash) {

        self.ballot = ballot
        self.nPrepared = nPrepared
        self.nCommit = nCommit
        self.nH = nH
        self.quorumSetHash = quorumSetHash
      }

      public func toXDR() -> Data {
        var xdr = Data()

        xdr.append(self.ballot.toXDR())
        xdr.append(self.nPrepared.toXDR())
        xdr.append(self.nCommit.toXDR())
        xdr.append(self.nH.toXDR())
        xdr.append(self.quorumSetHash.toXDR())

        return xdr
      }

    }
    public struct SCPStatementExternalize: XDREncodable {
      public var commit: SCPBallot
      public var nH: Uint32
      public var commitQuorumSetHash: Hash

      public init(
          commit: SCPBallot,
          nH: Uint32,
          commitQuorumSetHash: Hash) {

        self.commit = commit
        self.nH = nH
        self.commitQuorumSetHash = commitQuorumSetHash
      }

      public func toXDR() -> Data {
        var xdr = Data()

        xdr.append(self.commit.toXDR())
        xdr.append(self.nH.toXDR())
        xdr.append(self.commitQuorumSetHash.toXDR())

        return xdr
      }

    }
  }
}

// === xdr source ============================================================

//  struct SCPEnvelope
//  {
//      SCPStatement statement;
//      Signature signature;
//  };

//  ===========================================================================
public struct SCPEnvelope: XDREncodable {
  public var statement: SCPStatement
  public var signature: Signature

  public init(
      statement: SCPStatement,
      signature: Signature) {

    self.statement = statement
    self.signature = signature
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.statement.toXDR())
    xdr.append(self.signature.toXDR())

    return xdr
  }
}

// === xdr source ============================================================

//  struct SCPQuorumSet
//  {
//      uint32 threshold;
//      PublicKey validators<>;
//      SCPQuorumSet innerSets<>;
//  };

//  ===========================================================================
public struct SCPQuorumSet: XDREncodable {
  public var threshold: Uint32
  public var validators: [PublicKey]
  public var innerSets: [SCPQuorumSet]

  public init(
      threshold: Uint32,
      validators: [PublicKey],
      innerSets: [SCPQuorumSet]) {

    self.threshold = threshold
    self.validators = validators
    self.innerSets = innerSets
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.threshold.toXDR())
    xdr.append(self.validators.toXDR())
    xdr.append(self.innerSets.toXDR())

    return xdr
  }
}

// === xdr source ============================================================

//  struct AccountKYCEntry
//  {
//      AccountID accountID;
//      longstring KYCData;
//  
//      // reserved for future use
//      union switch (LedgerVersion v)
//      {
//      case EMPTY_VERSION:
//          void;
//      }
//      ext;
//  };

//  ===========================================================================
public struct AccountKYCEntry: XDREncodable {
  public var accountID: AccountID
  public var KYCData: Longstring
  public var ext: AccountKYCEntryExt

  public init(
      accountID: AccountID,
      KYCData: Longstring,
      ext: AccountKYCEntryExt) {

    self.accountID = accountID
    self.KYCData = KYCData
    self.ext = ext
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.accountID.toXDR())
    xdr.append(self.KYCData.toXDR())
    xdr.append(self.ext.toXDR())

    return xdr
  }

  public enum AccountKYCEntryExt: XDRDiscriminatedUnion {
    case emptyVersion()

    public var discriminant: Int32 {
      switch self {
      case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .emptyVersion(): xdr.append(Data())
      }

      return xdr
    }

  }
}

// === xdr source ============================================================

//  struct AccountLimitsEntry
//  {
//      AccountID accountID;
//      Limits limits;
//  
//      union switch (LedgerVersion v)
//      {
//      case EMPTY_VERSION:
//          void;
//      }
//      ext;
//  };

//  ===========================================================================
public struct AccountLimitsEntry: XDREncodable {
  public var accountID: AccountID
  public var limits: Limits
  public var ext: AccountLimitsEntryExt

  public init(
      accountID: AccountID,
      limits: Limits,
      ext: AccountLimitsEntryExt) {

    self.accountID = accountID
    self.limits = limits
    self.ext = ext
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.accountID.toXDR())
    xdr.append(self.limits.toXDR())
    xdr.append(self.ext.toXDR())

    return xdr
  }

  public enum AccountLimitsEntryExt: XDRDiscriminatedUnion {
    case emptyVersion()

    public var discriminant: Int32 {
      switch self {
      case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .emptyVersion(): xdr.append(Data())
      }

      return xdr
    }

  }
}

// === xdr source ============================================================

//  struct AccountRolePermissionEntry
//  {
//      uint64 permissionID;
//      uint64 accountRoleID;
//      OperationType opType;
//  
//      // reserved for future use
//      union switch (LedgerVersion v)
//      {
//      case EMPTY_VERSION:
//          void;
//      }
//      ext;
//  };

//  ===========================================================================
public struct AccountRolePermissionEntry: XDREncodable {
  public var permissionID: Uint64
  public var accountRoleID: Uint64
  public var opType: OperationType
  public var ext: AccountRolePermissionEntryExt

  public init(
      permissionID: Uint64,
      accountRoleID: Uint64,
      opType: OperationType,
      ext: AccountRolePermissionEntryExt) {

    self.permissionID = permissionID
    self.accountRoleID = accountRoleID
    self.opType = opType
    self.ext = ext
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.permissionID.toXDR())
    xdr.append(self.accountRoleID.toXDR())
    xdr.append(self.opType.toXDR())
    xdr.append(self.ext.toXDR())

    return xdr
  }

  public enum AccountRolePermissionEntryExt: XDRDiscriminatedUnion {
    case emptyVersion()

    public var discriminant: Int32 {
      switch self {
      case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .emptyVersion(): xdr.append(Data())
      }

      return xdr
    }

  }
}

// === xdr source ============================================================

//  struct AccountRoleEntry {
//      uint64 accountRoleID;
//      longstring accountRoleName;
//  
//      // reserved for future use
//      union switch (LedgerVersion v) {
//      case EMPTY_VERSION:
//          void;
//      }
//      ext;
//  };

//  ===========================================================================
public struct AccountRoleEntry: XDREncodable {
  public var accountRoleID: Uint64
  public var accountRoleName: Longstring
  public var ext: AccountRoleEntryExt

  public init(
      accountRoleID: Uint64,
      accountRoleName: Longstring,
      ext: AccountRoleEntryExt) {

    self.accountRoleID = accountRoleID
    self.accountRoleName = accountRoleName
    self.ext = ext
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.accountRoleID.toXDR())
    xdr.append(self.accountRoleName.toXDR())
    xdr.append(self.ext.toXDR())

    return xdr
  }

  public enum AccountRoleEntryExt: XDRDiscriminatedUnion {
    case emptyVersion()

    public var discriminant: Int32 {
      switch self {
      case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .emptyVersion(): xdr.append(Data())
      }

      return xdr
    }

  }
}

// === xdr source ============================================================

//  struct AccountTypeLimitsEntry
//  {
//  	AccountType accountType;
//      Limits limits;
//  
//  	// reserved for future use
//      union switch (LedgerVersion v)
//      {
//      case EMPTY_VERSION:
//          void;
//      }
//      ext;
//  };

//  ===========================================================================
public struct AccountTypeLimitsEntry: XDREncodable {
  public var accountType: AccountType
  public var limits: Limits
  public var ext: AccountTypeLimitsEntryExt

  public init(
      accountType: AccountType,
      limits: Limits,
      ext: AccountTypeLimitsEntryExt) {

    self.accountType = accountType
    self.limits = limits
    self.ext = ext
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.accountType.toXDR())
    xdr.append(self.limits.toXDR())
    xdr.append(self.ext.toXDR())

    return xdr
  }

  public enum AccountTypeLimitsEntryExt: XDRDiscriminatedUnion {
    case emptyVersion()

    public var discriminant: Int32 {
      switch self {
      case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .emptyVersion(): xdr.append(Data())
      }

      return xdr
    }

  }
}

// === xdr source ============================================================

//  enum SignerType
//  {
//  	READER = 1,                  // can only read data from API and Horizon
//  	NOT_VERIFIED_ACC_MANAGER = 2,// can manage not verified account and block/unblock general
//  	GENERAL_ACC_MANAGER = 4,     // allowed to create account, block/unblock, change limits for particular general account
//  	DIRECT_DEBIT_OPERATOR = 8, // allowed to perform direct debit operation
//  	ASSET_MANAGER = 16, // allowed to create assets/asset pairs and update policies, set fees
//  	ASSET_RATE_MANAGER = 32, // allowed to set physical asset price
//  	BALANCE_MANAGER = 64, // allowed to create balances, spend assets from balances
//  	ISSUANCE_MANAGER = 128, // allowed to make preissuance request
//  	INVOICE_MANAGER = 256, // allowed to create payment requests to other accounts
//  	PAYMENT_OPERATOR = 512, // allowed to review payment requests
//  	LIMITS_MANAGER = 1024, // allowed to change limits
//  	ACCOUNT_MANAGER = 2048, // allowed to add/delete signers and trust
//  	COMMISSION_BALANCE_MANAGER  = 4096,// allowed to spend from commission balances
//  	OPERATIONAL_BALANCE_MANAGER = 8192, // allowed to spend from operational balances
//  	EVENTS_CHECKER = 16384, // allow to check and trigger events
//  	EXCHANGE_ACC_MANAGER = 32768, // can manage exchange account
//  	SYNDICATE_ACC_MANAGER = 65536, // can manage syndicate account
//  	USER_ASSET_MANAGER = 131072, // can review sale, asset creation/update requests
//  	USER_ISSUANCE_MANAGER = 262144, // can review pre-issuance/issuance requests
//  	WITHDRAW_MANAGER = 524288, // can review withdraw requests
//  	FEES_MANAGER = 1048576, // can set fee
//  	TX_SENDER = 2097152, // can send tx
//  	AML_ALERT_MANAGER = 4194304, // can manage AML alert request
//  	AML_ALERT_REVIEWER = 8388608, // can review aml alert requests
//  	KYC_ACC_MANAGER = 16777216, // can manage kyc
//  	KYC_SUPER_ADMIN = 33554432,
//  	EXTERNAL_SYSTEM_ACCOUNT_ID_POOL_MANAGER = 67108864,
//      KEY_VALUE_MANAGER = 134217728, // can manage keyValue
//      SUPER_ISSUANCE_MANAGER = 268435456,
//      CONTRACT_MANAGER = 536870912,
//      ACCOUNT_ROLE_PERMISSION_MANAGER = 1073741824 // can manage account role permissions
//  };

//  ===========================================================================
public enum SignerType: Int32, XDREnum {
  case reader = 1
  case notVerifiedAccManager = 2
  case generalAccManager = 4
  case directDebitOperator = 8
  case assetManager = 16
  case assetRateManager = 32
  case balanceManager = 64
  case issuanceManager = 128
  case invoiceManager = 256
  case paymentOperator = 512
  case limitsManager = 1024
  case accountManager = 2048
  case commissionBalanceManager = 4096
  case operationalBalanceManager = 8192
  case eventsChecker = 16384
  case exchangeAccManager = 32768
  case syndicateAccManager = 65536
  case userAssetManager = 131072
  case userIssuanceManager = 262144
  case withdrawManager = 524288
  case feesManager = 1048576
  case txSender = 2097152
  case amlAlertManager = 4194304
  case amlAlertReviewer = 8388608
  case kycAccManager = 16777216
  case kycSuperAdmin = 33554432
  case externalSystemAccountIdPoolManager = 67108864
  case keyValueManager = 134217728
  case superIssuanceManager = 268435456
  case contractManager = 536870912
  case accountRolePermissionManager = 1073741824
}

// === xdr source ============================================================

//  struct Signer
//  {
//      AccountID pubKey;
//      uint32 weight; // really only need 1byte
//  	uint32 signerType;
//  	uint32 identity;
//  	string256 name;
//  
//  	 // reserved for future use
//      union switch (LedgerVersion v)
//      {
//      case EMPTY_VERSION:
//          void;
//      }
//      ext;
//  };

//  ===========================================================================
public struct Signer: XDREncodable {
  public var pubKey: AccountID
  public var weight: Uint32
  public var signerType: Uint32
  public var identity: Uint32
  public var name: String256
  public var ext: SignerExt

  public init(
      pubKey: AccountID,
      weight: Uint32,
      signerType: Uint32,
      identity: Uint32,
      name: String256,
      ext: SignerExt) {

    self.pubKey = pubKey
    self.weight = weight
    self.signerType = signerType
    self.identity = identity
    self.name = name
    self.ext = ext
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.pubKey.toXDR())
    xdr.append(self.weight.toXDR())
    xdr.append(self.signerType.toXDR())
    xdr.append(self.identity.toXDR())
    xdr.append(self.name.toXDR())
    xdr.append(self.ext.toXDR())

    return xdr
  }

  public enum SignerExt: XDRDiscriminatedUnion {
    case emptyVersion()

    public var discriminant: Int32 {
      switch self {
      case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .emptyVersion(): xdr.append(Data())
      }

      return xdr
    }

  }
}

// === xdr source ============================================================

//  struct TrustEntry
//  {
//      AccountID allowedAccount;
//      BalanceID balanceToUse;
//  
//  	 // reserved for future use
//      union switch (LedgerVersion v)
//      {
//      case EMPTY_VERSION:
//          void;
//      }
//      ext;
//  };

//  ===========================================================================
public struct TrustEntry: XDREncodable {
  public var allowedAccount: AccountID
  public var balanceToUse: BalanceID
  public var ext: TrustEntryExt

  public init(
      allowedAccount: AccountID,
      balanceToUse: BalanceID,
      ext: TrustEntryExt) {

    self.allowedAccount = allowedAccount
    self.balanceToUse = balanceToUse
    self.ext = ext
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.allowedAccount.toXDR())
    xdr.append(self.balanceToUse.toXDR())
    xdr.append(self.ext.toXDR())

    return xdr
  }

  public enum TrustEntryExt: XDRDiscriminatedUnion {
    case emptyVersion()

    public var discriminant: Int32 {
      switch self {
      case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .emptyVersion(): xdr.append(Data())
      }

      return xdr
    }

  }
}

// === xdr source ============================================================

//  struct Limits
//  {
//      int64 dailyOut;
//  	int64 weeklyOut;
//  	int64 monthlyOut;
//      int64 annualOut;
//  
//  	 // reserved for future use
//      union switch (LedgerVersion v)
//      {
//      case EMPTY_VERSION:
//          void;
//      }
//      ext;
//      
//  };

//  ===========================================================================
public struct Limits: XDREncodable {
  public var dailyOut: Int64
  public var weeklyOut: Int64
  public var monthlyOut: Int64
  public var annualOut: Int64
  public var ext: LimitsExt

  public init(
      dailyOut: Int64,
      weeklyOut: Int64,
      monthlyOut: Int64,
      annualOut: Int64,
      ext: LimitsExt) {

    self.dailyOut = dailyOut
    self.weeklyOut = weeklyOut
    self.monthlyOut = monthlyOut
    self.annualOut = annualOut
    self.ext = ext
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.dailyOut.toXDR())
    xdr.append(self.weeklyOut.toXDR())
    xdr.append(self.monthlyOut.toXDR())
    xdr.append(self.annualOut.toXDR())
    xdr.append(self.ext.toXDR())

    return xdr
  }

  public enum LimitsExt: XDRDiscriminatedUnion {
    case emptyVersion()

    public var discriminant: Int32 {
      switch self {
      case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .emptyVersion(): xdr.append(Data())
      }

      return xdr
    }

  }
}

// === xdr source ============================================================

//  enum AccountPolicies
//  {
//  	NO_PERMISSIONS = 0,
//  	ALLOW_TO_CREATE_USER_VIA_API = 1
//  };

//  ===========================================================================
public enum AccountPolicies: Int32, XDREnum {
  case noPermissions = 0
  case allowToCreateUserViaApi = 1
}

// === xdr source ============================================================

//  enum AccountType
//  {
//  	OPERATIONAL = 1,       // operational account of the system 
//  	GENERAL = 2,           // general account can perform payments, setoptions, be source account for tx, etc.
//  	COMMISSION = 3,        // commission account
//  	MASTER = 4,            // master account
//      NOT_VERIFIED = 5,
//  	SYNDICATE = 6, // can create asset
//  	EXCHANGE = 7,
//  	ACCREDITED_INVESTOR = 8,
//  	INSTITUTIONAL_INVESTOR = 9,
//  	VERIFIED = 10
//  };

//  ===========================================================================
public enum AccountType: Int32, XDREnum {
  case operational = 1
  case general = 2
  case commission = 3
  case master = 4
  case notVerified = 5
  case syndicate = 6
  case exchange = 7
  case accreditedInvestor = 8
  case institutionalInvestor = 9
  case verified = 10
}

// === xdr source ============================================================

//  enum BlockReasons
//  {
//  	RECOVERY_REQUEST = 1,
//  	KYC_UPDATE = 2,
//  	SUSPICIOUS_BEHAVIOR = 4,
//  	TOO_MANY_KYC_UPDATE_REQUESTS = 8,
//  	WITHDRAWAL = 16
//  };

//  ===========================================================================
public enum BlockReasons: Int32, XDREnum {
  case recoveryRequest = 1
  case kycUpdate = 2
  case suspiciousBehavior = 4
  case tooManyKycUpdateRequests = 8
  case withdrawal = 16
}

// === xdr source ============================================================

//  struct AccountEntryExtended
//  {
//      uint32 kycLevel;
//      uint64* accountRole;
//  
//      // reserved for future use
//      union switch (LedgerVersion v)
//      {
//      case EMPTY_VERSION:
//          void;
//      }
//      ext;
//  };

//  ===========================================================================
public struct AccountEntryExtended: XDREncodable {
  public var kycLevel: Uint32
  public var accountRole: Uint64?
  public var ext: AccountEntryExtendedExt

  public init(
      kycLevel: Uint32,
      accountRole: Uint64?,
      ext: AccountEntryExtendedExt) {

    self.kycLevel = kycLevel
    self.accountRole = accountRole
    self.ext = ext
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.kycLevel.toXDR())
    xdr.append(self.accountRole.toXDR())
    xdr.append(self.ext.toXDR())

    return xdr
  }

  public enum AccountEntryExtendedExt: XDRDiscriminatedUnion {
    case emptyVersion()

    public var discriminant: Int32 {
      switch self {
      case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .emptyVersion(): xdr.append(Data())
      }

      return xdr
    }

  }
}

// === xdr source ============================================================

//  struct AccountEntry
//  {
//      AccountID accountID;      // master public key for this account
//      AccountID recoveryID;
//  
//      // fields used for signatures
//      // thresholds stores unsigned bytes: [weight of master|low|medium|high]
//      Thresholds thresholds;
//  
//      Signer signers<>; // possible signers for this account
//      Limits* limits;
//  
//  	uint32 blockReasons;
//      AccountType accountType; // type of the account
//      
//      // Referral marketing
//      AccountID* referrer;     // parent account
//  
//  	int32 policies;
//  
//      // reserved for future use
//      union switch (LedgerVersion v)
//      {
//      case EMPTY_VERSION:
//          void;
//      case USE_KYC_LEVEL:
//          uint32 kycLevel;
//      case REPLACE_ACCOUNT_TYPES_WITH_POLICIES:
//          AccountEntryExtended accountEntryExt;
//      }
//      ext;
//  };

//  ===========================================================================
public struct AccountEntry: XDREncodable {
  public var accountID: AccountID
  public var recoveryID: AccountID
  public var thresholds: Thresholds
  public var signers: [Signer]
  public var limits: Limits?
  public var blockReasons: Uint32
  public var accountType: AccountType
  public var referrer: AccountID?
  public var policies: Int32
  public var ext: AccountEntryExt

  public init(
      accountID: AccountID,
      recoveryID: AccountID,
      thresholds: Thresholds,
      signers: [Signer],
      limits: Limits?,
      blockReasons: Uint32,
      accountType: AccountType,
      referrer: AccountID?,
      policies: Int32,
      ext: AccountEntryExt) {

    self.accountID = accountID
    self.recoveryID = recoveryID
    self.thresholds = thresholds
    self.signers = signers
    self.limits = limits
    self.blockReasons = blockReasons
    self.accountType = accountType
    self.referrer = referrer
    self.policies = policies
    self.ext = ext
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.accountID.toXDR())
    xdr.append(self.recoveryID.toXDR())
    xdr.append(self.thresholds.toXDR())
    xdr.append(self.signers.toXDR())
    xdr.append(self.limits.toXDR())
    xdr.append(self.blockReasons.toXDR())
    xdr.append(self.accountType.toXDR())
    xdr.append(self.referrer.toXDR())
    xdr.append(self.policies.toXDR())
    xdr.append(self.ext.toXDR())

    return xdr
  }

  public enum AccountEntryExt: XDRDiscriminatedUnion {
    case emptyVersion()
    case useKycLevel(Uint32)
    case replaceAccountTypesWithPolicies(AccountEntryExtended)

    public var discriminant: Int32 {
      switch self {
      case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
      case .useKycLevel: return LedgerVersion.useKycLevel.rawValue
      case .replaceAccountTypesWithPolicies: return LedgerVersion.replaceAccountTypesWithPolicies.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .emptyVersion(): xdr.append(Data())
      case .useKycLevel(let data): xdr.append(data.toXDR())
      case .replaceAccountTypesWithPolicies(let data): xdr.append(data.toXDR())
      }

      return xdr
    }

  }
}

// === xdr source ============================================================

//  enum AssetPairPolicy
//  {
//  	TRADEABLE_SECONDARY_MARKET = 1, // if not set pair can not be traided on secondary market
//  	PHYSICAL_PRICE_RESTRICTION = 2, // if set, then prices for new offers must be greater then physical price with correction
//  	CURRENT_PRICE_RESTRICTION = 4 // if set, then price for new offers must be in interval of (1 +- maxPriceStep)*currentPrice
//  };

//  ===========================================================================
public enum AssetPairPolicy: Int32, XDREnum {
  case tradeableSecondaryMarket = 1
  case physicalPriceRestriction = 2
  case currentPriceRestriction = 4
}

// === xdr source ============================================================

//  struct AssetPairEntry
//  {
//      AssetCode base;
//  	AssetCode quote;
//  
//      int64 currentPrice;
//      int64 physicalPrice;
//  
//  	int64 physicalPriceCorrection; // correction of physical price in percents. If physical price is set and restriction by physical price set, mininal price for offer for this pair will be physicalPrice * physicalPriceCorrection
//  	int64 maxPriceStep; // max price step in percent. User is allowed to set offer with price < (1 - maxPriceStep)*currentPrice and > (1 + maxPriceStep)*currentPrice
//  
//  
//  	int32 policies;
//  
//      // reserved for future use
//      union switch (LedgerVersion v)
//      {
//      case EMPTY_VERSION:
//          void;
//      }
//      ext;
//  };

//  ===========================================================================
public struct AssetPairEntry: XDREncodable {
  public var base: AssetCode
  public var quote: AssetCode
  public var currentPrice: Int64
  public var physicalPrice: Int64
  public var physicalPriceCorrection: Int64
  public var maxPriceStep: Int64
  public var policies: Int32
  public var ext: AssetPairEntryExt

  public init(
      base: AssetCode,
      quote: AssetCode,
      currentPrice: Int64,
      physicalPrice: Int64,
      physicalPriceCorrection: Int64,
      maxPriceStep: Int64,
      policies: Int32,
      ext: AssetPairEntryExt) {

    self.base = base
    self.quote = quote
    self.currentPrice = currentPrice
    self.physicalPrice = physicalPrice
    self.physicalPriceCorrection = physicalPriceCorrection
    self.maxPriceStep = maxPriceStep
    self.policies = policies
    self.ext = ext
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.base.toXDR())
    xdr.append(self.quote.toXDR())
    xdr.append(self.currentPrice.toXDR())
    xdr.append(self.physicalPrice.toXDR())
    xdr.append(self.physicalPriceCorrection.toXDR())
    xdr.append(self.maxPriceStep.toXDR())
    xdr.append(self.policies.toXDR())
    xdr.append(self.ext.toXDR())

    return xdr
  }

  public enum AssetPairEntryExt: XDRDiscriminatedUnion {
    case emptyVersion()

    public var discriminant: Int32 {
      switch self {
      case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .emptyVersion(): xdr.append(Data())
      }

      return xdr
    }

  }
}

// === xdr source ============================================================

//  enum AssetPolicy
//  {
//  	TRANSFERABLE = 1,
//  	BASE_ASSET = 2,
//  	STATS_QUOTE_ASSET = 4,
//  	WITHDRAWABLE = 8,
//  	TWO_STEP_WITHDRAWAL = 16,
//  	REQUIRES_KYC = 32,
//  	ISSUANCE_MANUAL_REVIEW_REQUIRED = 64,
//  	REQUIRES_VERIFICATION = 128
//  };

//  ===========================================================================
public enum AssetPolicy: Int32, XDREnum {
  case transferable = 1
  case baseAsset = 2
  case statsQuoteAsset = 4
  case withdrawable = 8
  case twoStepWithdrawal = 16
  case requiresKyc = 32
  case issuanceManualReviewRequired = 64
  case requiresVerification = 128
}

// === xdr source ============================================================

//  enum AssetSystemPolicies
//  {
//  	TWO_STEP_WITHDRAW = 1
//  };

//  ===========================================================================
public enum AssetSystemPolicies: Int32, XDREnum {
  case twoStepWithdraw = 1
}

// === xdr source ============================================================

//  struct AssetEntry
//  {
//      AssetCode code;
//  	AccountID owner;
//  	AccountID preissuedAssetSigner; // signer of pre issuance tokens
//  	longstring details;
//  	uint64 maxIssuanceAmount; // max number of tokens to be issued
//  	uint64 availableForIssueance; // pre issued tokens available for issuance
//  	uint64 issued; // number of issued tokens
//  	uint64 pendingIssuance; // number of tokens locked for entries like token sale. lockedIssuance + issued can not be > maxIssuanceAmount
//      uint32 policies;
//  
//      // reserved for future use
//      union switch (LedgerVersion v)
//      {
//      case EMPTY_VERSION:
//          void;
//      }
//      ext;
//  };

//  ===========================================================================
public struct AssetEntry: XDREncodable {
  public var code: AssetCode
  public var owner: AccountID
  public var preissuedAssetSigner: AccountID
  public var details: Longstring
  public var maxIssuanceAmount: Uint64
  public var availableForIssueance: Uint64
  public var issued: Uint64
  public var pendingIssuance: Uint64
  public var policies: Uint32
  public var ext: AssetEntryExt

  public init(
      code: AssetCode,
      owner: AccountID,
      preissuedAssetSigner: AccountID,
      details: Longstring,
      maxIssuanceAmount: Uint64,
      availableForIssueance: Uint64,
      issued: Uint64,
      pendingIssuance: Uint64,
      policies: Uint32,
      ext: AssetEntryExt) {

    self.code = code
    self.owner = owner
    self.preissuedAssetSigner = preissuedAssetSigner
    self.details = details
    self.maxIssuanceAmount = maxIssuanceAmount
    self.availableForIssueance = availableForIssueance
    self.issued = issued
    self.pendingIssuance = pendingIssuance
    self.policies = policies
    self.ext = ext
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.code.toXDR())
    xdr.append(self.owner.toXDR())
    xdr.append(self.preissuedAssetSigner.toXDR())
    xdr.append(self.details.toXDR())
    xdr.append(self.maxIssuanceAmount.toXDR())
    xdr.append(self.availableForIssueance.toXDR())
    xdr.append(self.issued.toXDR())
    xdr.append(self.pendingIssuance.toXDR())
    xdr.append(self.policies.toXDR())
    xdr.append(self.ext.toXDR())

    return xdr
  }

  public enum AssetEntryExt: XDRDiscriminatedUnion {
    case emptyVersion()

    public var discriminant: Int32 {
      switch self {
      case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .emptyVersion(): xdr.append(Data())
      }

      return xdr
    }

  }
}

// === xdr source ============================================================

//  struct BalanceEntry
//  {
//      BalanceID balanceID;
//      AssetCode asset;
//      AccountID accountID;
//      uint64 amount;
//      uint64 locked;
//  
//      // reserved for future use
//      union switch (LedgerVersion v)
//      {
//      case EMPTY_VERSION:
//          void;
//      }
//      ext;
//  };

//  ===========================================================================
public struct BalanceEntry: XDREncodable {
  public var balanceID: BalanceID
  public var asset: AssetCode
  public var accountID: AccountID
  public var amount: Uint64
  public var locked: Uint64
  public var ext: BalanceEntryExt

  public init(
      balanceID: BalanceID,
      asset: AssetCode,
      accountID: AccountID,
      amount: Uint64,
      locked: Uint64,
      ext: BalanceEntryExt) {

    self.balanceID = balanceID
    self.asset = asset
    self.accountID = accountID
    self.amount = amount
    self.locked = locked
    self.ext = ext
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.balanceID.toXDR())
    xdr.append(self.asset.toXDR())
    xdr.append(self.accountID.toXDR())
    xdr.append(self.amount.toXDR())
    xdr.append(self.locked.toXDR())
    xdr.append(self.ext.toXDR())

    return xdr
  }

  public enum BalanceEntryExt: XDRDiscriminatedUnion {
    case emptyVersion()

    public var discriminant: Int32 {
      switch self {
      case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .emptyVersion(): xdr.append(Data())
      }

      return xdr
    }

  }
}

// === xdr source ============================================================

//  enum ContractState
//  {
//      NO_CONFIRMATIONS = 0,
//      CUSTOMER_CONFIRMED = 1,
//      CONTRACTOR_CONFIRMED = 2,
//      DISPUTING = 4,
//      REVERTING_RESOLVE = 8,
//      NOT_REVERTING_RESOLVE = 16
//  };

//  ===========================================================================
public enum ContractState: Int32, XDREnum {
  case noConfirmations = 0
  case customerConfirmed = 1
  case contractorConfirmed = 2
  case disputing = 4
  case revertingResolve = 8
  case notRevertingResolve = 16
}

// === xdr source ============================================================

//  struct ContractEntry
//  {
//      uint64 contractID;
//  
//      AccountID contractor;
//      AccountID customer;
//      AccountID escrow;
//  
//      uint64 startTime;
//      uint64 endTime;
//      uint64 invoiceRequestsIDs<>;
//      longstring initialDetails;
//  
//      uint32 state;
//  
//      union switch (LedgerVersion v)
//      {
//      case EMPTY_VERSION:
//          void;
//      case ADD_CUSTOMER_DETAILS_TO_CONTRACT:
//          longstring customerDetails;
//      }
//      ext;
//  };

//  ===========================================================================
public struct ContractEntry: XDREncodable {
  public var contractID: Uint64
  public var contractor: AccountID
  public var customer: AccountID
  public var escrow: AccountID
  public var startTime: Uint64
  public var endTime: Uint64
  public var invoiceRequestsIDs: [Uint64]
  public var initialDetails: Longstring
  public var state: Uint32
  public var ext: ContractEntryExt

  public init(
      contractID: Uint64,
      contractor: AccountID,
      customer: AccountID,
      escrow: AccountID,
      startTime: Uint64,
      endTime: Uint64,
      invoiceRequestsIDs: [Uint64],
      initialDetails: Longstring,
      state: Uint32,
      ext: ContractEntryExt) {

    self.contractID = contractID
    self.contractor = contractor
    self.customer = customer
    self.escrow = escrow
    self.startTime = startTime
    self.endTime = endTime
    self.invoiceRequestsIDs = invoiceRequestsIDs
    self.initialDetails = initialDetails
    self.state = state
    self.ext = ext
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.contractID.toXDR())
    xdr.append(self.contractor.toXDR())
    xdr.append(self.customer.toXDR())
    xdr.append(self.escrow.toXDR())
    xdr.append(self.startTime.toXDR())
    xdr.append(self.endTime.toXDR())
    xdr.append(self.invoiceRequestsIDs.toXDR())
    xdr.append(self.initialDetails.toXDR())
    xdr.append(self.state.toXDR())
    xdr.append(self.ext.toXDR())

    return xdr
  }

  public enum ContractEntryExt: XDRDiscriminatedUnion {
    case emptyVersion()
    case addCustomerDetailsToContract(Longstring)

    public var discriminant: Int32 {
      switch self {
      case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
      case .addCustomerDetailsToContract: return LedgerVersion.addCustomerDetailsToContract.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .emptyVersion(): xdr.append(Data())
      case .addCustomerDetailsToContract(let data): xdr.append(data.toXDR())
      }

      return xdr
    }

  }
}

// === xdr source ============================================================

//  struct ExternalSystemAccountIDPoolEntry
//  {
//      uint64 poolEntryID;
//      int32 externalSystemType;
//      longstring data;
//      AccountID* accountID;
//      uint64 expiresAt;
//      uint64 bindedAt;
//      uint64 parent;
//      bool isDeleted;
//  
//  
//      // reserved for future use
//      union switch (LedgerVersion v)
//      {
//      case EMPTY_VERSION:
//         void;
//      }
//      ext;
//  };

//  ===========================================================================
public struct ExternalSystemAccountIDPoolEntry: XDREncodable {
  public var poolEntryID: Uint64
  public var externalSystemType: Int32
  public var data: Longstring
  public var accountID: AccountID?
  public var expiresAt: Uint64
  public var bindedAt: Uint64
  public var parent: Uint64
  public var isDeleted: Bool
  public var ext: ExternalSystemAccountIDPoolEntryExt

  public init(
      poolEntryID: Uint64,
      externalSystemType: Int32,
      data: Longstring,
      accountID: AccountID?,
      expiresAt: Uint64,
      bindedAt: Uint64,
      parent: Uint64,
      isDeleted: Bool,
      ext: ExternalSystemAccountIDPoolEntryExt) {

    self.poolEntryID = poolEntryID
    self.externalSystemType = externalSystemType
    self.data = data
    self.accountID = accountID
    self.expiresAt = expiresAt
    self.bindedAt = bindedAt
    self.parent = parent
    self.isDeleted = isDeleted
    self.ext = ext
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.poolEntryID.toXDR())
    xdr.append(self.externalSystemType.toXDR())
    xdr.append(self.data.toXDR())
    xdr.append(self.accountID.toXDR())
    xdr.append(self.expiresAt.toXDR())
    xdr.append(self.bindedAt.toXDR())
    xdr.append(self.parent.toXDR())
    xdr.append(self.isDeleted.toXDR())
    xdr.append(self.ext.toXDR())

    return xdr
  }

  public enum ExternalSystemAccountIDPoolEntryExt: XDRDiscriminatedUnion {
    case emptyVersion()

    public var discriminant: Int32 {
      switch self {
      case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .emptyVersion(): xdr.append(Data())
      }

      return xdr
    }

  }
}

// === xdr source ============================================================

//  struct ExternalSystemAccountID
//  {
//      AccountID accountID;
//      int32 externalSystemType;
//  	longstring data;
//  
//  	 // reserved for future use
//      union switch (LedgerVersion v)
//      {
//      case EMPTY_VERSION:
//          void;
//      }
//      ext;
//  };

//  ===========================================================================
public struct ExternalSystemAccountID: XDREncodable {
  public var accountID: AccountID
  public var externalSystemType: Int32
  public var data: Longstring
  public var ext: ExternalSystemAccountIDExt

  public init(
      accountID: AccountID,
      externalSystemType: Int32,
      data: Longstring,
      ext: ExternalSystemAccountIDExt) {

    self.accountID = accountID
    self.externalSystemType = externalSystemType
    self.data = data
    self.ext = ext
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.accountID.toXDR())
    xdr.append(self.externalSystemType.toXDR())
    xdr.append(self.data.toXDR())
    xdr.append(self.ext.toXDR())

    return xdr
  }

  public enum ExternalSystemAccountIDExt: XDRDiscriminatedUnion {
    case emptyVersion()

    public var discriminant: Int32 {
      switch self {
      case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .emptyVersion(): xdr.append(Data())
      }

      return xdr
    }

  }
}

// === xdr source ============================================================

//  enum FeeType
//  {
//      PAYMENT_FEE = 0,
//  	OFFER_FEE = 1,
//      WITHDRAWAL_FEE = 2,
//      ISSUANCE_FEE = 3,
//      INVEST_FEE = 4, // fee to be taken while creating sale participation
//      CAPITAL_DEPLOYMENT_FEE = 5, // fee to be taken when sale close
//      OPERATION_FEE = 6,
//      PAYOUT_FEE = 7
//  };

//  ===========================================================================
public enum FeeType: Int32, XDREnum {
  case paymentFee = 0
  case offerFee = 1
  case withdrawalFee = 2
  case issuanceFee = 3
  case investFee = 4
  case capitalDeploymentFee = 5
  case operationFee = 6
  case payoutFee = 7
}

// === xdr source ============================================================

//  enum EmissionFeeType
//  {
//  	PRIMARY_MARKET = 1,
//  	SECONDARY_MARKET = 2
//  };

//  ===========================================================================
public enum EmissionFeeType: Int32, XDREnum {
  case primaryMarket = 1
  case secondaryMarket = 2
}

// === xdr source ============================================================

//  enum PaymentFeeType
//  {
//      OUTGOING = 1,
//      INCOMING = 2
//  };

//  ===========================================================================
public enum PaymentFeeType: Int32, XDREnum {
  case outgoing = 1
  case incoming = 2
}

// === xdr source ============================================================

//  struct FeeEntry
//  {
//      FeeType feeType;
//      AssetCode asset;
//      int64 fixedFee; // fee paid for operation
//  	int64 percentFee; // percent of transfer amount to be charged
//  
//      AccountID* accountID;
//      AccountType* accountType;
//      int64 subtype; // for example, different withdrawals — bars or coins
//  
//      int64 lowerBound;
//      int64 upperBound;
//  
//      Hash hash;
//  
//  	// reserved for future use
//      union switch (LedgerVersion v)
//      {
//      case EMPTY_VERSION:
//          void;
//      case CROSS_ASSET_FEE:
//          AssetCode feeAsset;
//      }
//      ext;
//  };

//  ===========================================================================
public struct FeeEntry: XDREncodable {
  public var feeType: FeeType
  public var asset: AssetCode
  public var fixedFee: Int64
  public var percentFee: Int64
  public var accountID: AccountID?
  public var accountType: AccountType?
  public var subtype: Int64
  public var lowerBound: Int64
  public var upperBound: Int64
  public var hash: Hash
  public var ext: FeeEntryExt

  public init(
      feeType: FeeType,
      asset: AssetCode,
      fixedFee: Int64,
      percentFee: Int64,
      accountID: AccountID?,
      accountType: AccountType?,
      subtype: Int64,
      lowerBound: Int64,
      upperBound: Int64,
      hash: Hash,
      ext: FeeEntryExt) {

    self.feeType = feeType
    self.asset = asset
    self.fixedFee = fixedFee
    self.percentFee = percentFee
    self.accountID = accountID
    self.accountType = accountType
    self.subtype = subtype
    self.lowerBound = lowerBound
    self.upperBound = upperBound
    self.hash = hash
    self.ext = ext
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.feeType.toXDR())
    xdr.append(self.asset.toXDR())
    xdr.append(self.fixedFee.toXDR())
    xdr.append(self.percentFee.toXDR())
    xdr.append(self.accountID.toXDR())
    xdr.append(self.accountType.toXDR())
    xdr.append(self.subtype.toXDR())
    xdr.append(self.lowerBound.toXDR())
    xdr.append(self.upperBound.toXDR())
    xdr.append(self.hash.toXDR())
    xdr.append(self.ext.toXDR())

    return xdr
  }

  public enum FeeEntryExt: XDRDiscriminatedUnion {
    case emptyVersion()
    case crossAssetFee(AssetCode)

    public var discriminant: Int32 {
      switch self {
      case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
      case .crossAssetFee: return LedgerVersion.crossAssetFee.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .emptyVersion(): xdr.append(Data())
      case .crossAssetFee(let data): xdr.append(data.toXDR())
      }

      return xdr
    }

  }
}

// === xdr source ============================================================

//  enum KeyValueEntryType
//      {
//          UINT32 = 1,
//          STRING = 2,
//          UINT64 = 3
//      };

//  ===========================================================================
public enum KeyValueEntryType: Int32, XDREnum {
  case uint32 = 1
  case string = 2
  case uint64 = 3
}

// === xdr source ============================================================

//  struct KeyValueEntry
//      {
//          longstring key;
//  
//          union switch (KeyValueEntryType type)
//          {
//               case UINT32:
//                  uint32 ui32Value;
//               case STRING:
//                  string stringValue<>;
//              case UINT64:
//                  uint64 ui64Value;
//          }
//          value;
//  
//          // reserved for future use
//          union switch (LedgerVersion v)
//          {
//              case EMPTY_VERSION:
//                  void;
//          }
//          ext;
//      };

//  ===========================================================================
public struct KeyValueEntry: XDREncodable {
  public var key: Longstring
  public var value: KeyValueEntryValue
  public var ext: KeyValueEntryExt

  public init(
      key: Longstring,
      value: KeyValueEntryValue,
      ext: KeyValueEntryExt) {

    self.key = key
    self.value = value
    self.ext = ext
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.key.toXDR())
    xdr.append(self.value.toXDR())
    xdr.append(self.ext.toXDR())

    return xdr
  }

  public enum KeyValueEntryValue: XDRDiscriminatedUnion {
    case uint32(Uint32)
    case string(String)
    case uint64(Uint64)

    public var discriminant: Int32 {
      switch self {
      case .uint32: return KeyValueEntryType.uint32.rawValue
      case .string: return KeyValueEntryType.string.rawValue
      case .uint64: return KeyValueEntryType.uint64.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .uint32(let data): xdr.append(data.toXDR())
      case .string(let data): xdr.append(data.toXDR())
      case .uint64(let data): xdr.append(data.toXDR())
      }

      return xdr
    }

  }
  public enum KeyValueEntryExt: XDRDiscriminatedUnion {
    case emptyVersion()

    public var discriminant: Int32 {
      switch self {
      case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .emptyVersion(): xdr.append(Data())
      }

      return xdr
    }

  }
}

// === xdr source ============================================================

//  enum StatsOpType
//  {
//      PAYMENT_OUT = 1,
//      WITHDRAW = 2,
//      SPEND = 3,
//      DEPOSIT = 4,
//      PAYOUT = 5
//  };

//  ===========================================================================
public enum StatsOpType: Int32, XDREnum {
  case paymentOut = 1
  case withdraw = 2
  case spend = 3
  case deposit = 4
  case payout = 5
}

// === xdr source ============================================================

//  struct LimitsV2Entry
//  {
//      uint64      id;
//      AccountType *accountType;
//      AccountID   *accountID;
//      StatsOpType statsOpType;
//      AssetCode   assetCode;
//      bool        isConvertNeeded;
//  
//      uint64 dailyOut;
//      uint64 weeklyOut;
//      uint64 monthlyOut;
//      uint64 annualOut;
//  
//       // reserved for future use
//      union switch (LedgerVersion v)
//      {
//      case EMPTY_VERSION:
//          void;
//      }
//      ext;
//  };

//  ===========================================================================
public struct LimitsV2Entry: XDREncodable {
  public var id: Uint64
  public var accountType: AccountType?
  public var accountID: AccountID?
  public var statsOpType: StatsOpType
  public var assetCode: AssetCode
  public var isConvertNeeded: Bool
  public var dailyOut: Uint64
  public var weeklyOut: Uint64
  public var monthlyOut: Uint64
  public var annualOut: Uint64
  public var ext: LimitsV2EntryExt

  public init(
      id: Uint64,
      accountType: AccountType?,
      accountID: AccountID?,
      statsOpType: StatsOpType,
      assetCode: AssetCode,
      isConvertNeeded: Bool,
      dailyOut: Uint64,
      weeklyOut: Uint64,
      monthlyOut: Uint64,
      annualOut: Uint64,
      ext: LimitsV2EntryExt) {

    self.id = id
    self.accountType = accountType
    self.accountID = accountID
    self.statsOpType = statsOpType
    self.assetCode = assetCode
    self.isConvertNeeded = isConvertNeeded
    self.dailyOut = dailyOut
    self.weeklyOut = weeklyOut
    self.monthlyOut = monthlyOut
    self.annualOut = annualOut
    self.ext = ext
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.id.toXDR())
    xdr.append(self.accountType.toXDR())
    xdr.append(self.accountID.toXDR())
    xdr.append(self.statsOpType.toXDR())
    xdr.append(self.assetCode.toXDR())
    xdr.append(self.isConvertNeeded.toXDR())
    xdr.append(self.dailyOut.toXDR())
    xdr.append(self.weeklyOut.toXDR())
    xdr.append(self.monthlyOut.toXDR())
    xdr.append(self.annualOut.toXDR())
    xdr.append(self.ext.toXDR())

    return xdr
  }

  public enum LimitsV2EntryExt: XDRDiscriminatedUnion {
    case emptyVersion()

    public var discriminant: Int32 {
      switch self {
      case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .emptyVersion(): xdr.append(Data())
      }

      return xdr
    }

  }
}

// === xdr source ============================================================

//  struct OfferEntry
//  {	
//      uint64 offerID;
//  	uint64 orderBookID;
//  	AccountID ownerID;
//  	bool isBuy;
//      AssetCode base; // A
//      AssetCode quote;  // B
//  	BalanceID baseBalance; 
//  	BalanceID quoteBalance;
//      int64 baseAmount;
//  	int64 quoteAmount;
//  	uint64 createdAt;
//  	int64 fee;
//  
//      int64 percentFee;
//  
//  	// price of A in terms of B
//      int64 price;
//  
//      // reserved for future use
//      union switch (LedgerVersion v)
//      {
//      case EMPTY_VERSION:
//          void;
//      }
//      ext;
//  };

//  ===========================================================================
public struct OfferEntry: XDREncodable {
  public var offerID: Uint64
  public var orderBookID: Uint64
  public var ownerID: AccountID
  public var isBuy: Bool
  public var base: AssetCode
  public var quote: AssetCode
  public var baseBalance: BalanceID
  public var quoteBalance: BalanceID
  public var baseAmount: Int64
  public var quoteAmount: Int64
  public var createdAt: Uint64
  public var fee: Int64
  public var percentFee: Int64
  public var price: Int64
  public var ext: OfferEntryExt

  public init(
      offerID: Uint64,
      orderBookID: Uint64,
      ownerID: AccountID,
      isBuy: Bool,
      base: AssetCode,
      quote: AssetCode,
      baseBalance: BalanceID,
      quoteBalance: BalanceID,
      baseAmount: Int64,
      quoteAmount: Int64,
      createdAt: Uint64,
      fee: Int64,
      percentFee: Int64,
      price: Int64,
      ext: OfferEntryExt) {

    self.offerID = offerID
    self.orderBookID = orderBookID
    self.ownerID = ownerID
    self.isBuy = isBuy
    self.base = base
    self.quote = quote
    self.baseBalance = baseBalance
    self.quoteBalance = quoteBalance
    self.baseAmount = baseAmount
    self.quoteAmount = quoteAmount
    self.createdAt = createdAt
    self.fee = fee
    self.percentFee = percentFee
    self.price = price
    self.ext = ext
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.offerID.toXDR())
    xdr.append(self.orderBookID.toXDR())
    xdr.append(self.ownerID.toXDR())
    xdr.append(self.isBuy.toXDR())
    xdr.append(self.base.toXDR())
    xdr.append(self.quote.toXDR())
    xdr.append(self.baseBalance.toXDR())
    xdr.append(self.quoteBalance.toXDR())
    xdr.append(self.baseAmount.toXDR())
    xdr.append(self.quoteAmount.toXDR())
    xdr.append(self.createdAt.toXDR())
    xdr.append(self.fee.toXDR())
    xdr.append(self.percentFee.toXDR())
    xdr.append(self.price.toXDR())
    xdr.append(self.ext.toXDR())

    return xdr
  }

  public enum OfferEntryExt: XDRDiscriminatedUnion {
    case emptyVersion()

    public var discriminant: Int32 {
      switch self {
      case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .emptyVersion(): xdr.append(Data())
      }

      return xdr
    }

  }
}

// === xdr source ============================================================

//  struct PendingStatisticsEntry
//  {
//      uint64 statisticsID;
//      uint64 requestID;
//      uint64 amount;
//  
//      // reserved for future use
//      union switch (LedgerVersion v)
//      {
//      case EMPTY_VERSION:
//          void;
//      }
//      ext;
//  };

//  ===========================================================================
public struct PendingStatisticsEntry: XDREncodable {
  public var statisticsID: Uint64
  public var requestID: Uint64
  public var amount: Uint64
  public var ext: PendingStatisticsEntryExt

  public init(
      statisticsID: Uint64,
      requestID: Uint64,
      amount: Uint64,
      ext: PendingStatisticsEntryExt) {

    self.statisticsID = statisticsID
    self.requestID = requestID
    self.amount = amount
    self.ext = ext
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.statisticsID.toXDR())
    xdr.append(self.requestID.toXDR())
    xdr.append(self.amount.toXDR())
    xdr.append(self.ext.toXDR())

    return xdr
  }

  public enum PendingStatisticsEntryExt: XDRDiscriminatedUnion {
    case emptyVersion()

    public var discriminant: Int32 {
      switch self {
      case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .emptyVersion(): xdr.append(Data())
      }

      return xdr
    }

  }
}

// === xdr source ============================================================

//  struct ReferenceEntry
//  {
//  	AccountID sender;
//      string64 reference;
//  
//  	// reserved for future use
//      union switch (LedgerVersion v)
//      {
//      case EMPTY_VERSION:
//          void;
//      }
//      ext;
//  };

//  ===========================================================================
public struct ReferenceEntry: XDREncodable {
  public var sender: AccountID
  public var reference: String64
  public var ext: ReferenceEntryExt

  public init(
      sender: AccountID,
      reference: String64,
      ext: ReferenceEntryExt) {

    self.sender = sender
    self.reference = reference
    self.ext = ext
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.sender.toXDR())
    xdr.append(self.reference.toXDR())
    xdr.append(self.ext.toXDR())

    return xdr
  }

  public enum ReferenceEntryExt: XDRDiscriminatedUnion {
    case emptyVersion()

    public var discriminant: Int32 {
      switch self {
      case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .emptyVersion(): xdr.append(Data())
      }

      return xdr
    }

  }
}

// === xdr source ============================================================

//  enum ReviewableRequestType
//  {
//      ASSET_CREATE = 0,
//  	ASSET_UPDATE = 1,
//  	PRE_ISSUANCE_CREATE = 2,
//  	ISSUANCE_CREATE = 3,
//  	WITHDRAW = 4,
//  	SALE = 5,
//  	LIMITS_UPDATE = 6,
//  	TWO_STEP_WITHDRAWAL = 7,
//      AML_ALERT = 8,
//  	UPDATE_KYC = 9,
//  	UPDATE_SALE_DETAILS = 10,
//  	UPDATE_PROMOTION = 11,
//  	UPDATE_SALE_END_TIME = 12,
//  	NONE = 13, // use this request type in ReviewRequestOp extended result if additional info is not required
//  	INVOICE = 14,
//  	CONTRACT = 15
//  
//  };

//  ===========================================================================
public enum ReviewableRequestType: Int32, XDREnum {
  case assetCreate = 0
  case assetUpdate = 1
  case preIssuanceCreate = 2
  case issuanceCreate = 3
  case withdraw = 4
  case sale = 5
  case limitsUpdate = 6
  case twoStepWithdrawal = 7
  case amlAlert = 8
  case updateKyc = 9
  case updateSaleDetails = 10
  case updatePromotion = 11
  case updateSaleEndTime = 12
  case none = 13
  case invoice = 14
  case contract = 15
}

// === xdr source ============================================================

//  struct TasksExt {
//      // Tasks are represented by a bitmask
//      uint32 allTasks;
//      uint32 pendingTasks;
//  
//      // External details vector consists of comments written by request reviewers
//      longstring externalDetails<>;
//  
//      // Reserved for future use
//      union switch (LedgerVersion v)
//      {
//      case EMPTY_VERSION:
//          void;
//      }
//      ext;
//  };

//  ===========================================================================
public struct TasksExt: XDREncodable {
  public var allTasks: Uint32
  public var pendingTasks: Uint32
  public var externalDetails: [Longstring]
  public var ext: TasksExtExt

  public init(
      allTasks: Uint32,
      pendingTasks: Uint32,
      externalDetails: [Longstring],
      ext: TasksExtExt) {

    self.allTasks = allTasks
    self.pendingTasks = pendingTasks
    self.externalDetails = externalDetails
    self.ext = ext
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.allTasks.toXDR())
    xdr.append(self.pendingTasks.toXDR())
    xdr.append(self.externalDetails.toXDR())
    xdr.append(self.ext.toXDR())

    return xdr
  }

  public enum TasksExtExt: XDRDiscriminatedUnion {
    case emptyVersion()

    public var discriminant: Int32 {
      switch self {
      case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .emptyVersion(): xdr.append(Data())
      }

      return xdr
    }

  }
}

// === xdr source ============================================================

//  struct ReviewableRequestEntry {
//  	uint64 requestID;
//  	Hash hash; // hash of the request body
//  	AccountID requestor;
//  	longstring rejectReason;
//  	AccountID reviewer;
//  	string64* reference; // reference for request which will act as an unique key for the request (will reject request with the same reference from same requestor)
//  	int64 createdAt; // when request was created
//  
//  	union switch (ReviewableRequestType type) {
//  		case ASSET_CREATE:
//  			AssetCreationRequest assetCreationRequest;
//  		case ASSET_UPDATE:
//  			AssetUpdateRequest assetUpdateRequest;
//  		case PRE_ISSUANCE_CREATE:
//  			PreIssuanceRequest preIssuanceRequest;
//  		case ISSUANCE_CREATE:
//  			IssuanceRequest issuanceRequest;
//  		case WITHDRAW:
//  			WithdrawalRequest withdrawalRequest;
//  		case SALE:
//  			SaleCreationRequest saleCreationRequest;
//          case LIMITS_UPDATE:
//              LimitsUpdateRequest limitsUpdateRequest;
//  		case TWO_STEP_WITHDRAWAL:
//  			WithdrawalRequest twoStepWithdrawalRequest;
//          case AML_ALERT:
//              AMLAlertRequest amlAlertRequest;
//          case UPDATE_KYC:
//              UpdateKYCRequest updateKYCRequest;
//          case UPDATE_SALE_DETAILS:
//              UpdateSaleDetailsRequest updateSaleDetailsRequest;
//          case UPDATE_PROMOTION:
//              PromotionUpdateRequest promotionUpdateRequest;
//          case INVOICE:
//              InvoiceRequest invoiceRequest;
//          case UPDATE_SALE_END_TIME:
//              UpdateSaleEndTimeRequest updateSaleEndTimeRequest;
//          case CONTRACT:
//              ContractRequest contractRequest;
//  	} body;
//  
//  	// reserved for future use
//      union switch (LedgerVersion v)
//      {
//      case EMPTY_VERSION:
//          void;
//      case ADD_TASKS_TO_REVIEWABLE_REQUEST:
//          TasksExt tasksExt;
//      }
//      ext;
//  };

//  ===========================================================================
public struct ReviewableRequestEntry: XDREncodable {
  public var requestID: Uint64
  public var hash: Hash
  public var requestor: AccountID
  public var rejectReason: Longstring
  public var reviewer: AccountID
  public var reference: String64?
  public var createdAt: Int64
  public var body: ReviewableRequestEntryBody
  public var ext: ReviewableRequestEntryExt

  public init(
      requestID: Uint64,
      hash: Hash,
      requestor: AccountID,
      rejectReason: Longstring,
      reviewer: AccountID,
      reference: String64?,
      createdAt: Int64,
      body: ReviewableRequestEntryBody,
      ext: ReviewableRequestEntryExt) {

    self.requestID = requestID
    self.hash = hash
    self.requestor = requestor
    self.rejectReason = rejectReason
    self.reviewer = reviewer
    self.reference = reference
    self.createdAt = createdAt
    self.body = body
    self.ext = ext
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.requestID.toXDR())
    xdr.append(self.hash.toXDR())
    xdr.append(self.requestor.toXDR())
    xdr.append(self.rejectReason.toXDR())
    xdr.append(self.reviewer.toXDR())
    xdr.append(self.reference.toXDR())
    xdr.append(self.createdAt.toXDR())
    xdr.append(self.body.toXDR())
    xdr.append(self.ext.toXDR())

    return xdr
  }

  public enum ReviewableRequestEntryBody: XDRDiscriminatedUnion {
    case assetCreate(AssetCreationRequest)
    case assetUpdate(AssetUpdateRequest)
    case preIssuanceCreate(PreIssuanceRequest)
    case issuanceCreate(IssuanceRequest)
    case withdraw(WithdrawalRequest)
    case sale(SaleCreationRequest)
    case limitsUpdate(LimitsUpdateRequest)
    case twoStepWithdrawal(WithdrawalRequest)
    case amlAlert(AMLAlertRequest)
    case updateKyc(UpdateKYCRequest)
    case updateSaleDetails(UpdateSaleDetailsRequest)
    case updatePromotion(PromotionUpdateRequest)
    case invoice(InvoiceRequest)
    case updateSaleEndTime(UpdateSaleEndTimeRequest)
    case contract(ContractRequest)

    public var discriminant: Int32 {
      switch self {
      case .assetCreate: return ReviewableRequestType.assetCreate.rawValue
      case .assetUpdate: return ReviewableRequestType.assetUpdate.rawValue
      case .preIssuanceCreate: return ReviewableRequestType.preIssuanceCreate.rawValue
      case .issuanceCreate: return ReviewableRequestType.issuanceCreate.rawValue
      case .withdraw: return ReviewableRequestType.withdraw.rawValue
      case .sale: return ReviewableRequestType.sale.rawValue
      case .limitsUpdate: return ReviewableRequestType.limitsUpdate.rawValue
      case .twoStepWithdrawal: return ReviewableRequestType.twoStepWithdrawal.rawValue
      case .amlAlert: return ReviewableRequestType.amlAlert.rawValue
      case .updateKyc: return ReviewableRequestType.updateKyc.rawValue
      case .updateSaleDetails: return ReviewableRequestType.updateSaleDetails.rawValue
      case .updatePromotion: return ReviewableRequestType.updatePromotion.rawValue
      case .invoice: return ReviewableRequestType.invoice.rawValue
      case .updateSaleEndTime: return ReviewableRequestType.updateSaleEndTime.rawValue
      case .contract: return ReviewableRequestType.contract.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .assetCreate(let data): xdr.append(data.toXDR())
      case .assetUpdate(let data): xdr.append(data.toXDR())
      case .preIssuanceCreate(let data): xdr.append(data.toXDR())
      case .issuanceCreate(let data): xdr.append(data.toXDR())
      case .withdraw(let data): xdr.append(data.toXDR())
      case .sale(let data): xdr.append(data.toXDR())
      case .limitsUpdate(let data): xdr.append(data.toXDR())
      case .twoStepWithdrawal(let data): xdr.append(data.toXDR())
      case .amlAlert(let data): xdr.append(data.toXDR())
      case .updateKyc(let data): xdr.append(data.toXDR())
      case .updateSaleDetails(let data): xdr.append(data.toXDR())
      case .updatePromotion(let data): xdr.append(data.toXDR())
      case .invoice(let data): xdr.append(data.toXDR())
      case .updateSaleEndTime(let data): xdr.append(data.toXDR())
      case .contract(let data): xdr.append(data.toXDR())
      }

      return xdr
    }

  }
  public enum ReviewableRequestEntryExt: XDRDiscriminatedUnion {
    case emptyVersion()
    case addTasksToReviewableRequest(TasksExt)

    public var discriminant: Int32 {
      switch self {
      case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
      case .addTasksToReviewableRequest: return LedgerVersion.addTasksToReviewableRequest.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .emptyVersion(): xdr.append(Data())
      case .addTasksToReviewableRequest(let data): xdr.append(data.toXDR())
      }

      return xdr
    }

  }
}

// === xdr source ============================================================

//  struct SaleAnteEntry
//  {
//      uint64 saleID;
//      BalanceID participantBalanceID;
//      uint64 amount; // amount to be locked from participant balance
//  
//      union switch (LedgerVersion v)
//      {
//      case EMPTY_VERSION:
//          void;
//      }
//      ext;
//  };

//  ===========================================================================
public struct SaleAnteEntry: XDREncodable {
  public var saleID: Uint64
  public var participantBalanceID: BalanceID
  public var amount: Uint64
  public var ext: SaleAnteEntryExt

  public init(
      saleID: Uint64,
      participantBalanceID: BalanceID,
      amount: Uint64,
      ext: SaleAnteEntryExt) {

    self.saleID = saleID
    self.participantBalanceID = participantBalanceID
    self.amount = amount
    self.ext = ext
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.saleID.toXDR())
    xdr.append(self.participantBalanceID.toXDR())
    xdr.append(self.amount.toXDR())
    xdr.append(self.ext.toXDR())

    return xdr
  }

  public enum SaleAnteEntryExt: XDRDiscriminatedUnion {
    case emptyVersion()

    public var discriminant: Int32 {
      switch self {
      case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .emptyVersion(): xdr.append(Data())
      }

      return xdr
    }

  }
}

// === xdr source ============================================================

//  enum SaleState {
//  	NONE = 0, // default state
//  	VOTING = 1, // not allowed to invest
//  	PROMOTION = 2 // not allowed to invest, but allowed to change all the details
//  };

//  ===========================================================================
public enum SaleState: Int32, XDREnum {
  case none = 0
  case voting = 1
  case promotion = 2
}

// === xdr source ============================================================

//  enum SaleType {
//  	BASIC_SALE = 1, // sale creator specifies price for each quote asset
//  	CROWD_FUNDING = 2, // sale creator does not specify price,
//  	                  // price is defined on sale close based on amount of base asset to be sold and amount of quote assets collected
//      FIXED_PRICE=3
//  };

//  ===========================================================================
public enum SaleType: Int32, XDREnum {
  case basicSale = 1
  case crowdFunding = 2
  case fixedPrice = 3
}

// === xdr source ============================================================

//  struct FixedPriceSale {
//  	union switch (LedgerVersion v)
//      {
//      case EMPTY_VERSION:
//          void;
//      }
//      ext;
//  };

//  ===========================================================================
public struct FixedPriceSale: XDREncodable {
  public var ext: FixedPriceSaleExt

  public init(
      ext: FixedPriceSaleExt) {

    self.ext = ext
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.ext.toXDR())

    return xdr
  }

  public enum FixedPriceSaleExt: XDRDiscriminatedUnion {
    case emptyVersion()

    public var discriminant: Int32 {
      switch self {
      case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .emptyVersion(): xdr.append(Data())
      }

      return xdr
    }

  }
}

// === xdr source ============================================================

//  struct CrowdFundingSale {
//  	union switch (LedgerVersion v)
//      {
//      case EMPTY_VERSION:
//          void;
//      }
//      ext;
//  };

//  ===========================================================================
public struct CrowdFundingSale: XDREncodable {
  public var ext: CrowdFundingSaleExt

  public init(
      ext: CrowdFundingSaleExt) {

    self.ext = ext
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.ext.toXDR())

    return xdr
  }

  public enum CrowdFundingSaleExt: XDRDiscriminatedUnion {
    case emptyVersion()

    public var discriminant: Int32 {
      switch self {
      case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .emptyVersion(): xdr.append(Data())
      }

      return xdr
    }

  }
}

// === xdr source ============================================================

//  struct BasicSale {
//  	union switch (LedgerVersion v)
//      {
//      case EMPTY_VERSION:
//          void;
//      }
//      ext;
//  };

//  ===========================================================================
public struct BasicSale: XDREncodable {
  public var ext: BasicSaleExt

  public init(
      ext: BasicSaleExt) {

    self.ext = ext
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.ext.toXDR())

    return xdr
  }

  public enum BasicSaleExt: XDRDiscriminatedUnion {
    case emptyVersion()

    public var discriminant: Int32 {
      switch self {
      case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .emptyVersion(): xdr.append(Data())
      }

      return xdr
    }

  }
}

// === xdr source ============================================================

//  struct SaleTypeExt {
//  	union switch (SaleType saleType)
//      {
//  	case BASIC_SALE:
//  		BasicSale basicSale;
//      case CROWD_FUNDING:
//          CrowdFundingSale crowdFundingSale;
//      case FIXED_PRICE:
//          FixedPriceSale fixedPriceSale;
//      }
//      typedSale;
//  };

//  ===========================================================================
public struct SaleTypeExt: XDREncodable {
  public var typedSale: SaleTypeExtTypedSale

  public init(
      typedSale: SaleTypeExtTypedSale) {

    self.typedSale = typedSale
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.typedSale.toXDR())

    return xdr
  }

  public enum SaleTypeExtTypedSale: XDRDiscriminatedUnion {
    case basicSale(BasicSale)
    case crowdFunding(CrowdFundingSale)
    case fixedPrice(FixedPriceSale)

    public var discriminant: Int32 {
      switch self {
      case .basicSale: return SaleType.basicSale.rawValue
      case .crowdFunding: return SaleType.crowdFunding.rawValue
      case .fixedPrice: return SaleType.fixedPrice.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .basicSale(let data): xdr.append(data.toXDR())
      case .crowdFunding(let data): xdr.append(data.toXDR())
      case .fixedPrice(let data): xdr.append(data.toXDR())
      }

      return xdr
    }

  }
}

// === xdr source ============================================================

//  struct StatableSaleExt {
//  	SaleTypeExt saleTypeExt;
//  	SaleState state;
//  };

//  ===========================================================================
public struct StatableSaleExt: XDREncodable {
  public var saleTypeExt: SaleTypeExt
  public var state: SaleState

  public init(
      saleTypeExt: SaleTypeExt,
      state: SaleState) {

    self.saleTypeExt = saleTypeExt
    self.state = state
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.saleTypeExt.toXDR())
    xdr.append(self.state.toXDR())

    return xdr
  }
}

// === xdr source ============================================================

//  struct SaleQuoteAsset {
//  	AssetCode quoteAsset; // asset in which participation will be accepted
//  	uint64 price; // price for 1 baseAsset in terms of quote asset
//  	BalanceID quoteBalance;
//  	uint64 currentCap; // current capitalization
//  	union switch (LedgerVersion v)
//      {
//      case EMPTY_VERSION:
//          void;
//      }
//      ext;
//  };

//  ===========================================================================
public struct SaleQuoteAsset: XDREncodable {
  public var quoteAsset: AssetCode
  public var price: Uint64
  public var quoteBalance: BalanceID
  public var currentCap: Uint64
  public var ext: SaleQuoteAssetExt

  public init(
      quoteAsset: AssetCode,
      price: Uint64,
      quoteBalance: BalanceID,
      currentCap: Uint64,
      ext: SaleQuoteAssetExt) {

    self.quoteAsset = quoteAsset
    self.price = price
    self.quoteBalance = quoteBalance
    self.currentCap = currentCap
    self.ext = ext
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.quoteAsset.toXDR())
    xdr.append(self.price.toXDR())
    xdr.append(self.quoteBalance.toXDR())
    xdr.append(self.currentCap.toXDR())
    xdr.append(self.ext.toXDR())

    return xdr
  }

  public enum SaleQuoteAssetExt: XDRDiscriminatedUnion {
    case emptyVersion()

    public var discriminant: Int32 {
      switch self {
      case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .emptyVersion(): xdr.append(Data())
      }

      return xdr
    }

  }
}

// === xdr source ============================================================

//  struct SaleEntry
//  {
//  	uint64 saleID;
//  	AccountID ownerID;
//      AssetCode baseAsset; // asset for which sale will be performed
//  	uint64 startTime; // start time of the sale
//  	uint64 endTime; // close time of the sale
//  	AssetCode defaultQuoteAsset; // asset for soft and hard cap
//  	uint64 softCap; // minimum amount of quote asset to be received at which sale will be considered a successful
//  	uint64 hardCap; // max amount of quote asset to be received
//  	uint64 currentCapInBase;
//  	uint64 maxAmountToBeSold;
//  	longstring details; // sale specific details
//  	SaleQuoteAsset quoteAssets<100>;
//  
//  	BalanceID baseBalance;
//  
//  	union switch (LedgerVersion v)
//      {
//      case EMPTY_VERSION:
//          void;
//  	case TYPED_SALE:
//  		SaleTypeExt saleTypeExt;
//  	case STATABLE_SALES:
//  		StatableSaleExt statableSaleExt;
//      }
//      ext;
//  };

//  ===========================================================================
public struct SaleEntry: XDREncodable {
  public var saleID: Uint64
  public var ownerID: AccountID
  public var baseAsset: AssetCode
  public var startTime: Uint64
  public var endTime: Uint64
  public var defaultQuoteAsset: AssetCode
  public var softCap: Uint64
  public var hardCap: Uint64
  public var currentCapInBase: Uint64
  public var maxAmountToBeSold: Uint64
  public var details: Longstring
  public var quoteAssets: [SaleQuoteAsset]
  public var baseBalance: BalanceID
  public var ext: SaleEntryExt

  public init(
      saleID: Uint64,
      ownerID: AccountID,
      baseAsset: AssetCode,
      startTime: Uint64,
      endTime: Uint64,
      defaultQuoteAsset: AssetCode,
      softCap: Uint64,
      hardCap: Uint64,
      currentCapInBase: Uint64,
      maxAmountToBeSold: Uint64,
      details: Longstring,
      quoteAssets: [SaleQuoteAsset],
      baseBalance: BalanceID,
      ext: SaleEntryExt) {

    self.saleID = saleID
    self.ownerID = ownerID
    self.baseAsset = baseAsset
    self.startTime = startTime
    self.endTime = endTime
    self.defaultQuoteAsset = defaultQuoteAsset
    self.softCap = softCap
    self.hardCap = hardCap
    self.currentCapInBase = currentCapInBase
    self.maxAmountToBeSold = maxAmountToBeSold
    self.details = details
    self.quoteAssets = quoteAssets
    self.baseBalance = baseBalance
    self.ext = ext
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.saleID.toXDR())
    xdr.append(self.ownerID.toXDR())
    xdr.append(self.baseAsset.toXDR())
    xdr.append(self.startTime.toXDR())
    xdr.append(self.endTime.toXDR())
    xdr.append(self.defaultQuoteAsset.toXDR())
    xdr.append(self.softCap.toXDR())
    xdr.append(self.hardCap.toXDR())
    xdr.append(self.currentCapInBase.toXDR())
    xdr.append(self.maxAmountToBeSold.toXDR())
    xdr.append(self.details.toXDR())
    xdr.append(self.quoteAssets.toXDR())
    xdr.append(self.baseBalance.toXDR())
    xdr.append(self.ext.toXDR())

    return xdr
  }

  public enum SaleEntryExt: XDRDiscriminatedUnion {
    case emptyVersion()
    case typedSale(SaleTypeExt)
    case statableSales(StatableSaleExt)

    public var discriminant: Int32 {
      switch self {
      case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
      case .typedSale: return LedgerVersion.typedSale.rawValue
      case .statableSales: return LedgerVersion.statableSales.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .emptyVersion(): xdr.append(Data())
      case .typedSale(let data): xdr.append(data.toXDR())
      case .statableSales(let data): xdr.append(data.toXDR())
      }

      return xdr
    }

  }
}

// === xdr source ============================================================

//  struct StatisticsV2Entry
//  {
//      uint64      id;
//  	AccountID   accountID;
//  	StatsOpType statsOpType;
//      AssetCode   assetCode;
//      bool        isConvertNeeded;
//  
//  	uint64 dailyOutcome;
//  	uint64 weeklyOutcome;
//  	uint64 monthlyOutcome;
//  	uint64 annualOutcome;
//  
//  	int64 updatedAt;
//  
//      // reserved for future use
//      union switch (LedgerVersion v)
//      {
//      case EMPTY_VERSION:
//          void;
//      }
//      ext;
//  };

//  ===========================================================================
public struct StatisticsV2Entry: XDREncodable {
  public var id: Uint64
  public var accountID: AccountID
  public var statsOpType: StatsOpType
  public var assetCode: AssetCode
  public var isConvertNeeded: Bool
  public var dailyOutcome: Uint64
  public var weeklyOutcome: Uint64
  public var monthlyOutcome: Uint64
  public var annualOutcome: Uint64
  public var updatedAt: Int64
  public var ext: StatisticsV2EntryExt

  public init(
      id: Uint64,
      accountID: AccountID,
      statsOpType: StatsOpType,
      assetCode: AssetCode,
      isConvertNeeded: Bool,
      dailyOutcome: Uint64,
      weeklyOutcome: Uint64,
      monthlyOutcome: Uint64,
      annualOutcome: Uint64,
      updatedAt: Int64,
      ext: StatisticsV2EntryExt) {

    self.id = id
    self.accountID = accountID
    self.statsOpType = statsOpType
    self.assetCode = assetCode
    self.isConvertNeeded = isConvertNeeded
    self.dailyOutcome = dailyOutcome
    self.weeklyOutcome = weeklyOutcome
    self.monthlyOutcome = monthlyOutcome
    self.annualOutcome = annualOutcome
    self.updatedAt = updatedAt
    self.ext = ext
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.id.toXDR())
    xdr.append(self.accountID.toXDR())
    xdr.append(self.statsOpType.toXDR())
    xdr.append(self.assetCode.toXDR())
    xdr.append(self.isConvertNeeded.toXDR())
    xdr.append(self.dailyOutcome.toXDR())
    xdr.append(self.weeklyOutcome.toXDR())
    xdr.append(self.monthlyOutcome.toXDR())
    xdr.append(self.annualOutcome.toXDR())
    xdr.append(self.updatedAt.toXDR())
    xdr.append(self.ext.toXDR())

    return xdr
  }

  public enum StatisticsV2EntryExt: XDRDiscriminatedUnion {
    case emptyVersion()

    public var discriminant: Int32 {
      switch self {
      case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .emptyVersion(): xdr.append(Data())
      }

      return xdr
    }

  }
}

// === xdr source ============================================================

//  struct StatisticsEntry
//  {
//  	AccountID accountID;
//  
//  	uint64 dailyOutcome;
//  	uint64 weeklyOutcome;
//  	uint64 monthlyOutcome;
//  	uint64 annualOutcome;
//  
//  	int64 updatedAt;
//  
//      // reserved for future use
//      union switch (LedgerVersion v)
//      {
//      case EMPTY_VERSION:
//          void;
//      }
//      ext;
//  };

//  ===========================================================================
public struct StatisticsEntry: XDREncodable {
  public var accountID: AccountID
  public var dailyOutcome: Uint64
  public var weeklyOutcome: Uint64
  public var monthlyOutcome: Uint64
  public var annualOutcome: Uint64
  public var updatedAt: Int64
  public var ext: StatisticsEntryExt

  public init(
      accountID: AccountID,
      dailyOutcome: Uint64,
      weeklyOutcome: Uint64,
      monthlyOutcome: Uint64,
      annualOutcome: Uint64,
      updatedAt: Int64,
      ext: StatisticsEntryExt) {

    self.accountID = accountID
    self.dailyOutcome = dailyOutcome
    self.weeklyOutcome = weeklyOutcome
    self.monthlyOutcome = monthlyOutcome
    self.annualOutcome = annualOutcome
    self.updatedAt = updatedAt
    self.ext = ext
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.accountID.toXDR())
    xdr.append(self.dailyOutcome.toXDR())
    xdr.append(self.weeklyOutcome.toXDR())
    xdr.append(self.monthlyOutcome.toXDR())
    xdr.append(self.annualOutcome.toXDR())
    xdr.append(self.updatedAt.toXDR())
    xdr.append(self.ext.toXDR())

    return xdr
  }

  public enum StatisticsEntryExt: XDRDiscriminatedUnion {
    case emptyVersion()

    public var discriminant: Int32 {
      switch self {
      case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .emptyVersion(): xdr.append(Data())
      }

      return xdr
    }

  }
}

// === xdr source ============================================================

//  enum ThresholdIndexes
//  {
//      MASTER_WEIGHT = 0,
//      LOW = 1,
//      MED = 2,
//      HIGH = 3
//  };

//  ===========================================================================
public enum ThresholdIndexes: Int32, XDREnum {
  case masterWeight = 0
  case low = 1
  case med = 2
  case high = 3
}

// === xdr source ============================================================

//  enum LedgerEntryType
//  {
//      ACCOUNT = 0,
//      FEE = 2,
//      BALANCE = 4,
//      PAYMENT_REQUEST = 5,
//      ASSET = 6,
//      REFERENCE_ENTRY = 7,
//      ACCOUNT_TYPE_LIMITS = 8,
//      STATISTICS = 9,
//      TRUST = 10,
//      ACCOUNT_LIMITS = 11,
//  	ASSET_PAIR = 12,
//  	OFFER_ENTRY = 13,
//  	REVIEWABLE_REQUEST = 15,
//  	EXTERNAL_SYSTEM_ACCOUNT_ID = 16,
//  	SALE = 17,
//  	ACCOUNT_KYC = 18,
//  	EXTERNAL_SYSTEM_ACCOUNT_ID_POOL_ENTRY = 19,
//      KEY_VALUE = 20,
//      SALE_ANTE = 21,
//      LIMITS_V2 = 22,
//      STATISTICS_V2 = 23,
//      PENDING_STATISTICS = 24,
//      CONTRACT = 25,
//      ACCOUNT_ROLE = 26,
//      ACCOUNT_ROLE_PERMISSION = 27
//  };

//  ===========================================================================
public enum LedgerEntryType: Int32, XDREnum {
  case account = 0
  case fee = 2
  case balance = 4
  case paymentRequest = 5
  case asset = 6
  case referenceEntry = 7
  case accountTypeLimits = 8
  case statistics = 9
  case trust = 10
  case accountLimits = 11
  case assetPair = 12
  case offerEntry = 13
  case reviewableRequest = 15
  case externalSystemAccountId = 16
  case sale = 17
  case accountKyc = 18
  case externalSystemAccountIdPoolEntry = 19
  case keyValue = 20
  case saleAnte = 21
  case limitsV2 = 22
  case statisticsV2 = 23
  case pendingStatistics = 24
  case contract = 25
  case accountRole = 26
  case accountRolePermission = 27
}

// === xdr source ============================================================

//  struct LedgerEntry
//  {
//      uint32 lastModifiedLedgerSeq; // ledger the LedgerEntry was last changed
//  
//      union switch (LedgerEntryType type)
//      {
//      case ACCOUNT:
//          AccountEntry account;
//      case FEE:
//          FeeEntry feeState;
//      case BALANCE:
//          BalanceEntry balance;
//      case ASSET:
//          AssetEntry asset;
//      case REFERENCE_ENTRY:
//          ReferenceEntry reference;
//      case ACCOUNT_TYPE_LIMITS:
//          AccountTypeLimitsEntry accountTypeLimits;
//      case STATISTICS:
//          StatisticsEntry stats;
//      case TRUST:
//          TrustEntry trust;
//      case ACCOUNT_LIMITS:
//          AccountLimitsEntry accountLimits;
//  	case ASSET_PAIR: 
//  		AssetPairEntry assetPair;
//  	case OFFER_ENTRY:
//  		OfferEntry offer;
//  	case REVIEWABLE_REQUEST:
//  		ReviewableRequestEntry reviewableRequest;
//  	case EXTERNAL_SYSTEM_ACCOUNT_ID:
//  		ExternalSystemAccountID externalSystemAccountID;
//  	case SALE:
//  		SaleEntry sale;
//  	case KEY_VALUE:
//  	    KeyValueEntry keyValue;
//  	case ACCOUNT_KYC:
//          AccountKYCEntry accountKYC;
//      case EXTERNAL_SYSTEM_ACCOUNT_ID_POOL_ENTRY:
//          ExternalSystemAccountIDPoolEntry externalSystemAccountIDPoolEntry;
//      case SALE_ANTE:
//          SaleAnteEntry saleAnte;
//      case LIMITS_V2:
//          LimitsV2Entry limitsV2;
//      case STATISTICS_V2:
//          StatisticsV2Entry statisticsV2;
//      case PENDING_STATISTICS:
//          PendingStatisticsEntry pendingStatistics;
//      case CONTRACT:
//          ContractEntry contract;
//      case ACCOUNT_ROLE:
//          AccountRoleEntry accountRole;
//      case ACCOUNT_ROLE_PERMISSION:
//          AccountRolePermissionEntry accountRolePermission;
//      }
//      data;
//  
//      // reserved for future use
//      union switch (LedgerVersion v)
//      {
//      case EMPTY_VERSION:
//          void;
//      }
//      ext;
//  };

//  ===========================================================================
public struct LedgerEntry: XDREncodable {
  public var lastModifiedLedgerSeq: Uint32
  public var data: LedgerEntryData
  public var ext: LedgerEntryExt

  public init(
      lastModifiedLedgerSeq: Uint32,
      data: LedgerEntryData,
      ext: LedgerEntryExt) {

    self.lastModifiedLedgerSeq = lastModifiedLedgerSeq
    self.data = data
    self.ext = ext
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.lastModifiedLedgerSeq.toXDR())
    xdr.append(self.data.toXDR())
    xdr.append(self.ext.toXDR())

    return xdr
  }

  public enum LedgerEntryData: XDRDiscriminatedUnion {
    case account(AccountEntry)
    case fee(FeeEntry)
    case balance(BalanceEntry)
    case asset(AssetEntry)
    case referenceEntry(ReferenceEntry)
    case accountTypeLimits(AccountTypeLimitsEntry)
    case statistics(StatisticsEntry)
    case trust(TrustEntry)
    case accountLimits(AccountLimitsEntry)
    case assetPair(AssetPairEntry)
    case offerEntry(OfferEntry)
    case reviewableRequest(ReviewableRequestEntry)
    case externalSystemAccountId(ExternalSystemAccountID)
    case sale(SaleEntry)
    case keyValue(KeyValueEntry)
    case accountKyc(AccountKYCEntry)
    case externalSystemAccountIdPoolEntry(ExternalSystemAccountIDPoolEntry)
    case saleAnte(SaleAnteEntry)
    case limitsV2(LimitsV2Entry)
    case statisticsV2(StatisticsV2Entry)
    case pendingStatistics(PendingStatisticsEntry)
    case contract(ContractEntry)
    case accountRole(AccountRoleEntry)
    case accountRolePermission(AccountRolePermissionEntry)

    public var discriminant: Int32 {
      switch self {
      case .account: return LedgerEntryType.account.rawValue
      case .fee: return LedgerEntryType.fee.rawValue
      case .balance: return LedgerEntryType.balance.rawValue
      case .asset: return LedgerEntryType.asset.rawValue
      case .referenceEntry: return LedgerEntryType.referenceEntry.rawValue
      case .accountTypeLimits: return LedgerEntryType.accountTypeLimits.rawValue
      case .statistics: return LedgerEntryType.statistics.rawValue
      case .trust: return LedgerEntryType.trust.rawValue
      case .accountLimits: return LedgerEntryType.accountLimits.rawValue
      case .assetPair: return LedgerEntryType.assetPair.rawValue
      case .offerEntry: return LedgerEntryType.offerEntry.rawValue
      case .reviewableRequest: return LedgerEntryType.reviewableRequest.rawValue
      case .externalSystemAccountId: return LedgerEntryType.externalSystemAccountId.rawValue
      case .sale: return LedgerEntryType.sale.rawValue
      case .keyValue: return LedgerEntryType.keyValue.rawValue
      case .accountKyc: return LedgerEntryType.accountKyc.rawValue
      case .externalSystemAccountIdPoolEntry: return LedgerEntryType.externalSystemAccountIdPoolEntry.rawValue
      case .saleAnte: return LedgerEntryType.saleAnte.rawValue
      case .limitsV2: return LedgerEntryType.limitsV2.rawValue
      case .statisticsV2: return LedgerEntryType.statisticsV2.rawValue
      case .pendingStatistics: return LedgerEntryType.pendingStatistics.rawValue
      case .contract: return LedgerEntryType.contract.rawValue
      case .accountRole: return LedgerEntryType.accountRole.rawValue
      case .accountRolePermission: return LedgerEntryType.accountRolePermission.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .account(let data): xdr.append(data.toXDR())
      case .fee(let data): xdr.append(data.toXDR())
      case .balance(let data): xdr.append(data.toXDR())
      case .asset(let data): xdr.append(data.toXDR())
      case .referenceEntry(let data): xdr.append(data.toXDR())
      case .accountTypeLimits(let data): xdr.append(data.toXDR())
      case .statistics(let data): xdr.append(data.toXDR())
      case .trust(let data): xdr.append(data.toXDR())
      case .accountLimits(let data): xdr.append(data.toXDR())
      case .assetPair(let data): xdr.append(data.toXDR())
      case .offerEntry(let data): xdr.append(data.toXDR())
      case .reviewableRequest(let data): xdr.append(data.toXDR())
      case .externalSystemAccountId(let data): xdr.append(data.toXDR())
      case .sale(let data): xdr.append(data.toXDR())
      case .keyValue(let data): xdr.append(data.toXDR())
      case .accountKyc(let data): xdr.append(data.toXDR())
      case .externalSystemAccountIdPoolEntry(let data): xdr.append(data.toXDR())
      case .saleAnte(let data): xdr.append(data.toXDR())
      case .limitsV2(let data): xdr.append(data.toXDR())
      case .statisticsV2(let data): xdr.append(data.toXDR())
      case .pendingStatistics(let data): xdr.append(data.toXDR())
      case .contract(let data): xdr.append(data.toXDR())
      case .accountRole(let data): xdr.append(data.toXDR())
      case .accountRolePermission(let data): xdr.append(data.toXDR())
      }

      return xdr
    }

  }
  public enum LedgerEntryExt: XDRDiscriminatedUnion {
    case emptyVersion()

    public var discriminant: Int32 {
      switch self {
      case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .emptyVersion(): xdr.append(Data())
      }

      return xdr
    }

  }
}

// === xdr source ============================================================

//  enum EnvelopeType
//  {
//      SCP = 1,
//      TX = 2,
//      AUTH = 3
//  };

//  ===========================================================================
public enum EnvelopeType: Int32, XDREnum {
  case scp = 1
  case tx = 2
  case auth = 3
}

// === xdr source ============================================================

//  enum ExternalSystemIDGeneratorType {
//  	BITCOIN_BASIC = 1,
//  	ETHEREUM_BASIC = 2
//  };

//  ===========================================================================
public enum ExternalSystemIDGeneratorType: Int32, XDREnum {
  case bitcoinBasic = 1
  case ethereumBasic = 2
}

// === xdr source ============================================================

//  typedef opaque UpgradeType<128>;

//  ===========================================================================
public typealias UpgradeType = Data

// === xdr source ============================================================

//  struct StellarValue
//  {
//      Hash txSetHash;   // transaction set to apply to previous ledger
//      uint64 closeTime; // network close time
//  
//      // upgrades to apply to the previous ledger (usually empty)
//      // this is a vector of encoded 'LedgerUpgrade' so that nodes can drop
//      // unknown steps during consensus if needed.
//      // see notes below on 'LedgerUpgrade' for more detail
//      // max size is dictated by number of upgrade types (+ room for future)
//      UpgradeType upgrades<6>;
//  
//      // reserved for future use
//      union switch (LedgerVersion v)
//      {
//      case EMPTY_VERSION:
//          void;
//      }
//      ext;
//  };

//  ===========================================================================
public struct StellarValue: XDREncodable {
  public var txSetHash: Hash
  public var closeTime: Uint64
  public var upgrades: [UpgradeType]
  public var ext: StellarValueExt

  public init(
      txSetHash: Hash,
      closeTime: Uint64,
      upgrades: [UpgradeType],
      ext: StellarValueExt) {

    self.txSetHash = txSetHash
    self.closeTime = closeTime
    self.upgrades = upgrades
    self.ext = ext
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.txSetHash.toXDR())
    xdr.append(self.closeTime.toXDR())
    xdr.append(self.upgrades.toXDR())
    xdr.append(self.ext.toXDR())

    return xdr
  }

  public enum StellarValueExt: XDRDiscriminatedUnion {
    case emptyVersion()

    public var discriminant: Int32 {
      switch self {
      case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .emptyVersion(): xdr.append(Data())
      }

      return xdr
    }

  }
}

// === xdr source ============================================================

//  struct IdGenerator {
//  	LedgerEntryType entryType; // type of the entry, for which ids will be generated
//  	uint64 idPool; // last used entry specific ID, used for generating entry of specified type
//  };

//  ===========================================================================
public struct IdGenerator: XDREncodable {
  public var entryType: LedgerEntryType
  public var idPool: Uint64

  public init(
      entryType: LedgerEntryType,
      idPool: Uint64) {

    self.entryType = entryType
    self.idPool = idPool
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.entryType.toXDR())
    xdr.append(self.idPool.toXDR())

    return xdr
  }
}

// === xdr source ============================================================

//  struct LedgerHeader
//  {
//      uint32 ledgerVersion;    // the protocol version of the ledger
//      Hash previousLedgerHash; // hash of the previous ledger header
//      StellarValue scpValue;   // what consensus agreed to
//      Hash txSetResultHash;    // the TransactionResultSet that led to this ledger
//      Hash bucketListHash;     // hash of the ledger state
//  
//      uint32 ledgerSeq; // sequence number of this ledger
//  
//      IdGenerator idGenerators<>; // generators of ids
//  
//      uint32 baseFee;     // base fee per operation in stroops
//      uint32 baseReserve; // account base reserve in stroops
//  
//      uint32 maxTxSetSize; // maximum size a transaction set can be
//  
//      ExternalSystemIDGeneratorType externalSystemIDGenerators<>;
//      int64 txExpirationPeriod;
//      
//      Hash skipList[4]; // hashes of ledgers in the past. allows you to jump back
//                        // in time without walking the chain back ledger by ledger
//                        // each slot contains the oldest ledger that is mod of
//                        // either 50  5000  50000 or 500000 depending on index
//                        // skipList[0] mod(50), skipList[1] mod(5000), etc
//  
//      // reserved for future use
//      union switch (LedgerVersion v)
//      {
//      case EMPTY_VERSION:
//          void;
//      }
//      ext;
//  };

//  ===========================================================================
public struct LedgerHeader: XDREncodable {
  public var ledgerVersion: Uint32
  public var previousLedgerHash: Hash
  public var scpValue: StellarValue
  public var txSetResultHash: Hash
  public var bucketListHash: Hash
  public var ledgerSeq: Uint32
  public var idGenerators: [IdGenerator]
  public var baseFee: Uint32
  public var baseReserve: Uint32
  public var maxTxSetSize: Uint32
  public var externalSystemIDGenerators: [ExternalSystemIDGeneratorType]
  public var txExpirationPeriod: Int64
  public var skipList: XDRArrayFixed<Hash>
  public var ext: LedgerHeaderExt

  public init(
      ledgerVersion: Uint32,
      previousLedgerHash: Hash,
      scpValue: StellarValue,
      txSetResultHash: Hash,
      bucketListHash: Hash,
      ledgerSeq: Uint32,
      idGenerators: [IdGenerator],
      baseFee: Uint32,
      baseReserve: Uint32,
      maxTxSetSize: Uint32,
      externalSystemIDGenerators: [ExternalSystemIDGeneratorType],
      txExpirationPeriod: Int64,
      skipList: XDRArrayFixed<Hash>,
      ext: LedgerHeaderExt) {

    self.ledgerVersion = ledgerVersion
    self.previousLedgerHash = previousLedgerHash
    self.scpValue = scpValue
    self.txSetResultHash = txSetResultHash
    self.bucketListHash = bucketListHash
    self.ledgerSeq = ledgerSeq
    self.idGenerators = idGenerators
    self.baseFee = baseFee
    self.baseReserve = baseReserve
    self.maxTxSetSize = maxTxSetSize
    self.externalSystemIDGenerators = externalSystemIDGenerators
    self.txExpirationPeriod = txExpirationPeriod
    self.skipList = skipList
    self.ext = ext
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.ledgerVersion.toXDR())
    xdr.append(self.previousLedgerHash.toXDR())
    xdr.append(self.scpValue.toXDR())
    xdr.append(self.txSetResultHash.toXDR())
    xdr.append(self.bucketListHash.toXDR())
    xdr.append(self.ledgerSeq.toXDR())
    xdr.append(self.idGenerators.toXDR())
    xdr.append(self.baseFee.toXDR())
    xdr.append(self.baseReserve.toXDR())
    xdr.append(self.maxTxSetSize.toXDR())
    xdr.append(self.externalSystemIDGenerators.toXDR())
    xdr.append(self.txExpirationPeriod.toXDR())
    xdr.append(self.skipList.toXDR())
    xdr.append(self.ext.toXDR())

    return xdr
  }

  public enum LedgerHeaderExt: XDRDiscriminatedUnion {
    case emptyVersion()

    public var discriminant: Int32 {
      switch self {
      case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .emptyVersion(): xdr.append(Data())
      }

      return xdr
    }

  }
}

// === xdr source ============================================================

//  enum LedgerUpgradeType
//  {
//      VERSION = 1,
//      MAX_TX_SET_SIZE = 2,
//      TX_EXPIRATION_PERIOD = 3,
//  	EXTERNAL_SYSTEM_ID_GENERATOR = 4
//  };

//  ===========================================================================
public enum LedgerUpgradeType: Int32, XDREnum {
  case version = 1
  case maxTxSetSize = 2
  case txExpirationPeriod = 3
  case externalSystemIdGenerator = 4
}

// === xdr source ============================================================

//  union LedgerUpgrade switch (LedgerUpgradeType type)
//  {
//  case VERSION:
//      uint32 newLedgerVersion; // update ledgerVersion
//  case MAX_TX_SET_SIZE:
//      uint32 newMaxTxSetSize; // update maxTxSetSize
//  case EXTERNAL_SYSTEM_ID_GENERATOR:
//      ExternalSystemIDGeneratorType newExternalSystemIDGenerators<>;
//  case TX_EXPIRATION_PERIOD:
//      int64 newTxExpirationPeriod;
//  };

//  ===========================================================================
public enum LedgerUpgrade: XDRDiscriminatedUnion {
  case version(Uint32)
  case maxTxSetSize(Uint32)
  case externalSystemIdGenerator([ExternalSystemIDGeneratorType])
  case txExpirationPeriod(Int64)

  public var discriminant: Int32 {
    switch self {
    case .version: return LedgerUpgradeType.version.rawValue
    case .maxTxSetSize: return LedgerUpgradeType.maxTxSetSize.rawValue
    case .externalSystemIdGenerator: return LedgerUpgradeType.externalSystemIdGenerator.rawValue
    case .txExpirationPeriod: return LedgerUpgradeType.txExpirationPeriod.rawValue
    }
  }

  public func toXDR() -> Data {
    var xdr = Data()
          
    xdr.append(self.discriminant.toXDR())
          
    switch self {
    case .version(let data): xdr.append(data.toXDR())
    case .maxTxSetSize(let data): xdr.append(data.toXDR())
    case .externalSystemIdGenerator(let data): xdr.append(data.toXDR())
    case .txExpirationPeriod(let data): xdr.append(data.toXDR())
    }

    return xdr
  }
}

// === xdr source ============================================================

//  union LedgerKey switch (LedgerEntryType type)
//  {
//  case ACCOUNT:
//      struct
//      {
//          AccountID accountID;
//  		union switch (LedgerVersion v)
//  		{
//  		case EMPTY_VERSION:
//  			void;
//  		}
//  		ext;
//      } account;
//  case FEE:
//      struct {
//          Hash hash;
//  		int64 lowerBound;
//  		int64 upperBound;
//  		 union switch (LedgerVersion v)
//  		{
//  		case EMPTY_VERSION:
//  			void;
//  		}
//  		ext;
//      } feeState;
//  case BALANCE:
//      struct
//      {
//  		BalanceID balanceID;
//  		union switch (LedgerVersion v)
//  		{
//  		case EMPTY_VERSION:
//  			void;
//  		}
//  		ext;
//      } balance;
//  case ASSET:
//      struct
//      {
//  		AssetCode code;
//  		union switch (LedgerVersion v)
//  		{
//  		case EMPTY_VERSION:
//  			void;
//  		}
//  		ext;
//      } asset;
//  case REFERENCE_ENTRY:
//      struct
//      {
//  		AccountID sender;
//  		string64 reference;
//  		union switch (LedgerVersion v)
//  		{
//  		case EMPTY_VERSION:
//  			void;
//  		}
//  		ext;
//      } reference;
//  case ACCOUNT_TYPE_LIMITS:
//      struct {
//          AccountType accountType;
//  		union switch (LedgerVersion v)
//  		{
//  		case EMPTY_VERSION:
//  			void;
//  		}
//  		ext;
//      } accountTypeLimits;
//  case STATISTICS:
//      struct {
//          AccountID accountID;
//  		union switch (LedgerVersion v)
//  		{
//  		case EMPTY_VERSION:
//  			void;
//  		}
//  		ext;
//      } stats;
//  case TRUST:
//      struct {
//          AccountID allowedAccount;
//          BalanceID balanceToUse;
//  		union switch (LedgerVersion v)
//  		{
//  		case EMPTY_VERSION:
//  			void;
//  		}
//  		ext;
//      } trust;
//  case ACCOUNT_LIMITS:
//      struct {
//          AccountID accountID;
//  		union switch (LedgerVersion v)
//  		{
//  		case EMPTY_VERSION:
//  			void;
//  		}
//  		ext;
//      } accountLimits;
//  case ASSET_PAIR:
//  	struct {
//           AssetCode base;
//  		 AssetCode quote;
//  		 union switch (LedgerVersion v)
//  		{
//  		case EMPTY_VERSION:
//  			void;
//  		}
//  		ext;
//      } assetPair;
//  case OFFER_ENTRY:
//  	struct {
//  		uint64 offerID;
//  		AccountID ownerID;
//  	} offer;
//  case REVIEWABLE_REQUEST:
//      struct {
//          uint64 requestID;
//  		union switch (LedgerVersion v)
//  		{
//  		case EMPTY_VERSION:
//  			void;
//  		}
//  		ext;
//      } reviewableRequest;
//  case EXTERNAL_SYSTEM_ACCOUNT_ID:
//  	struct {
//  		AccountID accountID;
//  		int32 externalSystemType;
//  		union switch (LedgerVersion v)
//  		{
//  		case EMPTY_VERSION:
//  			void;
//  		}
//  		ext;
//  	} externalSystemAccountID;
//  case SALE:
//  	struct {
//  		uint64 saleID;
//  		union switch (LedgerVersion v)
//  		{
//  		case EMPTY_VERSION:
//  			void;
//  		}
//  		ext;
//  	} sale;
//  case KEY_VALUE:
//      struct {
//          string256 key;
//          union switch (LedgerVersion v)
//          {
//          	case EMPTY_VERSION:
//          		void;
//          }
//          ext;
//      } keyValue;
//  case ACCOUNT_KYC:
//      struct {
//          AccountID accountID;
//          union switch(LedgerVersion v)
//          {
//          case EMPTY_VERSION:
//              void;
//          }
//          ext;
//      } accountKYC;
//  case EXTERNAL_SYSTEM_ACCOUNT_ID_POOL_ENTRY:
//      struct {
//  		uint64 poolEntryID;
//  		union switch (LedgerVersion v)
//  		{
//  		case EMPTY_VERSION:
//  			void;
//  		}
//  		ext;
//  	} externalSystemAccountIDPoolEntry;
//  case SALE_ANTE:
//      struct {
//          uint64 saleID;
//          BalanceID participantBalanceID;
//          union switch (LedgerVersion v)
//          {
//          case EMPTY_VERSION:
//              void;
//          } ext;
//      } saleAnte;
//  case LIMITS_V2:
//      struct {
//          uint64 id;
//          union switch (LedgerVersion v)
//          {
//          case EMPTY_VERSION:
//              void;
//          } ext;
//      } limitsV2;
//  case STATISTICS_V2:
//      struct {
//          uint64 id;
//          union switch (LedgerVersion v)
//          {
//          case EMPTY_VERSION:
//              void;
//          }
//          ext;
//      } statisticsV2;
//  case PENDING_STATISTICS:
//      struct {
//          uint64 statisticsID;
//          uint64 requestID;
//          union switch (LedgerVersion v)
//          {
//          case EMPTY_VERSION:
//              void;
//          }
//          ext;
//      } pendingStatistics;
//  case CONTRACT:
//      struct {
//          uint64 contractID;
//          union switch (LedgerVersion v)
//          {
//          case EMPTY_VERSION:
//              void;
//          }
//          ext;
//      } contract;
//  case ACCOUNT_ROLE:
//      struct {
//          uint64 accountRoleID;
//          union switch (LedgerVersion v)
//          {
//          case EMPTY_VERSION:
//              void;
//          }
//          ext;
//      } accountRole;
//  case ACCOUNT_ROLE_PERMISSION:
//      struct {
//          uint64 permissionID;
//          union switch (LedgerVersion v)
//          {
//          case EMPTY_VERSION:
//              void;
//          }
//          ext;
//      } accountRolePermission;
//  };

//  ===========================================================================
public enum LedgerKey: XDRDiscriminatedUnion {
  case account(LedgerKeyAccount)
  case fee(LedgerKeyFeeState)
  case balance(LedgerKeyBalance)
  case asset(LedgerKeyAsset)
  case referenceEntry(LedgerKeyReference)
  case accountTypeLimits(LedgerKeyAccountTypeLimits)
  case statistics(LedgerKeyStats)
  case trust(LedgerKeyTrust)
  case accountLimits(LedgerKeyAccountLimits)
  case assetPair(LedgerKeyAssetPair)
  case offerEntry(LedgerKeyOffer)
  case reviewableRequest(LedgerKeyReviewableRequest)
  case externalSystemAccountId(LedgerKeyExternalSystemAccountID)
  case sale(LedgerKeySale)
  case keyValue(LedgerKeyKeyValue)
  case accountKyc(LedgerKeyAccountKYC)
  case externalSystemAccountIdPoolEntry(LedgerKeyExternalSystemAccountIDPoolEntry)
  case saleAnte(LedgerKeySaleAnte)
  case limitsV2(LedgerKeyLimitsV2)
  case statisticsV2(LedgerKeyStatisticsV2)
  case pendingStatistics(LedgerKeyPendingStatistics)
  case contract(LedgerKeyContract)
  case accountRole(LedgerKeyAccountRole)
  case accountRolePermission(LedgerKeyAccountRolePermission)

  public var discriminant: Int32 {
    switch self {
    case .account: return LedgerEntryType.account.rawValue
    case .fee: return LedgerEntryType.fee.rawValue
    case .balance: return LedgerEntryType.balance.rawValue
    case .asset: return LedgerEntryType.asset.rawValue
    case .referenceEntry: return LedgerEntryType.referenceEntry.rawValue
    case .accountTypeLimits: return LedgerEntryType.accountTypeLimits.rawValue
    case .statistics: return LedgerEntryType.statistics.rawValue
    case .trust: return LedgerEntryType.trust.rawValue
    case .accountLimits: return LedgerEntryType.accountLimits.rawValue
    case .assetPair: return LedgerEntryType.assetPair.rawValue
    case .offerEntry: return LedgerEntryType.offerEntry.rawValue
    case .reviewableRequest: return LedgerEntryType.reviewableRequest.rawValue
    case .externalSystemAccountId: return LedgerEntryType.externalSystemAccountId.rawValue
    case .sale: return LedgerEntryType.sale.rawValue
    case .keyValue: return LedgerEntryType.keyValue.rawValue
    case .accountKyc: return LedgerEntryType.accountKyc.rawValue
    case .externalSystemAccountIdPoolEntry: return LedgerEntryType.externalSystemAccountIdPoolEntry.rawValue
    case .saleAnte: return LedgerEntryType.saleAnte.rawValue
    case .limitsV2: return LedgerEntryType.limitsV2.rawValue
    case .statisticsV2: return LedgerEntryType.statisticsV2.rawValue
    case .pendingStatistics: return LedgerEntryType.pendingStatistics.rawValue
    case .contract: return LedgerEntryType.contract.rawValue
    case .accountRole: return LedgerEntryType.accountRole.rawValue
    case .accountRolePermission: return LedgerEntryType.accountRolePermission.rawValue
    }
  }

  public func toXDR() -> Data {
    var xdr = Data()
          
    xdr.append(self.discriminant.toXDR())
          
    switch self {
    case .account(let data): xdr.append(data.toXDR())
    case .fee(let data): xdr.append(data.toXDR())
    case .balance(let data): xdr.append(data.toXDR())
    case .asset(let data): xdr.append(data.toXDR())
    case .referenceEntry(let data): xdr.append(data.toXDR())
    case .accountTypeLimits(let data): xdr.append(data.toXDR())
    case .statistics(let data): xdr.append(data.toXDR())
    case .trust(let data): xdr.append(data.toXDR())
    case .accountLimits(let data): xdr.append(data.toXDR())
    case .assetPair(let data): xdr.append(data.toXDR())
    case .offerEntry(let data): xdr.append(data.toXDR())
    case .reviewableRequest(let data): xdr.append(data.toXDR())
    case .externalSystemAccountId(let data): xdr.append(data.toXDR())
    case .sale(let data): xdr.append(data.toXDR())
    case .keyValue(let data): xdr.append(data.toXDR())
    case .accountKyc(let data): xdr.append(data.toXDR())
    case .externalSystemAccountIdPoolEntry(let data): xdr.append(data.toXDR())
    case .saleAnte(let data): xdr.append(data.toXDR())
    case .limitsV2(let data): xdr.append(data.toXDR())
    case .statisticsV2(let data): xdr.append(data.toXDR())
    case .pendingStatistics(let data): xdr.append(data.toXDR())
    case .contract(let data): xdr.append(data.toXDR())
    case .accountRole(let data): xdr.append(data.toXDR())
    case .accountRolePermission(let data): xdr.append(data.toXDR())
    }

    return xdr
  }

  public struct LedgerKeyAccount: XDREncodable {
    public var accountID: AccountID
    public var ext: LedgerKeyAccountExt

    public init(
        accountID: AccountID,
        ext: LedgerKeyAccountExt) {

      self.accountID = accountID
      self.ext = ext
    }

    public func toXDR() -> Data {
      var xdr = Data()

      xdr.append(self.accountID.toXDR())
      xdr.append(self.ext.toXDR())

      return xdr
    }

    public enum LedgerKeyAccountExt: XDRDiscriminatedUnion {
      case emptyVersion()

      public var discriminant: Int32 {
        switch self {
        case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
        }
      }

      public func toXDR() -> Data {
        var xdr = Data()
              
        xdr.append(self.discriminant.toXDR())
              
        switch self {
        case .emptyVersion(): xdr.append(Data())
        }

        return xdr
      }

    }
  }
  public struct LedgerKeyFeeState: XDREncodable {
    public var hash: Hash
    public var lowerBound: Int64
    public var upperBound: Int64
    public var ext: LedgerKeyFeeStateExt

    public init(
        hash: Hash,
        lowerBound: Int64,
        upperBound: Int64,
        ext: LedgerKeyFeeStateExt) {

      self.hash = hash
      self.lowerBound = lowerBound
      self.upperBound = upperBound
      self.ext = ext
    }

    public func toXDR() -> Data {
      var xdr = Data()

      xdr.append(self.hash.toXDR())
      xdr.append(self.lowerBound.toXDR())
      xdr.append(self.upperBound.toXDR())
      xdr.append(self.ext.toXDR())

      return xdr
    }

    public enum LedgerKeyFeeStateExt: XDRDiscriminatedUnion {
      case emptyVersion()

      public var discriminant: Int32 {
        switch self {
        case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
        }
      }

      public func toXDR() -> Data {
        var xdr = Data()
              
        xdr.append(self.discriminant.toXDR())
              
        switch self {
        case .emptyVersion(): xdr.append(Data())
        }

        return xdr
      }

    }
  }
  public struct LedgerKeyBalance: XDREncodable {
    public var balanceID: BalanceID
    public var ext: LedgerKeyBalanceExt

    public init(
        balanceID: BalanceID,
        ext: LedgerKeyBalanceExt) {

      self.balanceID = balanceID
      self.ext = ext
    }

    public func toXDR() -> Data {
      var xdr = Data()

      xdr.append(self.balanceID.toXDR())
      xdr.append(self.ext.toXDR())

      return xdr
    }

    public enum LedgerKeyBalanceExt: XDRDiscriminatedUnion {
      case emptyVersion()

      public var discriminant: Int32 {
        switch self {
        case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
        }
      }

      public func toXDR() -> Data {
        var xdr = Data()
              
        xdr.append(self.discriminant.toXDR())
              
        switch self {
        case .emptyVersion(): xdr.append(Data())
        }

        return xdr
      }

    }
  }
  public struct LedgerKeyAsset: XDREncodable {
    public var code: AssetCode
    public var ext: LedgerKeyAssetExt

    public init(
        code: AssetCode,
        ext: LedgerKeyAssetExt) {

      self.code = code
      self.ext = ext
    }

    public func toXDR() -> Data {
      var xdr = Data()

      xdr.append(self.code.toXDR())
      xdr.append(self.ext.toXDR())

      return xdr
    }

    public enum LedgerKeyAssetExt: XDRDiscriminatedUnion {
      case emptyVersion()

      public var discriminant: Int32 {
        switch self {
        case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
        }
      }

      public func toXDR() -> Data {
        var xdr = Data()
              
        xdr.append(self.discriminant.toXDR())
              
        switch self {
        case .emptyVersion(): xdr.append(Data())
        }

        return xdr
      }

    }
  }
  public struct LedgerKeyReference: XDREncodable {
    public var sender: AccountID
    public var reference: String64
    public var ext: LedgerKeyReferenceExt

    public init(
        sender: AccountID,
        reference: String64,
        ext: LedgerKeyReferenceExt) {

      self.sender = sender
      self.reference = reference
      self.ext = ext
    }

    public func toXDR() -> Data {
      var xdr = Data()

      xdr.append(self.sender.toXDR())
      xdr.append(self.reference.toXDR())
      xdr.append(self.ext.toXDR())

      return xdr
    }

    public enum LedgerKeyReferenceExt: XDRDiscriminatedUnion {
      case emptyVersion()

      public var discriminant: Int32 {
        switch self {
        case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
        }
      }

      public func toXDR() -> Data {
        var xdr = Data()
              
        xdr.append(self.discriminant.toXDR())
              
        switch self {
        case .emptyVersion(): xdr.append(Data())
        }

        return xdr
      }

    }
  }
  public struct LedgerKeyAccountTypeLimits: XDREncodable {
    public var accountType: AccountType
    public var ext: LedgerKeyAccountTypeLimitsExt

    public init(
        accountType: AccountType,
        ext: LedgerKeyAccountTypeLimitsExt) {

      self.accountType = accountType
      self.ext = ext
    }

    public func toXDR() -> Data {
      var xdr = Data()

      xdr.append(self.accountType.toXDR())
      xdr.append(self.ext.toXDR())

      return xdr
    }

    public enum LedgerKeyAccountTypeLimitsExt: XDRDiscriminatedUnion {
      case emptyVersion()

      public var discriminant: Int32 {
        switch self {
        case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
        }
      }

      public func toXDR() -> Data {
        var xdr = Data()
              
        xdr.append(self.discriminant.toXDR())
              
        switch self {
        case .emptyVersion(): xdr.append(Data())
        }

        return xdr
      }

    }
  }
  public struct LedgerKeyStats: XDREncodable {
    public var accountID: AccountID
    public var ext: LedgerKeyStatsExt

    public init(
        accountID: AccountID,
        ext: LedgerKeyStatsExt) {

      self.accountID = accountID
      self.ext = ext
    }

    public func toXDR() -> Data {
      var xdr = Data()

      xdr.append(self.accountID.toXDR())
      xdr.append(self.ext.toXDR())

      return xdr
    }

    public enum LedgerKeyStatsExt: XDRDiscriminatedUnion {
      case emptyVersion()

      public var discriminant: Int32 {
        switch self {
        case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
        }
      }

      public func toXDR() -> Data {
        var xdr = Data()
              
        xdr.append(self.discriminant.toXDR())
              
        switch self {
        case .emptyVersion(): xdr.append(Data())
        }

        return xdr
      }

    }
  }
  public struct LedgerKeyTrust: XDREncodable {
    public var allowedAccount: AccountID
    public var balanceToUse: BalanceID
    public var ext: LedgerKeyTrustExt

    public init(
        allowedAccount: AccountID,
        balanceToUse: BalanceID,
        ext: LedgerKeyTrustExt) {

      self.allowedAccount = allowedAccount
      self.balanceToUse = balanceToUse
      self.ext = ext
    }

    public func toXDR() -> Data {
      var xdr = Data()

      xdr.append(self.allowedAccount.toXDR())
      xdr.append(self.balanceToUse.toXDR())
      xdr.append(self.ext.toXDR())

      return xdr
    }

    public enum LedgerKeyTrustExt: XDRDiscriminatedUnion {
      case emptyVersion()

      public var discriminant: Int32 {
        switch self {
        case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
        }
      }

      public func toXDR() -> Data {
        var xdr = Data()
              
        xdr.append(self.discriminant.toXDR())
              
        switch self {
        case .emptyVersion(): xdr.append(Data())
        }

        return xdr
      }

    }
  }
  public struct LedgerKeyAccountLimits: XDREncodable {
    public var accountID: AccountID
    public var ext: LedgerKeyAccountLimitsExt

    public init(
        accountID: AccountID,
        ext: LedgerKeyAccountLimitsExt) {

      self.accountID = accountID
      self.ext = ext
    }

    public func toXDR() -> Data {
      var xdr = Data()

      xdr.append(self.accountID.toXDR())
      xdr.append(self.ext.toXDR())

      return xdr
    }

    public enum LedgerKeyAccountLimitsExt: XDRDiscriminatedUnion {
      case emptyVersion()

      public var discriminant: Int32 {
        switch self {
        case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
        }
      }

      public func toXDR() -> Data {
        var xdr = Data()
              
        xdr.append(self.discriminant.toXDR())
              
        switch self {
        case .emptyVersion(): xdr.append(Data())
        }

        return xdr
      }

    }
  }
  public struct LedgerKeyAssetPair: XDREncodable {
    public var base: AssetCode
    public var quote: AssetCode
    public var ext: LedgerKeyAssetPairExt

    public init(
        base: AssetCode,
        quote: AssetCode,
        ext: LedgerKeyAssetPairExt) {

      self.base = base
      self.quote = quote
      self.ext = ext
    }

    public func toXDR() -> Data {
      var xdr = Data()

      xdr.append(self.base.toXDR())
      xdr.append(self.quote.toXDR())
      xdr.append(self.ext.toXDR())

      return xdr
    }

    public enum LedgerKeyAssetPairExt: XDRDiscriminatedUnion {
      case emptyVersion()

      public var discriminant: Int32 {
        switch self {
        case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
        }
      }

      public func toXDR() -> Data {
        var xdr = Data()
              
        xdr.append(self.discriminant.toXDR())
              
        switch self {
        case .emptyVersion(): xdr.append(Data())
        }

        return xdr
      }

    }
  }
  public struct LedgerKeyOffer: XDREncodable {
    public var offerID: Uint64
    public var ownerID: AccountID

    public init(
        offerID: Uint64,
        ownerID: AccountID) {

      self.offerID = offerID
      self.ownerID = ownerID
    }

    public func toXDR() -> Data {
      var xdr = Data()

      xdr.append(self.offerID.toXDR())
      xdr.append(self.ownerID.toXDR())

      return xdr
    }

  }
  public struct LedgerKeyReviewableRequest: XDREncodable {
    public var requestID: Uint64
    public var ext: LedgerKeyReviewableRequestExt

    public init(
        requestID: Uint64,
        ext: LedgerKeyReviewableRequestExt) {

      self.requestID = requestID
      self.ext = ext
    }

    public func toXDR() -> Data {
      var xdr = Data()

      xdr.append(self.requestID.toXDR())
      xdr.append(self.ext.toXDR())

      return xdr
    }

    public enum LedgerKeyReviewableRequestExt: XDRDiscriminatedUnion {
      case emptyVersion()

      public var discriminant: Int32 {
        switch self {
        case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
        }
      }

      public func toXDR() -> Data {
        var xdr = Data()
              
        xdr.append(self.discriminant.toXDR())
              
        switch self {
        case .emptyVersion(): xdr.append(Data())
        }

        return xdr
      }

    }
  }
  public struct LedgerKeyExternalSystemAccountID: XDREncodable {
    public var accountID: AccountID
    public var externalSystemType: Int32
    public var ext: LedgerKeyExternalSystemAccountIDExt

    public init(
        accountID: AccountID,
        externalSystemType: Int32,
        ext: LedgerKeyExternalSystemAccountIDExt) {

      self.accountID = accountID
      self.externalSystemType = externalSystemType
      self.ext = ext
    }

    public func toXDR() -> Data {
      var xdr = Data()

      xdr.append(self.accountID.toXDR())
      xdr.append(self.externalSystemType.toXDR())
      xdr.append(self.ext.toXDR())

      return xdr
    }

    public enum LedgerKeyExternalSystemAccountIDExt: XDRDiscriminatedUnion {
      case emptyVersion()

      public var discriminant: Int32 {
        switch self {
        case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
        }
      }

      public func toXDR() -> Data {
        var xdr = Data()
              
        xdr.append(self.discriminant.toXDR())
              
        switch self {
        case .emptyVersion(): xdr.append(Data())
        }

        return xdr
      }

    }
  }
  public struct LedgerKeySale: XDREncodable {
    public var saleID: Uint64
    public var ext: LedgerKeySaleExt

    public init(
        saleID: Uint64,
        ext: LedgerKeySaleExt) {

      self.saleID = saleID
      self.ext = ext
    }

    public func toXDR() -> Data {
      var xdr = Data()

      xdr.append(self.saleID.toXDR())
      xdr.append(self.ext.toXDR())

      return xdr
    }

    public enum LedgerKeySaleExt: XDRDiscriminatedUnion {
      case emptyVersion()

      public var discriminant: Int32 {
        switch self {
        case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
        }
      }

      public func toXDR() -> Data {
        var xdr = Data()
              
        xdr.append(self.discriminant.toXDR())
              
        switch self {
        case .emptyVersion(): xdr.append(Data())
        }

        return xdr
      }

    }
  }
  public struct LedgerKeyKeyValue: XDREncodable {
    public var key: String256
    public var ext: LedgerKeyKeyValueExt

    public init(
        key: String256,
        ext: LedgerKeyKeyValueExt) {

      self.key = key
      self.ext = ext
    }

    public func toXDR() -> Data {
      var xdr = Data()

      xdr.append(self.key.toXDR())
      xdr.append(self.ext.toXDR())

      return xdr
    }

    public enum LedgerKeyKeyValueExt: XDRDiscriminatedUnion {
      case emptyVersion()

      public var discriminant: Int32 {
        switch self {
        case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
        }
      }

      public func toXDR() -> Data {
        var xdr = Data()
              
        xdr.append(self.discriminant.toXDR())
              
        switch self {
        case .emptyVersion(): xdr.append(Data())
        }

        return xdr
      }

    }
  }
  public struct LedgerKeyAccountKYC: XDREncodable {
    public var accountID: AccountID
    public var ext: LedgerKeyAccountKYCExt

    public init(
        accountID: AccountID,
        ext: LedgerKeyAccountKYCExt) {

      self.accountID = accountID
      self.ext = ext
    }

    public func toXDR() -> Data {
      var xdr = Data()

      xdr.append(self.accountID.toXDR())
      xdr.append(self.ext.toXDR())

      return xdr
    }

    public enum LedgerKeyAccountKYCExt: XDRDiscriminatedUnion {
      case emptyVersion()

      public var discriminant: Int32 {
        switch self {
        case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
        }
      }

      public func toXDR() -> Data {
        var xdr = Data()
              
        xdr.append(self.discriminant.toXDR())
              
        switch self {
        case .emptyVersion(): xdr.append(Data())
        }

        return xdr
      }

    }
  }
  public struct LedgerKeyExternalSystemAccountIDPoolEntry: XDREncodable {
    public var poolEntryID: Uint64
    public var ext: LedgerKeyExternalSystemAccountIDPoolEntryExt

    public init(
        poolEntryID: Uint64,
        ext: LedgerKeyExternalSystemAccountIDPoolEntryExt) {

      self.poolEntryID = poolEntryID
      self.ext = ext
    }

    public func toXDR() -> Data {
      var xdr = Data()

      xdr.append(self.poolEntryID.toXDR())
      xdr.append(self.ext.toXDR())

      return xdr
    }

    public enum LedgerKeyExternalSystemAccountIDPoolEntryExt: XDRDiscriminatedUnion {
      case emptyVersion()

      public var discriminant: Int32 {
        switch self {
        case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
        }
      }

      public func toXDR() -> Data {
        var xdr = Data()
              
        xdr.append(self.discriminant.toXDR())
              
        switch self {
        case .emptyVersion(): xdr.append(Data())
        }

        return xdr
      }

    }
  }
  public struct LedgerKeySaleAnte: XDREncodable {
    public var saleID: Uint64
    public var participantBalanceID: BalanceID
    public var ext: LedgerKeySaleAnteExt

    public init(
        saleID: Uint64,
        participantBalanceID: BalanceID,
        ext: LedgerKeySaleAnteExt) {

      self.saleID = saleID
      self.participantBalanceID = participantBalanceID
      self.ext = ext
    }

    public func toXDR() -> Data {
      var xdr = Data()

      xdr.append(self.saleID.toXDR())
      xdr.append(self.participantBalanceID.toXDR())
      xdr.append(self.ext.toXDR())

      return xdr
    }

    public enum LedgerKeySaleAnteExt: XDRDiscriminatedUnion {
      case emptyVersion()

      public var discriminant: Int32 {
        switch self {
        case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
        }
      }

      public func toXDR() -> Data {
        var xdr = Data()
              
        xdr.append(self.discriminant.toXDR())
              
        switch self {
        case .emptyVersion(): xdr.append(Data())
        }

        return xdr
      }

    }
  }
  public struct LedgerKeyLimitsV2: XDREncodable {
    public var id: Uint64
    public var ext: LedgerKeyLimitsV2Ext

    public init(
        id: Uint64,
        ext: LedgerKeyLimitsV2Ext) {

      self.id = id
      self.ext = ext
    }

    public func toXDR() -> Data {
      var xdr = Data()

      xdr.append(self.id.toXDR())
      xdr.append(self.ext.toXDR())

      return xdr
    }

    public enum LedgerKeyLimitsV2Ext: XDRDiscriminatedUnion {
      case emptyVersion()

      public var discriminant: Int32 {
        switch self {
        case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
        }
      }

      public func toXDR() -> Data {
        var xdr = Data()
              
        xdr.append(self.discriminant.toXDR())
              
        switch self {
        case .emptyVersion(): xdr.append(Data())
        }

        return xdr
      }

    }
  }
  public struct LedgerKeyStatisticsV2: XDREncodable {
    public var id: Uint64
    public var ext: LedgerKeyStatisticsV2Ext

    public init(
        id: Uint64,
        ext: LedgerKeyStatisticsV2Ext) {

      self.id = id
      self.ext = ext
    }

    public func toXDR() -> Data {
      var xdr = Data()

      xdr.append(self.id.toXDR())
      xdr.append(self.ext.toXDR())

      return xdr
    }

    public enum LedgerKeyStatisticsV2Ext: XDRDiscriminatedUnion {
      case emptyVersion()

      public var discriminant: Int32 {
        switch self {
        case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
        }
      }

      public func toXDR() -> Data {
        var xdr = Data()
              
        xdr.append(self.discriminant.toXDR())
              
        switch self {
        case .emptyVersion(): xdr.append(Data())
        }

        return xdr
      }

    }
  }
  public struct LedgerKeyPendingStatistics: XDREncodable {
    public var statisticsID: Uint64
    public var requestID: Uint64
    public var ext: LedgerKeyPendingStatisticsExt

    public init(
        statisticsID: Uint64,
        requestID: Uint64,
        ext: LedgerKeyPendingStatisticsExt) {

      self.statisticsID = statisticsID
      self.requestID = requestID
      self.ext = ext
    }

    public func toXDR() -> Data {
      var xdr = Data()

      xdr.append(self.statisticsID.toXDR())
      xdr.append(self.requestID.toXDR())
      xdr.append(self.ext.toXDR())

      return xdr
    }

    public enum LedgerKeyPendingStatisticsExt: XDRDiscriminatedUnion {
      case emptyVersion()

      public var discriminant: Int32 {
        switch self {
        case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
        }
      }

      public func toXDR() -> Data {
        var xdr = Data()
              
        xdr.append(self.discriminant.toXDR())
              
        switch self {
        case .emptyVersion(): xdr.append(Data())
        }

        return xdr
      }

    }
  }
  public struct LedgerKeyContract: XDREncodable {
    public var contractID: Uint64
    public var ext: LedgerKeyContractExt

    public init(
        contractID: Uint64,
        ext: LedgerKeyContractExt) {

      self.contractID = contractID
      self.ext = ext
    }

    public func toXDR() -> Data {
      var xdr = Data()

      xdr.append(self.contractID.toXDR())
      xdr.append(self.ext.toXDR())

      return xdr
    }

    public enum LedgerKeyContractExt: XDRDiscriminatedUnion {
      case emptyVersion()

      public var discriminant: Int32 {
        switch self {
        case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
        }
      }

      public func toXDR() -> Data {
        var xdr = Data()
              
        xdr.append(self.discriminant.toXDR())
              
        switch self {
        case .emptyVersion(): xdr.append(Data())
        }

        return xdr
      }

    }
  }
  public struct LedgerKeyAccountRole: XDREncodable {
    public var accountRoleID: Uint64
    public var ext: LedgerKeyAccountRoleExt

    public init(
        accountRoleID: Uint64,
        ext: LedgerKeyAccountRoleExt) {

      self.accountRoleID = accountRoleID
      self.ext = ext
    }

    public func toXDR() -> Data {
      var xdr = Data()

      xdr.append(self.accountRoleID.toXDR())
      xdr.append(self.ext.toXDR())

      return xdr
    }

    public enum LedgerKeyAccountRoleExt: XDRDiscriminatedUnion {
      case emptyVersion()

      public var discriminant: Int32 {
        switch self {
        case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
        }
      }

      public func toXDR() -> Data {
        var xdr = Data()
              
        xdr.append(self.discriminant.toXDR())
              
        switch self {
        case .emptyVersion(): xdr.append(Data())
        }

        return xdr
      }

    }
  }
  public struct LedgerKeyAccountRolePermission: XDREncodable {
    public var permissionID: Uint64
    public var ext: LedgerKeyAccountRolePermissionExt

    public init(
        permissionID: Uint64,
        ext: LedgerKeyAccountRolePermissionExt) {

      self.permissionID = permissionID
      self.ext = ext
    }

    public func toXDR() -> Data {
      var xdr = Data()

      xdr.append(self.permissionID.toXDR())
      xdr.append(self.ext.toXDR())

      return xdr
    }

    public enum LedgerKeyAccountRolePermissionExt: XDRDiscriminatedUnion {
      case emptyVersion()

      public var discriminant: Int32 {
        switch self {
        case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
        }
      }

      public func toXDR() -> Data {
        var xdr = Data()
              
        xdr.append(self.discriminant.toXDR())
              
        switch self {
        case .emptyVersion(): xdr.append(Data())
        }

        return xdr
      }

    }
  }
}

// === xdr source ============================================================

//  enum BucketEntryType
//  {
//      LIVEENTRY = 0,
//      DEADENTRY = 1
//  };

//  ===========================================================================
public enum BucketEntryType: Int32, XDREnum {
  case liveentry = 0
  case deadentry = 1
}

// === xdr source ============================================================

//  union BucketEntry switch (BucketEntryType type)
//  {
//  case LIVEENTRY:
//      LedgerEntry liveEntry;
//  
//  case DEADENTRY:
//      LedgerKey deadEntry;
//  };

//  ===========================================================================
public enum BucketEntry: XDRDiscriminatedUnion {
  case liveentry(LedgerEntry)
  case deadentry(LedgerKey)

  public var discriminant: Int32 {
    switch self {
    case .liveentry: return BucketEntryType.liveentry.rawValue
    case .deadentry: return BucketEntryType.deadentry.rawValue
    }
  }

  public func toXDR() -> Data {
    var xdr = Data()
          
    xdr.append(self.discriminant.toXDR())
          
    switch self {
    case .liveentry(let data): xdr.append(data.toXDR())
    case .deadentry(let data): xdr.append(data.toXDR())
    }

    return xdr
  }
}

// === xdr source ============================================================

//  struct TransactionSet
//  {
//      Hash previousLedgerHash;
//      TransactionEnvelope txs<>;
//  };

//  ===========================================================================
public struct TransactionSet: XDREncodable {
  public var previousLedgerHash: Hash
  public var txs: [TransactionEnvelope]

  public init(
      previousLedgerHash: Hash,
      txs: [TransactionEnvelope]) {

    self.previousLedgerHash = previousLedgerHash
    self.txs = txs
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.previousLedgerHash.toXDR())
    xdr.append(self.txs.toXDR())

    return xdr
  }
}

// === xdr source ============================================================

//  struct TransactionResultPair
//  {
//      Hash transactionHash;
//      TransactionResult result; // result for the transaction
//  };

//  ===========================================================================
public struct TransactionResultPair: XDREncodable {
  public var transactionHash: Hash
  public var result: TransactionResult

  public init(
      transactionHash: Hash,
      result: TransactionResult) {

    self.transactionHash = transactionHash
    self.result = result
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.transactionHash.toXDR())
    xdr.append(self.result.toXDR())

    return xdr
  }
}

// === xdr source ============================================================

//  struct TransactionResultSet
//  {
//      TransactionResultPair results<>;
//  };

//  ===========================================================================
public struct TransactionResultSet: XDREncodable {
  public var results: [TransactionResultPair]

  public init(
      results: [TransactionResultPair]) {

    self.results = results
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.results.toXDR())

    return xdr
  }
}

// === xdr source ============================================================

//  struct TransactionHistoryEntry
//  {
//      uint32 ledgerSeq;
//      TransactionSet txSet;
//  
//      // reserved for future use
//      union switch (LedgerVersion v)
//      {
//      case EMPTY_VERSION:
//          void;
//      }
//      ext;
//  };

//  ===========================================================================
public struct TransactionHistoryEntry: XDREncodable {
  public var ledgerSeq: Uint32
  public var txSet: TransactionSet
  public var ext: TransactionHistoryEntryExt

  public init(
      ledgerSeq: Uint32,
      txSet: TransactionSet,
      ext: TransactionHistoryEntryExt) {

    self.ledgerSeq = ledgerSeq
    self.txSet = txSet
    self.ext = ext
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.ledgerSeq.toXDR())
    xdr.append(self.txSet.toXDR())
    xdr.append(self.ext.toXDR())

    return xdr
  }

  public enum TransactionHistoryEntryExt: XDRDiscriminatedUnion {
    case emptyVersion()

    public var discriminant: Int32 {
      switch self {
      case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .emptyVersion(): xdr.append(Data())
      }

      return xdr
    }

  }
}

// === xdr source ============================================================

//  struct TransactionHistoryResultEntry
//  {
//      uint32 ledgerSeq;
//      TransactionResultSet txResultSet;
//  
//      // reserved for future use
//      union switch (LedgerVersion v)
//      {
//      case EMPTY_VERSION:
//          void;
//      }
//      ext;
//  };

//  ===========================================================================
public struct TransactionHistoryResultEntry: XDREncodable {
  public var ledgerSeq: Uint32
  public var txResultSet: TransactionResultSet
  public var ext: TransactionHistoryResultEntryExt

  public init(
      ledgerSeq: Uint32,
      txResultSet: TransactionResultSet,
      ext: TransactionHistoryResultEntryExt) {

    self.ledgerSeq = ledgerSeq
    self.txResultSet = txResultSet
    self.ext = ext
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.ledgerSeq.toXDR())
    xdr.append(self.txResultSet.toXDR())
    xdr.append(self.ext.toXDR())

    return xdr
  }

  public enum TransactionHistoryResultEntryExt: XDRDiscriminatedUnion {
    case emptyVersion()

    public var discriminant: Int32 {
      switch self {
      case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .emptyVersion(): xdr.append(Data())
      }

      return xdr
    }

  }
}

// === xdr source ============================================================

//  struct LedgerHeaderHistoryEntry
//  {
//      Hash hash;
//      LedgerHeader header;
//  
//      // reserved for future use
//      union switch (LedgerVersion v)
//      {
//      case EMPTY_VERSION:
//          void;
//      }
//      ext;
//  };

//  ===========================================================================
public struct LedgerHeaderHistoryEntry: XDREncodable {
  public var hash: Hash
  public var header: LedgerHeader
  public var ext: LedgerHeaderHistoryEntryExt

  public init(
      hash: Hash,
      header: LedgerHeader,
      ext: LedgerHeaderHistoryEntryExt) {

    self.hash = hash
    self.header = header
    self.ext = ext
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.hash.toXDR())
    xdr.append(self.header.toXDR())
    xdr.append(self.ext.toXDR())

    return xdr
  }

  public enum LedgerHeaderHistoryEntryExt: XDRDiscriminatedUnion {
    case emptyVersion()

    public var discriminant: Int32 {
      switch self {
      case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .emptyVersion(): xdr.append(Data())
      }

      return xdr
    }

  }
}

// === xdr source ============================================================

//  struct LedgerSCPMessages
//  {
//      uint32 ledgerSeq;
//      SCPEnvelope messages<>;
//  };

//  ===========================================================================
public struct LedgerSCPMessages: XDREncodable {
  public var ledgerSeq: Uint32
  public var messages: [SCPEnvelope]

  public init(
      ledgerSeq: Uint32,
      messages: [SCPEnvelope]) {

    self.ledgerSeq = ledgerSeq
    self.messages = messages
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.ledgerSeq.toXDR())
    xdr.append(self.messages.toXDR())

    return xdr
  }
}

// === xdr source ============================================================

//  struct SCPHistoryEntryV0
//  {
//      SCPQuorumSet quorumSets<>; // additional quorum sets used by ledgerMessages
//      LedgerSCPMessages ledgerMessages;
//  };

//  ===========================================================================
public struct SCPHistoryEntryV0: XDREncodable {
  public var quorumSets: [SCPQuorumSet]
  public var ledgerMessages: LedgerSCPMessages

  public init(
      quorumSets: [SCPQuorumSet],
      ledgerMessages: LedgerSCPMessages) {

    self.quorumSets = quorumSets
    self.ledgerMessages = ledgerMessages
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.quorumSets.toXDR())
    xdr.append(self.ledgerMessages.toXDR())

    return xdr
  }
}

// === xdr source ============================================================

//  union SCPHistoryEntry switch (LedgerVersion v)
//  {
//  case EMPTY_VERSION:
//      SCPHistoryEntryV0 v0;
//  };

//  ===========================================================================
public enum SCPHistoryEntry: XDRDiscriminatedUnion {
  case emptyVersion(SCPHistoryEntryV0)

  public var discriminant: Int32 {
    switch self {
    case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
    }
  }

  public func toXDR() -> Data {
    var xdr = Data()
          
    xdr.append(self.discriminant.toXDR())
          
    switch self {
    case .emptyVersion(let data): xdr.append(data.toXDR())
    }

    return xdr
  }
}

// === xdr source ============================================================

//  enum LedgerEntryChangeType
//  {
//      CREATED = 0, // entry was added to the ledger
//      UPDATED = 1, // entry was modified in the ledger
//      REMOVED = 2, // entry was removed from the ledger
//      STATE = 3    // value of the entry
//  };

//  ===========================================================================
public enum LedgerEntryChangeType: Int32, XDREnum {
  case created = 0
  case updated = 1
  case removed = 2
  case state = 3
}

// === xdr source ============================================================

//  union LedgerEntryChange switch (LedgerEntryChangeType type)
//  {
//  case CREATED:
//      LedgerEntry created;
//  case UPDATED:
//      LedgerEntry updated;
//  case REMOVED:
//      LedgerKey removed;
//  case STATE:
//      LedgerEntry state;
//  };

//  ===========================================================================
public enum LedgerEntryChange: XDRDiscriminatedUnion {
  case created(LedgerEntry)
  case updated(LedgerEntry)
  case removed(LedgerKey)
  case state(LedgerEntry)

  public var discriminant: Int32 {
    switch self {
    case .created: return LedgerEntryChangeType.created.rawValue
    case .updated: return LedgerEntryChangeType.updated.rawValue
    case .removed: return LedgerEntryChangeType.removed.rawValue
    case .state: return LedgerEntryChangeType.state.rawValue
    }
  }

  public func toXDR() -> Data {
    var xdr = Data()
          
    xdr.append(self.discriminant.toXDR())
          
    switch self {
    case .created(let data): xdr.append(data.toXDR())
    case .updated(let data): xdr.append(data.toXDR())
    case .removed(let data): xdr.append(data.toXDR())
    case .state(let data): xdr.append(data.toXDR())
    }

    return xdr
  }
}

// === xdr source ============================================================

//  typedef LedgerEntryChange LedgerEntryChanges<>;

//  ===========================================================================
public typealias LedgerEntryChanges = [LedgerEntryChange]

// === xdr source ============================================================

//  struct OperationMeta
//  {
//      LedgerEntryChanges changes;
//  };

//  ===========================================================================
public struct OperationMeta: XDREncodable {
  public var changes: LedgerEntryChanges

  public init(
      changes: LedgerEntryChanges) {

    self.changes = changes
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.changes.toXDR())

    return xdr
  }
}

// === xdr source ============================================================

//  union TransactionMeta switch (LedgerVersion v)
//  {
//  case EMPTY_VERSION:
//      OperationMeta operations<>;
//  };

//  ===========================================================================
public enum TransactionMeta: XDRDiscriminatedUnion {
  case emptyVersion([OperationMeta])

  public var discriminant: Int32 {
    switch self {
    case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
    }
  }

  public func toXDR() -> Data {
    var xdr = Data()
          
    xdr.append(self.discriminant.toXDR())
          
    switch self {
    case .emptyVersion(let data): xdr.append(data.toXDR())
    }

    return xdr
  }
}

// === xdr source ============================================================

//  struct BindExternalSystemAccountIdOp
//  {
//      int32 externalSystemType;
//  
//      union switch (LedgerVersion v)
//      {
//      case EMPTY_VERSION:
//          void;
//      }
//      ext;
//  };

//  ===========================================================================
public struct BindExternalSystemAccountIdOp: XDREncodable {
  public var externalSystemType: Int32
  public var ext: BindExternalSystemAccountIdOpExt

  public init(
      externalSystemType: Int32,
      ext: BindExternalSystemAccountIdOpExt) {

    self.externalSystemType = externalSystemType
    self.ext = ext
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.externalSystemType.toXDR())
    xdr.append(self.ext.toXDR())

    return xdr
  }

  public enum BindExternalSystemAccountIdOpExt: XDRDiscriminatedUnion {
    case emptyVersion()

    public var discriminant: Int32 {
      switch self {
      case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .emptyVersion(): xdr.append(Data())
      }

      return xdr
    }

  }
}

// === xdr source ============================================================

//  enum BindExternalSystemAccountIdResultCode
//  {
//      // codes considered as "success" for the operation
//      SUCCESS = 0,
//  
//      // codes considered as "failure" for the operation
//      MALFORMED = -1,
//      NO_AVAILABLE_ID = -2,
//      AUTO_GENERATED_TYPE_NOT_ALLOWED = -3
//  };

//  ===========================================================================
public enum BindExternalSystemAccountIdResultCode: Int32, XDREnum {
  case success = 0
  case malformed = -1
  case noAvailableId = -2
  case autoGeneratedTypeNotAllowed = -3
}

// === xdr source ============================================================

//  struct BindExternalSystemAccountIdSuccess {
//      longstring data;
//      // reserved for future use
//      union switch (LedgerVersion v)
//      {
//      case EMPTY_VERSION:
//          void;
//      }
//      ext;
//  };

//  ===========================================================================
public struct BindExternalSystemAccountIdSuccess: XDREncodable {
  public var data: Longstring
  public var ext: BindExternalSystemAccountIdSuccessExt

  public init(
      data: Longstring,
      ext: BindExternalSystemAccountIdSuccessExt) {

    self.data = data
    self.ext = ext
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.data.toXDR())
    xdr.append(self.ext.toXDR())

    return xdr
  }

  public enum BindExternalSystemAccountIdSuccessExt: XDRDiscriminatedUnion {
    case emptyVersion()

    public var discriminant: Int32 {
      switch self {
      case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .emptyVersion(): xdr.append(Data())
      }

      return xdr
    }

  }
}

// === xdr source ============================================================

//  union BindExternalSystemAccountIdResult switch (BindExternalSystemAccountIdResultCode code)
//  {
//  case SUCCESS:
//      BindExternalSystemAccountIdSuccess success;
//  default:
//      void;
//  };

//  ===========================================================================
public enum BindExternalSystemAccountIdResult: XDRDiscriminatedUnion {
  case success(BindExternalSystemAccountIdSuccess)

  public var discriminant: Int32 {
    switch self {
    case .success: return BindExternalSystemAccountIdResultCode.success.rawValue
    }
  }

  public func toXDR() -> Data {
    var xdr = Data()
          
    xdr.append(self.discriminant.toXDR())
          
    switch self {
    case .success(let data): xdr.append(data.toXDR())
    }

    return xdr
  }
}

// === xdr source ============================================================

//  struct CancelSaleCreationRequestOp
//  {
//      uint64 requestID;
//  
//      union switch (LedgerVersion v)
//      {
//      case EMPTY_VERSION:
//          void;
//      }
//      ext;
//  
//  };

//  ===========================================================================
public struct CancelSaleCreationRequestOp: XDREncodable {
  public var requestID: Uint64
  public var ext: CancelSaleCreationRequestOpExt

  public init(
      requestID: Uint64,
      ext: CancelSaleCreationRequestOpExt) {

    self.requestID = requestID
    self.ext = ext
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.requestID.toXDR())
    xdr.append(self.ext.toXDR())

    return xdr
  }

  public enum CancelSaleCreationRequestOpExt: XDRDiscriminatedUnion {
    case emptyVersion()

    public var discriminant: Int32 {
      switch self {
      case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .emptyVersion(): xdr.append(Data())
      }

      return xdr
    }

  }
}

// === xdr source ============================================================

//  enum CancelSaleCreationRequestResultCode
//  {
//      // codes considered as "success" for the operation
//      SUCCESS = 0,
//  
//      // codes considered as "failure" for the operation
//      REQUEST_ID_INVALID = -1, // request id can not be equal zero
//      REQUEST_NOT_FOUND = -2 // trying to cancel not existing reviewable request
//  };

//  ===========================================================================
public enum CancelSaleCreationRequestResultCode: Int32, XDREnum {
  case success = 0
  case requestIdInvalid = -1
  case requestNotFound = -2
}

// === xdr source ============================================================

//  struct CancelSaleCreationSuccess {
//  
//      union switch (LedgerVersion v)
//      {
//      case EMPTY_VERSION:
//          void;
//      }
//      ext;
//  };

//  ===========================================================================
public struct CancelSaleCreationSuccess: XDREncodable {
  public var ext: CancelSaleCreationSuccessExt

  public init(
      ext: CancelSaleCreationSuccessExt) {

    self.ext = ext
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.ext.toXDR())

    return xdr
  }

  public enum CancelSaleCreationSuccessExt: XDRDiscriminatedUnion {
    case emptyVersion()

    public var discriminant: Int32 {
      switch self {
      case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .emptyVersion(): xdr.append(Data())
      }

      return xdr
    }

  }
}

// === xdr source ============================================================

//  union CancelSaleCreationRequestResult switch (CancelSaleCreationRequestResultCode code)
//  {
//      case SUCCESS:
//          CancelSaleCreationSuccess success;
//      default:
//          void;
//  };

//  ===========================================================================
public enum CancelSaleCreationRequestResult: XDRDiscriminatedUnion {
  case success(CancelSaleCreationSuccess)

  public var discriminant: Int32 {
    switch self {
    case .success: return CancelSaleCreationRequestResultCode.success.rawValue
    }
  }

  public func toXDR() -> Data {
    var xdr = Data()
          
    xdr.append(self.discriminant.toXDR())
          
    switch self {
    case .success(let data): xdr.append(data.toXDR())
    }

    return xdr
  }
}

// === xdr source ============================================================

//  struct CheckSaleStateOp
//  {
//  	uint64 saleID;
//  	 // reserved for future use
//      union switch (LedgerVersion v)
//      {
//      case EMPTY_VERSION:
//          void;		
//      }
//      ext;
//  };

//  ===========================================================================
public struct CheckSaleStateOp: XDREncodable {
  public var saleID: Uint64
  public var ext: CheckSaleStateOpExt

  public init(
      saleID: Uint64,
      ext: CheckSaleStateOpExt) {

    self.saleID = saleID
    self.ext = ext
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.saleID.toXDR())
    xdr.append(self.ext.toXDR())

    return xdr
  }

  public enum CheckSaleStateOpExt: XDRDiscriminatedUnion {
    case emptyVersion()

    public var discriminant: Int32 {
      switch self {
      case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .emptyVersion(): xdr.append(Data())
      }

      return xdr
    }

  }
}

// === xdr source ============================================================

//  enum CheckSaleStateResultCode
//  {
//      // codes considered as "success" for the operation
//      SUCCESS = 0, // sale was processed
//  
//      // codes considered as "failure" for the operation
//      NOT_FOUND = -1, // sale was not found
//  	NOT_READY = -2 // sale is not ready to be closed or canceled
//  };

//  ===========================================================================
public enum CheckSaleStateResultCode: Int32, XDREnum {
  case success = 0
  case notFound = -1
  case notReady = -2
}

// === xdr source ============================================================

//  enum CheckSaleStateEffect {
//  	CANCELED = 1, // sale did not managed to go over soft cap in time
//  	CLOSED = 2, // sale met hard cap or (end time and soft cap)
//  	UPDATED = 3 // on check sale was modified and modifications must be saved
//  };

//  ===========================================================================
public enum CheckSaleStateEffect: Int32, XDREnum {
  case canceled = 1
  case closed = 2
  case updated = 3
}

// === xdr source ============================================================

//  struct SaleCanceled {
//  	 // reserved for future use
//      union switch (LedgerVersion v)
//      {
//      case EMPTY_VERSION:
//          void;
//      }
//      ext;
//  };

//  ===========================================================================
public struct SaleCanceled: XDREncodable {
  public var ext: SaleCanceledExt

  public init(
      ext: SaleCanceledExt) {

    self.ext = ext
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.ext.toXDR())

    return xdr
  }

  public enum SaleCanceledExt: XDRDiscriminatedUnion {
    case emptyVersion()

    public var discriminant: Int32 {
      switch self {
      case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .emptyVersion(): xdr.append(Data())
      }

      return xdr
    }

  }
}

// === xdr source ============================================================

//  struct SaleUpdated {
//  	 // reserved for future use
//      union switch (LedgerVersion v)
//      {
//      case EMPTY_VERSION:
//          void;
//      }
//      ext;
//  };

//  ===========================================================================
public struct SaleUpdated: XDREncodable {
  public var ext: SaleUpdatedExt

  public init(
      ext: SaleUpdatedExt) {

    self.ext = ext
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.ext.toXDR())

    return xdr
  }

  public enum SaleUpdatedExt: XDRDiscriminatedUnion {
    case emptyVersion()

    public var discriminant: Int32 {
      switch self {
      case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .emptyVersion(): xdr.append(Data())
      }

      return xdr
    }

  }
}

// === xdr source ============================================================

//  struct CheckSubSaleClosedResult {
//  	BalanceID saleBaseBalance;
//  	BalanceID saleQuoteBalance;
//  	ManageOfferSuccessResult saleDetails;
//  	 // reserved for future use
//      union switch (LedgerVersion v)
//      {
//      case EMPTY_VERSION:
//          void;
//      }
//      ext;
//  };

//  ===========================================================================
public struct CheckSubSaleClosedResult: XDREncodable {
  public var saleBaseBalance: BalanceID
  public var saleQuoteBalance: BalanceID
  public var saleDetails: ManageOfferSuccessResult
  public var ext: CheckSubSaleClosedResultExt

  public init(
      saleBaseBalance: BalanceID,
      saleQuoteBalance: BalanceID,
      saleDetails: ManageOfferSuccessResult,
      ext: CheckSubSaleClosedResultExt) {

    self.saleBaseBalance = saleBaseBalance
    self.saleQuoteBalance = saleQuoteBalance
    self.saleDetails = saleDetails
    self.ext = ext
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.saleBaseBalance.toXDR())
    xdr.append(self.saleQuoteBalance.toXDR())
    xdr.append(self.saleDetails.toXDR())
    xdr.append(self.ext.toXDR())

    return xdr
  }

  public enum CheckSubSaleClosedResultExt: XDRDiscriminatedUnion {
    case emptyVersion()

    public var discriminant: Int32 {
      switch self {
      case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .emptyVersion(): xdr.append(Data())
      }

      return xdr
    }

  }
}

// === xdr source ============================================================

//  struct CheckSaleClosedResult {
//  	AccountID saleOwner;
//  	CheckSubSaleClosedResult results<>;
//  	 // reserved for future use
//      union switch (LedgerVersion v)
//      {
//      case EMPTY_VERSION:
//          void;
//      }
//      ext;
//  };

//  ===========================================================================
public struct CheckSaleClosedResult: XDREncodable {
  public var saleOwner: AccountID
  public var results: [CheckSubSaleClosedResult]
  public var ext: CheckSaleClosedResultExt

  public init(
      saleOwner: AccountID,
      results: [CheckSubSaleClosedResult],
      ext: CheckSaleClosedResultExt) {

    self.saleOwner = saleOwner
    self.results = results
    self.ext = ext
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.saleOwner.toXDR())
    xdr.append(self.results.toXDR())
    xdr.append(self.ext.toXDR())

    return xdr
  }

  public enum CheckSaleClosedResultExt: XDRDiscriminatedUnion {
    case emptyVersion()

    public var discriminant: Int32 {
      switch self {
      case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .emptyVersion(): xdr.append(Data())
      }

      return xdr
    }

  }
}

// === xdr source ============================================================

//  struct CheckSaleStateSuccess
//  {
//  	uint64 saleID;
//  	union switch (CheckSaleStateEffect effect)
//      {
//      case CANCELED:
//          SaleCanceled saleCanceled;
//  	case CLOSED:
//  		CheckSaleClosedResult saleClosed;
//  	case UPDATED:
//  		SaleUpdated saleUpdated;
//      }
//      effect;
//  	 // reserved for future use
//      union switch (LedgerVersion v)
//      {
//      case EMPTY_VERSION:
//          void;
//      }
//      ext;
//  };

//  ===========================================================================
public struct CheckSaleStateSuccess: XDREncodable {
  public var saleID: Uint64
  public var effect: CheckSaleStateSuccessEffect
  public var ext: CheckSaleStateSuccessExt

  public init(
      saleID: Uint64,
      effect: CheckSaleStateSuccessEffect,
      ext: CheckSaleStateSuccessExt) {

    self.saleID = saleID
    self.effect = effect
    self.ext = ext
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.saleID.toXDR())
    xdr.append(self.effect.toXDR())
    xdr.append(self.ext.toXDR())

    return xdr
  }

  public enum CheckSaleStateSuccessEffect: XDRDiscriminatedUnion {
    case canceled(SaleCanceled)
    case closed(CheckSaleClosedResult)
    case updated(SaleUpdated)

    public var discriminant: Int32 {
      switch self {
      case .canceled: return CheckSaleStateEffect.canceled.rawValue
      case .closed: return CheckSaleStateEffect.closed.rawValue
      case .updated: return CheckSaleStateEffect.updated.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .canceled(let data): xdr.append(data.toXDR())
      case .closed(let data): xdr.append(data.toXDR())
      case .updated(let data): xdr.append(data.toXDR())
      }

      return xdr
    }

  }
  public enum CheckSaleStateSuccessExt: XDRDiscriminatedUnion {
    case emptyVersion()

    public var discriminant: Int32 {
      switch self {
      case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .emptyVersion(): xdr.append(Data())
      }

      return xdr
    }

  }
}

// === xdr source ============================================================

//  union CheckSaleStateResult switch (CheckSaleStateResultCode code)
//  {
//  case SUCCESS:
//      CheckSaleStateSuccess success;
//  default:
//      void;
//  };

//  ===========================================================================
public enum CheckSaleStateResult: XDRDiscriminatedUnion {
  case success(CheckSaleStateSuccess)

  public var discriminant: Int32 {
    switch self {
    case .success: return CheckSaleStateResultCode.success.rawValue
    }
  }

  public func toXDR() -> Data {
    var xdr = Data()
          
    xdr.append(self.discriminant.toXDR())
          
    switch self {
    case .success(let data): xdr.append(data.toXDR())
    }

    return xdr
  }
}

// === xdr source ============================================================

//  struct CreateAMLAlertRequestOp
//  {
//      string64 reference;
//      AMLAlertRequest amlAlertRequest;
//  
//  	union switch (LedgerVersion v)
//      {
//      case EMPTY_VERSION:
//          void;
//      }
//      ext;
//  
//  };

//  ===========================================================================
public struct CreateAMLAlertRequestOp: XDREncodable {
  public var reference: String64
  public var amlAlertRequest: AMLAlertRequest
  public var ext: CreateAMLAlertRequestOpExt

  public init(
      reference: String64,
      amlAlertRequest: AMLAlertRequest,
      ext: CreateAMLAlertRequestOpExt) {

    self.reference = reference
    self.amlAlertRequest = amlAlertRequest
    self.ext = ext
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.reference.toXDR())
    xdr.append(self.amlAlertRequest.toXDR())
    xdr.append(self.ext.toXDR())

    return xdr
  }

  public enum CreateAMLAlertRequestOpExt: XDRDiscriminatedUnion {
    case emptyVersion()

    public var discriminant: Int32 {
      switch self {
      case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .emptyVersion(): xdr.append(Data())
      }

      return xdr
    }

  }
}

// === xdr source ============================================================

//  enum CreateAMLAlertRequestResultCode
//  {
//      // codes considered as "success" for the operation
//      SUCCESS = 0,
//      BALANCE_NOT_EXIST = 1, // balance doesn't exist
//      INVALID_REASON = 2, //invalid reason for request
//      UNDERFUNDED = 3, //when couldn't lock balance
//  	REFERENCE_DUPLICATION = 4, // reference already exists
//  	INVALID_AMOUNT = 5 // amount must be positive
//  
//  
//  };

//  ===========================================================================
public enum CreateAMLAlertRequestResultCode: Int32, XDREnum {
  case success = 0
  case balanceNotExist = 1
  case invalidReason = 2
  case underfunded = 3
  case referenceDuplication = 4
  case invalidAmount = 5
}

// === xdr source ============================================================

//  struct CreateAMLAlertRequestSuccess {
//  	uint64 requestID;
//  
//  	union switch (LedgerVersion v)
//      {
//      case EMPTY_VERSION:
//          void;
//      }
//      ext;
//  };

//  ===========================================================================
public struct CreateAMLAlertRequestSuccess: XDREncodable {
  public var requestID: Uint64
  public var ext: CreateAMLAlertRequestSuccessExt

  public init(
      requestID: Uint64,
      ext: CreateAMLAlertRequestSuccessExt) {

    self.requestID = requestID
    self.ext = ext
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.requestID.toXDR())
    xdr.append(self.ext.toXDR())

    return xdr
  }

  public enum CreateAMLAlertRequestSuccessExt: XDRDiscriminatedUnion {
    case emptyVersion()

    public var discriminant: Int32 {
      switch self {
      case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .emptyVersion(): xdr.append(Data())
      }

      return xdr
    }

  }
}

// === xdr source ============================================================

//  union CreateAMLAlertRequestResult switch (CreateAMLAlertRequestResultCode code)
//  {
//      case SUCCESS:
//          CreateAMLAlertRequestSuccess success;
//      default:
//          void;
//  };

//  ===========================================================================
public enum CreateAMLAlertRequestResult: XDRDiscriminatedUnion {
  case success(CreateAMLAlertRequestSuccess)

  public var discriminant: Int32 {
    switch self {
    case .success: return CreateAMLAlertRequestResultCode.success.rawValue
    }
  }

  public func toXDR() -> Data {
    var xdr = Data()
          
    xdr.append(self.discriminant.toXDR())
          
    switch self {
    case .success(let data): xdr.append(data.toXDR())
    }

    return xdr
  }
}

// === xdr source ============================================================

//  struct UpdateKYCRequestData {
//      AccountID accountToUpdateKYC;
//  	AccountType accountTypeToSet;
//  	uint32 kycLevelToSet;
//      longstring kycData;
//  	uint32* allTasks;
//  
//  	// Reserved for future use
//  	union switch (LedgerVersion v)
//      {
//      case EMPTY_VERSION:
//          void;
//      }
//      ext;
//  };

//  ===========================================================================
public struct UpdateKYCRequestData: XDREncodable {
  public var accountToUpdateKYC: AccountID
  public var accountTypeToSet: AccountType
  public var kycLevelToSet: Uint32
  public var kycData: Longstring
  public var allTasks: Uint32?
  public var ext: UpdateKYCRequestDataExt

  public init(
      accountToUpdateKYC: AccountID,
      accountTypeToSet: AccountType,
      kycLevelToSet: Uint32,
      kycData: Longstring,
      allTasks: Uint32?,
      ext: UpdateKYCRequestDataExt) {

    self.accountToUpdateKYC = accountToUpdateKYC
    self.accountTypeToSet = accountTypeToSet
    self.kycLevelToSet = kycLevelToSet
    self.kycData = kycData
    self.allTasks = allTasks
    self.ext = ext
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.accountToUpdateKYC.toXDR())
    xdr.append(self.accountTypeToSet.toXDR())
    xdr.append(self.kycLevelToSet.toXDR())
    xdr.append(self.kycData.toXDR())
    xdr.append(self.allTasks.toXDR())
    xdr.append(self.ext.toXDR())

    return xdr
  }

  public enum UpdateKYCRequestDataExt: XDRDiscriminatedUnion {
    case emptyVersion()

    public var discriminant: Int32 {
      switch self {
      case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .emptyVersion(): xdr.append(Data())
      }

      return xdr
    }

  }
}

// === xdr source ============================================================

//  struct CreateUpdateKYCRequestOp {
//      uint64 requestID;
//      UpdateKYCRequestData updateKYCRequestData;
//      union switch (LedgerVersion v)
//      {
//      case EMPTY_VERSION:
//          void;
//      }
//      ext;
//  };

//  ===========================================================================
public struct CreateUpdateKYCRequestOp: XDREncodable {
  public var requestID: Uint64
  public var updateKYCRequestData: UpdateKYCRequestData
  public var ext: CreateUpdateKYCRequestOpExt

  public init(
      requestID: Uint64,
      updateKYCRequestData: UpdateKYCRequestData,
      ext: CreateUpdateKYCRequestOpExt) {

    self.requestID = requestID
    self.updateKYCRequestData = updateKYCRequestData
    self.ext = ext
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.requestID.toXDR())
    xdr.append(self.updateKYCRequestData.toXDR())
    xdr.append(self.ext.toXDR())

    return xdr
  }

  public enum CreateUpdateKYCRequestOpExt: XDRDiscriminatedUnion {
    case emptyVersion()

    public var discriminant: Int32 {
      switch self {
      case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .emptyVersion(): xdr.append(Data())
      }

      return xdr
    }

  }
}

// === xdr source ============================================================

//  enum CreateUpdateKYCRequestResultCode
//  {
//      // codes considered as "success" for the operation
//      SUCCESS = 0,
//  
//      // codes considered as "failure" for the operation
//      ACC_TO_UPDATE_DOES_NOT_EXIST = -1, // account to update does not exist
//      REQUEST_ALREADY_EXISTS = -2,
//  	SAME_ACC_TYPE_TO_SET = -3,
//  	REQUEST_DOES_NOT_EXIST = -4,
//  	PENDING_REQUEST_UPDATE_NOT_ALLOWED = -5,
//  	NOT_ALLOWED_TO_UPDATE_REQUEST = -6, // master account can update request only through review request operation
//  	INVALID_UPDATE_KYC_REQUEST_DATA = -7,
//  	INVALID_KYC_DATA = -8,
//  	KYC_RULE_NOT_FOUND = -9
//  };

//  ===========================================================================
public enum CreateUpdateKYCRequestResultCode: Int32, XDREnum {
  case success = 0
  case accToUpdateDoesNotExist = -1
  case requestAlreadyExists = -2
  case sameAccTypeToSet = -3
  case requestDoesNotExist = -4
  case pendingRequestUpdateNotAllowed = -5
  case notAllowedToUpdateRequest = -6
  case invalidUpdateKycRequestData = -7
  case invalidKycData = -8
  case kycRuleNotFound = -9
}

// === xdr source ============================================================

//  union CreateUpdateKYCRequestResult switch (CreateUpdateKYCRequestResultCode code)
//  {
//  case SUCCESS:
//      struct {
//  		uint64 requestID;
//  		bool fulfilled;
//  		// Reserved for future use
//  		union switch (LedgerVersion v)
//  		{
//  		case EMPTY_VERSION:
//  			void;
//  		}
//  		ext;
//  	} success;
//  default:
//      void;
//  };

//  ===========================================================================
public enum CreateUpdateKYCRequestResult: XDRDiscriminatedUnion {
  case success(CreateUpdateKYCRequestResultSuccess)

  public var discriminant: Int32 {
    switch self {
    case .success: return CreateUpdateKYCRequestResultCode.success.rawValue
    }
  }

  public func toXDR() -> Data {
    var xdr = Data()
          
    xdr.append(self.discriminant.toXDR())
          
    switch self {
    case .success(let data): xdr.append(data.toXDR())
    }

    return xdr
  }

  public struct CreateUpdateKYCRequestResultSuccess: XDREncodable {
    public var requestID: Uint64
    public var fulfilled: Bool
    public var ext: CreateUpdateKYCRequestResultSuccessExt

    public init(
        requestID: Uint64,
        fulfilled: Bool,
        ext: CreateUpdateKYCRequestResultSuccessExt) {

      self.requestID = requestID
      self.fulfilled = fulfilled
      self.ext = ext
    }

    public func toXDR() -> Data {
      var xdr = Data()

      xdr.append(self.requestID.toXDR())
      xdr.append(self.fulfilled.toXDR())
      xdr.append(self.ext.toXDR())

      return xdr
    }

    public enum CreateUpdateKYCRequestResultSuccessExt: XDRDiscriminatedUnion {
      case emptyVersion()

      public var discriminant: Int32 {
        switch self {
        case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
        }
      }

      public func toXDR() -> Data {
        var xdr = Data()
              
        xdr.append(self.discriminant.toXDR())
              
        switch self {
        case .emptyVersion(): xdr.append(Data())
        }

        return xdr
      }

    }
  }
}

// === xdr source ============================================================

//  struct CreateAccountOpExtended
//  {
//      ExternalSystemAccountID externalSystemIDs<>;
//      uint64* roleID;
//  
//      // reserved for future use
//      union switch (LedgerVersion v)
//      {
//      case EMPTY_VERSION:
//          void;
//      }
//      ext;
//  };

//  ===========================================================================
public struct CreateAccountOpExtended: XDREncodable {
  public var externalSystemIDs: [ExternalSystemAccountID]
  public var roleID: Uint64?
  public var ext: CreateAccountOpExtendedExt

  public init(
      externalSystemIDs: [ExternalSystemAccountID],
      roleID: Uint64?,
      ext: CreateAccountOpExtendedExt) {

    self.externalSystemIDs = externalSystemIDs
    self.roleID = roleID
    self.ext = ext
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.externalSystemIDs.toXDR())
    xdr.append(self.roleID.toXDR())
    xdr.append(self.ext.toXDR())

    return xdr
  }

  public enum CreateAccountOpExtendedExt: XDRDiscriminatedUnion {
    case emptyVersion()

    public var discriminant: Int32 {
      switch self {
      case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .emptyVersion(): xdr.append(Data())
      }

      return xdr
    }

  }
}

// === xdr source ============================================================

//  struct CreateAccountOp
//  {
//      AccountID destination; // account to create
//      AccountID recoveryKey; // recovery signer's public key
//      AccountID* referrer;     // parent account
//  	AccountType accountType;
//  	uint32 policies;
//  
//  	 // reserved for future use
//      union switch (LedgerVersion v)
//      {
//      case EMPTY_VERSION:
//          void;
//      case PASS_EXTERNAL_SYS_ACC_ID_IN_CREATE_ACC:
//          ExternalSystemAccountID externalSystemIDs<>;
//      case REPLACE_ACCOUNT_TYPES_WITH_POLICIES:
//          CreateAccountOpExtended opExt;
//      }
//      ext;
//  };

//  ===========================================================================
public struct CreateAccountOp: XDREncodable {
  public var destination: AccountID
  public var recoveryKey: AccountID
  public var referrer: AccountID?
  public var accountType: AccountType
  public var policies: Uint32
  public var ext: CreateAccountOpExt

  public init(
      destination: AccountID,
      recoveryKey: AccountID,
      referrer: AccountID?,
      accountType: AccountType,
      policies: Uint32,
      ext: CreateAccountOpExt) {

    self.destination = destination
    self.recoveryKey = recoveryKey
    self.referrer = referrer
    self.accountType = accountType
    self.policies = policies
    self.ext = ext
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.destination.toXDR())
    xdr.append(self.recoveryKey.toXDR())
    xdr.append(self.referrer.toXDR())
    xdr.append(self.accountType.toXDR())
    xdr.append(self.policies.toXDR())
    xdr.append(self.ext.toXDR())

    return xdr
  }

  public enum CreateAccountOpExt: XDRDiscriminatedUnion {
    case emptyVersion()
    case passExternalSysAccIdInCreateAcc([ExternalSystemAccountID])
    case replaceAccountTypesWithPolicies(CreateAccountOpExtended)

    public var discriminant: Int32 {
      switch self {
      case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
      case .passExternalSysAccIdInCreateAcc: return LedgerVersion.passExternalSysAccIdInCreateAcc.rawValue
      case .replaceAccountTypesWithPolicies: return LedgerVersion.replaceAccountTypesWithPolicies.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .emptyVersion(): xdr.append(Data())
      case .passExternalSysAccIdInCreateAcc(let data): xdr.append(data.toXDR())
      case .replaceAccountTypesWithPolicies(let data): xdr.append(data.toXDR())
      }

      return xdr
    }

  }
}

// === xdr source ============================================================

//  enum CreateAccountResultCode
//  {
//      // codes considered as "success" for the operation
//      SUCCESS = 0, // account was created
//  
//      // codes considered as "failure" for the operation
//      MALFORMED = -1,       // invalid destination
//  	ACCOUNT_TYPE_MISMATCHED = -2, // account already exist and change of account type is not allowed
//  	TYPE_NOT_ALLOWED = -3, // master or commission account types are not allowed
//      NAME_DUPLICATION = -4,
//      REFERRER_NOT_FOUND = -5,
//  	INVALID_ACCOUNT_VERSION = -6, // if account version is higher than ledger version
//  	NOT_VERIFIED_CANNOT_HAVE_POLICIES = -7,
//  	EXTERNAL_SYS_ACC_NOT_ALLOWED = -8, // op contains external system account ID which should be generated on core level
//  	EXTERNAL_SYS_ID_EXISTS = -9 // external system account ID already exists
//  };

//  ===========================================================================
public enum CreateAccountResultCode: Int32, XDREnum {
  case success = 0
  case malformed = -1
  case accountTypeMismatched = -2
  case typeNotAllowed = -3
  case nameDuplication = -4
  case referrerNotFound = -5
  case invalidAccountVersion = -6
  case notVerifiedCannotHavePolicies = -7
  case externalSysAccNotAllowed = -8
  case externalSysIdExists = -9
}

// === xdr source ============================================================

//  struct CreateAccountSuccess
//  {
//  	ExternalSystemAccountID externalSystemIDs<>;
//  	 // reserved for future use
//      union switch (LedgerVersion v)
//      {
//      case EMPTY_VERSION:
//          void;
//      }
//      ext;
//  };

//  ===========================================================================
public struct CreateAccountSuccess: XDREncodable {
  public var externalSystemIDs: [ExternalSystemAccountID]
  public var ext: CreateAccountSuccessExt

  public init(
      externalSystemIDs: [ExternalSystemAccountID],
      ext: CreateAccountSuccessExt) {

    self.externalSystemIDs = externalSystemIDs
    self.ext = ext
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.externalSystemIDs.toXDR())
    xdr.append(self.ext.toXDR())

    return xdr
  }

  public enum CreateAccountSuccessExt: XDRDiscriminatedUnion {
    case emptyVersion()

    public var discriminant: Int32 {
      switch self {
      case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .emptyVersion(): xdr.append(Data())
      }

      return xdr
    }

  }
}

// === xdr source ============================================================

//  union CreateAccountResult switch (CreateAccountResultCode code)
//  {
//  case SUCCESS:
//      CreateAccountSuccess success;
//  default:
//      void;
//  };

//  ===========================================================================
public enum CreateAccountResult: XDRDiscriminatedUnion {
  case success(CreateAccountSuccess)

  public var discriminant: Int32 {
    switch self {
    case .success: return CreateAccountResultCode.success.rawValue
    }
  }

  public func toXDR() -> Data {
    var xdr = Data()
          
    xdr.append(self.discriminant.toXDR())
          
    switch self {
    case .success(let data): xdr.append(data.toXDR())
    }

    return xdr
  }
}

// === xdr source ============================================================

//  struct CreateIssuanceRequestOp
//  {
//  	IssuanceRequest request;
//  	string64 reference;
//  	// reserved for future use
//      union switch (LedgerVersion v)
//      {
//      case EMPTY_VERSION:
//          void;
//      case ADD_TASKS_TO_REVIEWABLE_REQUEST:
//          uint32* allTasks;
//      }
//      ext;
//  };

//  ===========================================================================
public struct CreateIssuanceRequestOp: XDREncodable {
  public var request: IssuanceRequest
  public var reference: String64
  public var ext: CreateIssuanceRequestOpExt

  public init(
      request: IssuanceRequest,
      reference: String64,
      ext: CreateIssuanceRequestOpExt) {

    self.request = request
    self.reference = reference
    self.ext = ext
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.request.toXDR())
    xdr.append(self.reference.toXDR())
    xdr.append(self.ext.toXDR())

    return xdr
  }

  public enum CreateIssuanceRequestOpExt: XDRDiscriminatedUnion {
    case emptyVersion()
    case addTasksToReviewableRequest(Uint32?)

    public var discriminant: Int32 {
      switch self {
      case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
      case .addTasksToReviewableRequest: return LedgerVersion.addTasksToReviewableRequest.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .emptyVersion(): xdr.append(Data())
      case .addTasksToReviewableRequest(let data): xdr.append(data.toXDR())
      }

      return xdr
    }

  }
}

// === xdr source ============================================================

//  enum CreateIssuanceRequestResultCode
//  {
//      // codes considered as "success" for the operation
//      SUCCESS = 0,
//  
//      // codes considered as "failure" for the operation
//      ASSET_NOT_FOUND = -1,
//  	INVALID_AMOUNT = -2,
//  	REFERENCE_DUPLICATION = -3,
//  	NO_COUNTERPARTY = -4,
//  	NOT_AUTHORIZED = -5,
//  	EXCEEDS_MAX_ISSUANCE_AMOUNT = -6,
//  	RECEIVER_FULL_LINE = -7,
//  	INVALID_EXTERNAL_DETAILS = -8, // external details size exceeds max allowed
//  	FEE_EXCEEDS_AMOUNT = -9, // fee more than amount to issue
//      REQUIRES_KYC = -10, // asset requires receiver to have KYC
//      REQUIRES_VERIFICATION = -11, //asset requires receiver to be verified
//      ISSUANCE_TASKS_NOT_FOUND = -12, // issuance tasks have not been provided by the source and don't exist in 'KeyValue' table
//      SYSTEM_TASKS_NOT_ALLOWED = -13
//  };

//  ===========================================================================
public enum CreateIssuanceRequestResultCode: Int32, XDREnum {
  case success = 0
  case assetNotFound = -1
  case invalidAmount = -2
  case referenceDuplication = -3
  case noCounterparty = -4
  case notAuthorized = -5
  case exceedsMaxIssuanceAmount = -6
  case receiverFullLine = -7
  case invalidExternalDetails = -8
  case feeExceedsAmount = -9
  case requiresKyc = -10
  case requiresVerification = -11
  case issuanceTasksNotFound = -12
  case systemTasksNotAllowed = -13
}

// === xdr source ============================================================

//  struct CreateIssuanceRequestSuccess {
//  	uint64 requestID;
//  	AccountID receiver;
//  	bool fulfilled;
//  	Fee fee;
//  	union switch (LedgerVersion v)
//  	{
//  	case EMPTY_VERSION:
//  		void;
//  	}
//  	ext;
//  };

//  ===========================================================================
public struct CreateIssuanceRequestSuccess: XDREncodable {
  public var requestID: Uint64
  public var receiver: AccountID
  public var fulfilled: Bool
  public var fee: Fee
  public var ext: CreateIssuanceRequestSuccessExt

  public init(
      requestID: Uint64,
      receiver: AccountID,
      fulfilled: Bool,
      fee: Fee,
      ext: CreateIssuanceRequestSuccessExt) {

    self.requestID = requestID
    self.receiver = receiver
    self.fulfilled = fulfilled
    self.fee = fee
    self.ext = ext
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.requestID.toXDR())
    xdr.append(self.receiver.toXDR())
    xdr.append(self.fulfilled.toXDR())
    xdr.append(self.fee.toXDR())
    xdr.append(self.ext.toXDR())

    return xdr
  }

  public enum CreateIssuanceRequestSuccessExt: XDRDiscriminatedUnion {
    case emptyVersion()

    public var discriminant: Int32 {
      switch self {
      case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .emptyVersion(): xdr.append(Data())
      }

      return xdr
    }

  }
}

// === xdr source ============================================================

//  union CreateIssuanceRequestResult switch (CreateIssuanceRequestResultCode code)
//  {
//  case SUCCESS:
//      CreateIssuanceRequestSuccess success;
//  default:
//      void;
//  };

//  ===========================================================================
public enum CreateIssuanceRequestResult: XDRDiscriminatedUnion {
  case success(CreateIssuanceRequestSuccess)

  public var discriminant: Int32 {
    switch self {
    case .success: return CreateIssuanceRequestResultCode.success.rawValue
    }
  }

  public func toXDR() -> Data {
    var xdr = Data()
          
    xdr.append(self.discriminant.toXDR())
          
    switch self {
    case .success(let data): xdr.append(data.toXDR())
    }

    return xdr
  }
}

// === xdr source ============================================================

//  struct CreateManageLimitsRequestOp
//  {
//      LimitsUpdateRequest manageLimitsRequest;
//  
//  	// reserved for future use
//  	union switch (LedgerVersion v)
//  	{
//  	case EMPTY_VERSION:
//  		void;
//      case ALLOW_TO_UPDATE_AND_REJECT_LIMITS_UPDATE_REQUESTS:
//          uint64 requestID;
//  	}
//  	ext;
//  
//  };

//  ===========================================================================
public struct CreateManageLimitsRequestOp: XDREncodable {
  public var manageLimitsRequest: LimitsUpdateRequest
  public var ext: CreateManageLimitsRequestOpExt

  public init(
      manageLimitsRequest: LimitsUpdateRequest,
      ext: CreateManageLimitsRequestOpExt) {

    self.manageLimitsRequest = manageLimitsRequest
    self.ext = ext
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.manageLimitsRequest.toXDR())
    xdr.append(self.ext.toXDR())

    return xdr
  }

  public enum CreateManageLimitsRequestOpExt: XDRDiscriminatedUnion {
    case emptyVersion()
    case allowToUpdateAndRejectLimitsUpdateRequests(Uint64)

    public var discriminant: Int32 {
      switch self {
      case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
      case .allowToUpdateAndRejectLimitsUpdateRequests: return LedgerVersion.allowToUpdateAndRejectLimitsUpdateRequests.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .emptyVersion(): xdr.append(Data())
      case .allowToUpdateAndRejectLimitsUpdateRequests(let data): xdr.append(data.toXDR())
      }

      return xdr
    }

  }
}

// === xdr source ============================================================

//  enum CreateManageLimitsRequestResultCode
//  {
//      // codes considered as "success" for the operation
//      SUCCESS = 0,
//  
//      // codes considered as "failure" for the operation
//  	MANAGE_LIMITS_REQUEST_REFERENCE_DUPLICATION = -1,
//      MANAGE_LIMITS_REQUEST_NOT_FOUND = -2,
//      INVALID_DETAILS = -3, // details must be valid json
//      INVALID_MANAGE_LIMITS_REQUEST_VERSION = -4 // a version of the request is higher than ledger version
//  };

//  ===========================================================================
public enum CreateManageLimitsRequestResultCode: Int32, XDREnum {
  case success = 0
  case manageLimitsRequestReferenceDuplication = -1
  case manageLimitsRequestNotFound = -2
  case invalidDetails = -3
  case invalidManageLimitsRequestVersion = -4
}

// === xdr source ============================================================

//  union CreateManageLimitsRequestResult switch (CreateManageLimitsRequestResultCode code)
//  {
//  case SUCCESS:
//      struct {
//          uint64 manageLimitsRequestID;
//  		// reserved for future use
//  		union switch (LedgerVersion v)
//  		{
//  		case EMPTY_VERSION:
//  			void;
//  		}
//  		ext;
//  	} success;
//  default:
//      void;
//  };

//  ===========================================================================
public enum CreateManageLimitsRequestResult: XDRDiscriminatedUnion {
  case success(CreateManageLimitsRequestResultSuccess)

  public var discriminant: Int32 {
    switch self {
    case .success: return CreateManageLimitsRequestResultCode.success.rawValue
    }
  }

  public func toXDR() -> Data {
    var xdr = Data()
          
    xdr.append(self.discriminant.toXDR())
          
    switch self {
    case .success(let data): xdr.append(data.toXDR())
    }

    return xdr
  }

  public struct CreateManageLimitsRequestResultSuccess: XDREncodable {
    public var manageLimitsRequestID: Uint64
    public var ext: CreateManageLimitsRequestResultSuccessExt

    public init(
        manageLimitsRequestID: Uint64,
        ext: CreateManageLimitsRequestResultSuccessExt) {

      self.manageLimitsRequestID = manageLimitsRequestID
      self.ext = ext
    }

    public func toXDR() -> Data {
      var xdr = Data()

      xdr.append(self.manageLimitsRequestID.toXDR())
      xdr.append(self.ext.toXDR())

      return xdr
    }

    public enum CreateManageLimitsRequestResultSuccessExt: XDRDiscriminatedUnion {
      case emptyVersion()

      public var discriminant: Int32 {
        switch self {
        case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
        }
      }

      public func toXDR() -> Data {
        var xdr = Data()
              
        xdr.append(self.discriminant.toXDR())
              
        switch self {
        case .emptyVersion(): xdr.append(Data())
        }

        return xdr
      }

    }
  }
}

// === xdr source ============================================================

//  struct CreatePreIssuanceRequestOp
//  {
//      PreIssuanceRequest request;
//  	// reserved for future use
//      union switch (LedgerVersion v)
//      {
//      case EMPTY_VERSION:
//          void;
//      }
//      ext;
//  };

//  ===========================================================================
public struct CreatePreIssuanceRequestOp: XDREncodable {
  public var request: PreIssuanceRequest
  public var ext: CreatePreIssuanceRequestOpExt

  public init(
      request: PreIssuanceRequest,
      ext: CreatePreIssuanceRequestOpExt) {

    self.request = request
    self.ext = ext
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.request.toXDR())
    xdr.append(self.ext.toXDR())

    return xdr
  }

  public enum CreatePreIssuanceRequestOpExt: XDRDiscriminatedUnion {
    case emptyVersion()

    public var discriminant: Int32 {
      switch self {
      case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .emptyVersion(): xdr.append(Data())
      }

      return xdr
    }

  }
}

// === xdr source ============================================================

//  enum CreatePreIssuanceRequestResultCode
//  {
//      // codes considered as "success" for the operation
//      SUCCESS = 0,
//  
//      // codes considered as "failure" for the operation
//      ASSET_NOT_FOUND = -1,
//      REFERENCE_DUPLICATION = -2,    // reference is already used
//      NOT_AUTHORIZED_UPLOAD = -3, // tries to pre issue asset for not owned asset
//      INVALID_SIGNATURE = -4,
//      EXCEEDED_MAX_AMOUNT = -5,
//  	INVALID_AMOUNT = -6,
//  	INVALID_REFERENCE = -7
//  };

//  ===========================================================================
public enum CreatePreIssuanceRequestResultCode: Int32, XDREnum {
  case success = 0
  case assetNotFound = -1
  case referenceDuplication = -2
  case notAuthorizedUpload = -3
  case invalidSignature = -4
  case exceededMaxAmount = -5
  case invalidAmount = -6
  case invalidReference = -7
}

// === xdr source ============================================================

//  union CreatePreIssuanceRequestResult switch (CreatePreIssuanceRequestResultCode code)
//  {
//  case SUCCESS:
//      struct {
//  		uint64 requestID;
//  		bool fulfilled;
//  		// reserved for future use
//  		union switch (LedgerVersion v)
//  		{
//  		case EMPTY_VERSION:
//  			void;
//  		}
//  		ext;
//  	} success;
//  default:
//      void;
//  };

//  ===========================================================================
public enum CreatePreIssuanceRequestResult: XDRDiscriminatedUnion {
  case success(CreatePreIssuanceRequestResultSuccess)

  public var discriminant: Int32 {
    switch self {
    case .success: return CreatePreIssuanceRequestResultCode.success.rawValue
    }
  }

  public func toXDR() -> Data {
    var xdr = Data()
          
    xdr.append(self.discriminant.toXDR())
          
    switch self {
    case .success(let data): xdr.append(data.toXDR())
    }

    return xdr
  }

  public struct CreatePreIssuanceRequestResultSuccess: XDREncodable {
    public var requestID: Uint64
    public var fulfilled: Bool
    public var ext: CreatePreIssuanceRequestResultSuccessExt

    public init(
        requestID: Uint64,
        fulfilled: Bool,
        ext: CreatePreIssuanceRequestResultSuccessExt) {

      self.requestID = requestID
      self.fulfilled = fulfilled
      self.ext = ext
    }

    public func toXDR() -> Data {
      var xdr = Data()

      xdr.append(self.requestID.toXDR())
      xdr.append(self.fulfilled.toXDR())
      xdr.append(self.ext.toXDR())

      return xdr
    }

    public enum CreatePreIssuanceRequestResultSuccessExt: XDRDiscriminatedUnion {
      case emptyVersion()

      public var discriminant: Int32 {
        switch self {
        case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
        }
      }

      public func toXDR() -> Data {
        var xdr = Data()
              
        xdr.append(self.discriminant.toXDR())
              
        switch self {
        case .emptyVersion(): xdr.append(Data())
        }

        return xdr
      }

    }
  }
}

// === xdr source ============================================================

//  struct CreateSaleCreationRequestOp
//  {
//  	uint64 requestID;
//      SaleCreationRequest request;
//  
//  	union switch (LedgerVersion v)
//      {
//      case EMPTY_VERSION:
//          void;
//      }
//      ext;
//  
//  };

//  ===========================================================================
public struct CreateSaleCreationRequestOp: XDREncodable {
  public var requestID: Uint64
  public var request: SaleCreationRequest
  public var ext: CreateSaleCreationRequestOpExt

  public init(
      requestID: Uint64,
      request: SaleCreationRequest,
      ext: CreateSaleCreationRequestOpExt) {

    self.requestID = requestID
    self.request = request
    self.ext = ext
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.requestID.toXDR())
    xdr.append(self.request.toXDR())
    xdr.append(self.ext.toXDR())

    return xdr
  }

  public enum CreateSaleCreationRequestOpExt: XDRDiscriminatedUnion {
    case emptyVersion()

    public var discriminant: Int32 {
      switch self {
      case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .emptyVersion(): xdr.append(Data())
      }

      return xdr
    }

  }
}

// === xdr source ============================================================

//  enum CreateSaleCreationRequestResultCode
//  {
//      // codes considered as "success" for the operation
//      SUCCESS = 0,
//  
//      // codes considered as "failure" for the operation
//  	REQUEST_NOT_FOUND = -1, // trying to update reviewable request which does not exists
//  	BASE_ASSET_OR_ASSET_REQUEST_NOT_FOUND = -2, // failed to find asset or asset request for sale
//  	QUOTE_ASSET_NOT_FOUND = -3, // failed to find quote asset
//  	START_END_INVALID = -4, // sale ends before start
//  	INVALID_END = -5, // end date is in the past
//  	INVALID_PRICE = -6, // price can not be 0
//  	INVALID_CAP = -7, // hard cap is < soft cap
//  	INSUFFICIENT_MAX_ISSUANCE = -8, // max number of tokens is less then number of tokens required for soft cap
//  	INVALID_ASSET_PAIR = -9, // one of the assets has invalid code or base asset is equal to quote asset
//  	REQUEST_OR_SALE_ALREADY_EXISTS = -10,
//  	INSUFFICIENT_PREISSUED = -11, // amount of pre issued tokens is insufficient for hard cap
//  	INVALID_DETAILS = -12, // details must be a valid json
//  	VERSION_IS_NOT_SUPPORTED_YET = -13 // version specified in request is not supported yet
//  };

//  ===========================================================================
public enum CreateSaleCreationRequestResultCode: Int32, XDREnum {
  case success = 0
  case requestNotFound = -1
  case baseAssetOrAssetRequestNotFound = -2
  case quoteAssetNotFound = -3
  case startEndInvalid = -4
  case invalidEnd = -5
  case invalidPrice = -6
  case invalidCap = -7
  case insufficientMaxIssuance = -8
  case invalidAssetPair = -9
  case requestOrSaleAlreadyExists = -10
  case insufficientPreissued = -11
  case invalidDetails = -12
  case versionIsNotSupportedYet = -13
}

// === xdr source ============================================================

//  struct CreateSaleCreationSuccess {
//  	uint64 requestID;
//  
//  	union switch (LedgerVersion v)
//      {
//      case EMPTY_VERSION:
//          void;
//      }
//      ext;
//  };

//  ===========================================================================
public struct CreateSaleCreationSuccess: XDREncodable {
  public var requestID: Uint64
  public var ext: CreateSaleCreationSuccessExt

  public init(
      requestID: Uint64,
      ext: CreateSaleCreationSuccessExt) {

    self.requestID = requestID
    self.ext = ext
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.requestID.toXDR())
    xdr.append(self.ext.toXDR())

    return xdr
  }

  public enum CreateSaleCreationSuccessExt: XDRDiscriminatedUnion {
    case emptyVersion()

    public var discriminant: Int32 {
      switch self {
      case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .emptyVersion(): xdr.append(Data())
      }

      return xdr
    }

  }
}

// === xdr source ============================================================

//  union CreateSaleCreationRequestResult switch (CreateSaleCreationRequestResultCode code)
//  {
//      case SUCCESS:
//          CreateSaleCreationSuccess success;
//      default:
//          void;
//  };

//  ===========================================================================
public enum CreateSaleCreationRequestResult: XDRDiscriminatedUnion {
  case success(CreateSaleCreationSuccess)

  public var discriminant: Int32 {
    switch self {
    case .success: return CreateSaleCreationRequestResultCode.success.rawValue
    }
  }

  public func toXDR() -> Data {
    var xdr = Data()
          
    xdr.append(self.discriminant.toXDR())
          
    switch self {
    case .success(let data): xdr.append(data.toXDR())
    }

    return xdr
  }
}

// === xdr source ============================================================

//  struct CreateWithdrawalRequestOp
//  {
//  	WithdrawalRequest request;
//  
//  	union switch (LedgerVersion v)
//  	{
//  	case EMPTY_VERSION:
//  		void;
//  	}
//  	ext;
//  
//  };

//  ===========================================================================
public struct CreateWithdrawalRequestOp: XDREncodable {
  public var request: WithdrawalRequest
  public var ext: CreateWithdrawalRequestOpExt

  public init(
      request: WithdrawalRequest,
      ext: CreateWithdrawalRequestOpExt) {

    self.request = request
    self.ext = ext
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.request.toXDR())
    xdr.append(self.ext.toXDR())

    return xdr
  }

  public enum CreateWithdrawalRequestOpExt: XDRDiscriminatedUnion {
    case emptyVersion()

    public var discriminant: Int32 {
      switch self {
      case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .emptyVersion(): xdr.append(Data())
      }

      return xdr
    }

  }
}

// === xdr source ============================================================

//  enum CreateWithdrawalRequestResultCode
//  {
//  	// codes considered as "success" for the operation
//  	SUCCESS = 0,
//  
//  	// codes considered as "failure" for the operation
//  	INVALID_AMOUNT = -1, // amount is 0
//  	INVALID_EXTERNAL_DETAILS = -2, // external details size exceeds max allowed
//  	BALANCE_NOT_FOUND = -3, // balance not found
//  	ASSET_IS_NOT_WITHDRAWABLE = -4, // asset is not withdrawable
//  	CONVERSION_PRICE_IS_NOT_AVAILABLE = -5, // failed to find conversion price - conversion is not allowed
//  	FEE_MISMATCHED = -6, // expected fee does not match calculated fee
//  	CONVERSION_OVERFLOW = -7, // overflow during converting source asset to dest asset
//  	CONVERTED_AMOUNT_MISMATCHED = -8, // expected converted amount passed by user, does not match calculated
//  	BALANCE_LOCK_OVERFLOW = -9, // overflow while tried to lock amount
//  	UNDERFUNDED = -10, // insufficient balance to perform operation
//  	INVALID_UNIVERSAL_AMOUNT = -11, // non-zero universal amount
//  	STATS_OVERFLOW = -12, // statistics overflowed by the operation
//  	LIMITS_EXCEEDED = -13, // withdraw exceeds limits for source account
//  	INVALID_PRE_CONFIRMATION_DETAILS = -14, // it's not allowed to pass pre confirmation details
//  	LOWER_BOUND_NOT_EXCEEDED = -15
//  };

//  ===========================================================================
public enum CreateWithdrawalRequestResultCode: Int32, XDREnum {
  case success = 0
  case invalidAmount = -1
  case invalidExternalDetails = -2
  case balanceNotFound = -3
  case assetIsNotWithdrawable = -4
  case conversionPriceIsNotAvailable = -5
  case feeMismatched = -6
  case conversionOverflow = -7
  case convertedAmountMismatched = -8
  case balanceLockOverflow = -9
  case underfunded = -10
  case invalidUniversalAmount = -11
  case statsOverflow = -12
  case limitsExceeded = -13
  case invalidPreConfirmationDetails = -14
  case lowerBoundNotExceeded = -15
}

// === xdr source ============================================================

//  struct CreateWithdrawalSuccess {
//  	uint64 requestID;
//  
//  	union switch (LedgerVersion v)
//  	{
//  	case EMPTY_VERSION:
//  		void;
//  	}
//  	ext;
//  };

//  ===========================================================================
public struct CreateWithdrawalSuccess: XDREncodable {
  public var requestID: Uint64
  public var ext: CreateWithdrawalSuccessExt

  public init(
      requestID: Uint64,
      ext: CreateWithdrawalSuccessExt) {

    self.requestID = requestID
    self.ext = ext
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.requestID.toXDR())
    xdr.append(self.ext.toXDR())

    return xdr
  }

  public enum CreateWithdrawalSuccessExt: XDRDiscriminatedUnion {
    case emptyVersion()

    public var discriminant: Int32 {
      switch self {
      case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .emptyVersion(): xdr.append(Data())
      }

      return xdr
    }

  }
}

// === xdr source ============================================================

//  union CreateWithdrawalRequestResult switch (CreateWithdrawalRequestResultCode code)
//  {
//  	case SUCCESS:
//  		CreateWithdrawalSuccess success;
//  	default:
//  		void;
//  };

//  ===========================================================================
public enum CreateWithdrawalRequestResult: XDRDiscriminatedUnion {
  case success(CreateWithdrawalSuccess)

  public var discriminant: Int32 {
    switch self {
    case .success: return CreateWithdrawalRequestResultCode.success.rawValue
    }
  }

  public func toXDR() -> Data {
    var xdr = Data()
          
    xdr.append(self.discriminant.toXDR())
          
    switch self {
    case .success(let data): xdr.append(data.toXDR())
    }

    return xdr
  }
}

// === xdr source ============================================================

//  struct DirectDebitOp
//  {
//      AccountID from;
//      PaymentOp paymentOp;
//  	 // reserved for future use
//      union switch (LedgerVersion v)
//      {
//      case EMPTY_VERSION:
//          void;
//      }
//      ext;
//  };

//  ===========================================================================
public struct DirectDebitOp: XDREncodable {
  public var from: AccountID
  public var paymentOp: PaymentOp
  public var ext: DirectDebitOpExt

  public init(
      from: AccountID,
      paymentOp: PaymentOp,
      ext: DirectDebitOpExt) {

    self.from = from
    self.paymentOp = paymentOp
    self.ext = ext
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.from.toXDR())
    xdr.append(self.paymentOp.toXDR())
    xdr.append(self.ext.toXDR())

    return xdr
  }

  public enum DirectDebitOpExt: XDRDiscriminatedUnion {
    case emptyVersion()

    public var discriminant: Int32 {
      switch self {
      case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .emptyVersion(): xdr.append(Data())
      }

      return xdr
    }

  }
}

// === xdr source ============================================================

//  enum DirectDebitResultCode
//  {
//      // codes considered as "success" for the operation
//      SUCCESS = 0, // payment successfuly completed
//  
//      // codes considered as "failure" for the operation
//      MALFORMED = -1,       // bad input
//      UNDERFUNDED = -2,     // not enough funds in source account
//      LINE_FULL = -3,       // destination would go above their limit
//  	FEE_MISMATCHED = -4,   // fee is not equal to expected fee
//      BALANCE_NOT_FOUND = -5, // destination balance not found
//      BALANCE_ACCOUNT_MISMATCHED = -6,
//      BALANCE_ASSETS_MISMATCHED = -7,
//  	SRC_BALANCE_NOT_FOUND = -8, // source balance not found
//      REFERENCE_DUPLICATION = -9,
//      STATS_OVERFLOW = -10,
//      LIMITS_EXCEEDED = -11,
//      NOT_ALLOWED_BY_ASSET_POLICY = -12,
//      NO_TRUST = -13
//  };

//  ===========================================================================
public enum DirectDebitResultCode: Int32, XDREnum {
  case success = 0
  case malformed = -1
  case underfunded = -2
  case lineFull = -3
  case feeMismatched = -4
  case balanceNotFound = -5
  case balanceAccountMismatched = -6
  case balanceAssetsMismatched = -7
  case srcBalanceNotFound = -8
  case referenceDuplication = -9
  case statsOverflow = -10
  case limitsExceeded = -11
  case notAllowedByAssetPolicy = -12
  case noTrust = -13
}

// === xdr source ============================================================

//  struct DirectDebitSuccess {
//  	PaymentResponse paymentResponse;
//  	// reserved for future use
//      union switch (LedgerVersion v)
//      {
//      case EMPTY_VERSION:
//          void;
//      }
//      ext;
//  };

//  ===========================================================================
public struct DirectDebitSuccess: XDREncodable {
  public var paymentResponse: PaymentResponse
  public var ext: DirectDebitSuccessExt

  public init(
      paymentResponse: PaymentResponse,
      ext: DirectDebitSuccessExt) {

    self.paymentResponse = paymentResponse
    self.ext = ext
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.paymentResponse.toXDR())
    xdr.append(self.ext.toXDR())

    return xdr
  }

  public enum DirectDebitSuccessExt: XDRDiscriminatedUnion {
    case emptyVersion()

    public var discriminant: Int32 {
      switch self {
      case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .emptyVersion(): xdr.append(Data())
      }

      return xdr
    }

  }
}

// === xdr source ============================================================

//  union DirectDebitResult switch (DirectDebitResultCode code)
//  {
//  case SUCCESS:
//      DirectDebitSuccess success;
//  default:
//      void;
//  };

//  ===========================================================================
public enum DirectDebitResult: XDRDiscriminatedUnion {
  case success(DirectDebitSuccess)

  public var discriminant: Int32 {
    switch self {
    case .success: return DirectDebitResultCode.success.rawValue
    }
  }

  public func toXDR() -> Data {
    var xdr = Data()
          
    xdr.append(self.discriminant.toXDR())
          
    switch self {
    case .success(let data): xdr.append(data.toXDR())
    }

    return xdr
  }
}

// === xdr source ============================================================

//  enum ManageAccountRolePermissionOpAction
//  {
//      CREATE = 0,
//      UPDATE = 1,
//      REMOVE = 2
//  };

//  ===========================================================================
public enum ManageAccountRolePermissionOpAction: Int32, XDREnum {
  case create = 0
  case update = 1
  case remove = 2
}

// === xdr source ============================================================

//  struct CreateAccountRolePermissionData
//  {
//      uint64 roleID;
//      OperationType opType;
//  
//      // reserved for future use
//      union switch (LedgerVersion v)
//      {
//      case EMPTY_VERSION:
//          void;
//      } ext;
//  };

//  ===========================================================================
public struct CreateAccountRolePermissionData: XDREncodable {
  public var roleID: Uint64
  public var opType: OperationType
  public var ext: CreateAccountRolePermissionDataExt

  public init(
      roleID: Uint64,
      opType: OperationType,
      ext: CreateAccountRolePermissionDataExt) {

    self.roleID = roleID
    self.opType = opType
    self.ext = ext
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.roleID.toXDR())
    xdr.append(self.opType.toXDR())
    xdr.append(self.ext.toXDR())

    return xdr
  }

  public enum CreateAccountRolePermissionDataExt: XDRDiscriminatedUnion {
    case emptyVersion()

    public var discriminant: Int32 {
      switch self {
      case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .emptyVersion(): xdr.append(Data())
      }

      return xdr
    }

  }
}

// === xdr source ============================================================

//  struct UpdateAccountRolePermissionData
//  {
//      uint64 permissionID;
//      uint64 roleID;
//      OperationType opType;
//  
//      // reserved for future use
//      union switch (LedgerVersion v)
//      {
//      case EMPTY_VERSION:
//          void;
//      } ext;
//  };

//  ===========================================================================
public struct UpdateAccountRolePermissionData: XDREncodable {
  public var permissionID: Uint64
  public var roleID: Uint64
  public var opType: OperationType
  public var ext: UpdateAccountRolePermissionDataExt

  public init(
      permissionID: Uint64,
      roleID: Uint64,
      opType: OperationType,
      ext: UpdateAccountRolePermissionDataExt) {

    self.permissionID = permissionID
    self.roleID = roleID
    self.opType = opType
    self.ext = ext
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.permissionID.toXDR())
    xdr.append(self.roleID.toXDR())
    xdr.append(self.opType.toXDR())
    xdr.append(self.ext.toXDR())

    return xdr
  }

  public enum UpdateAccountRolePermissionDataExt: XDRDiscriminatedUnion {
    case emptyVersion()

    public var discriminant: Int32 {
      switch self {
      case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .emptyVersion(): xdr.append(Data())
      }

      return xdr
    }

  }
}

// === xdr source ============================================================

//  struct RemoveAccountRolePermissionData
//  {
//      uint64 permissionID;
//  
//      // reserved for future use
//      union switch (LedgerVersion v)
//      {
//      case EMPTY_VERSION:
//          void;
//      } ext;
//  };

//  ===========================================================================
public struct RemoveAccountRolePermissionData: XDREncodable {
  public var permissionID: Uint64
  public var ext: RemoveAccountRolePermissionDataExt

  public init(
      permissionID: Uint64,
      ext: RemoveAccountRolePermissionDataExt) {

    self.permissionID = permissionID
    self.ext = ext
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.permissionID.toXDR())
    xdr.append(self.ext.toXDR())

    return xdr
  }

  public enum RemoveAccountRolePermissionDataExt: XDRDiscriminatedUnion {
    case emptyVersion()

    public var discriminant: Int32 {
      switch self {
      case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .emptyVersion(): xdr.append(Data())
      }

      return xdr
    }

  }
}

// === xdr source ============================================================

//  struct ManageAccountRolePermissionOp
//  {
//      union switch (ManageAccountRolePermissionOpAction action)
//      {
//      case CREATE:
//          CreateAccountRolePermissionData createData;
//      case UPDATE:
//          UpdateAccountRolePermissionData updateData;
//      case REMOVE:
//          RemoveAccountRolePermissionData removeData;
//      } data;
//  
//      // reserved for future use
//      union switch (LedgerVersion v)
//      {
//      case EMPTY_VERSION:
//          void;
//      }
//      ext;
//  };

//  ===========================================================================
public struct ManageAccountRolePermissionOp: XDREncodable {
  public var data: ManageAccountRolePermissionOpData
  public var ext: ManageAccountRolePermissionOpExt

  public init(
      data: ManageAccountRolePermissionOpData,
      ext: ManageAccountRolePermissionOpExt) {

    self.data = data
    self.ext = ext
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.data.toXDR())
    xdr.append(self.ext.toXDR())

    return xdr
  }

  public enum ManageAccountRolePermissionOpData: XDRDiscriminatedUnion {
    case create(CreateAccountRolePermissionData)
    case update(UpdateAccountRolePermissionData)
    case remove(RemoveAccountRolePermissionData)

    public var discriminant: Int32 {
      switch self {
      case .create: return ManageAccountRolePermissionOpAction.create.rawValue
      case .update: return ManageAccountRolePermissionOpAction.update.rawValue
      case .remove: return ManageAccountRolePermissionOpAction.remove.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .create(let data): xdr.append(data.toXDR())
      case .update(let data): xdr.append(data.toXDR())
      case .remove(let data): xdr.append(data.toXDR())
      }

      return xdr
    }

  }
  public enum ManageAccountRolePermissionOpExt: XDRDiscriminatedUnion {
    case emptyVersion()

    public var discriminant: Int32 {
      switch self {
      case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .emptyVersion(): xdr.append(Data())
      }

      return xdr
    }

  }
}

// === xdr source ============================================================

//  enum ManageAccountRolePermissionResultCode
//  {
//      // codes considered as "success" for the operation
//      SUCCESS = 0,
//  
//      // codes considered as "failure" for the operation
//      NOT_FOUND = -1,
//      PERMISSION_ALREADY_EXISTS = -2
//  };

//  ===========================================================================
public enum ManageAccountRolePermissionResultCode: Int32, XDREnum {
  case success = 0
  case notFound = -1
  case permissionAlreadyExists = -2
}

// === xdr source ============================================================

//  union ManageAccountRolePermissionResult switch (ManageAccountRolePermissionResultCode code)
//  {
//      case SUCCESS:
//          struct {
//              uint64 permissionID;
//  
//              // reserved for future use
//              union switch (LedgerVersion v)
//              {
//              case EMPTY_VERSION:
//                  void;
//              }
//              ext;
//          } success;
//      default:
//          void;
//  };

//  ===========================================================================
public enum ManageAccountRolePermissionResult: XDRDiscriminatedUnion {
  case success(ManageAccountRolePermissionResultSuccess)

  public var discriminant: Int32 {
    switch self {
    case .success: return ManageAccountRolePermissionResultCode.success.rawValue
    }
  }

  public func toXDR() -> Data {
    var xdr = Data()
          
    xdr.append(self.discriminant.toXDR())
          
    switch self {
    case .success(let data): xdr.append(data.toXDR())
    }

    return xdr
  }

  public struct ManageAccountRolePermissionResultSuccess: XDREncodable {
    public var permissionID: Uint64
    public var ext: ManageAccountRolePermissionResultSuccessExt

    public init(
        permissionID: Uint64,
        ext: ManageAccountRolePermissionResultSuccessExt) {

      self.permissionID = permissionID
      self.ext = ext
    }

    public func toXDR() -> Data {
      var xdr = Data()

      xdr.append(self.permissionID.toXDR())
      xdr.append(self.ext.toXDR())

      return xdr
    }

    public enum ManageAccountRolePermissionResultSuccessExt: XDRDiscriminatedUnion {
      case emptyVersion()

      public var discriminant: Int32 {
        switch self {
        case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
        }
      }

      public func toXDR() -> Data {
        var xdr = Data()
              
        xdr.append(self.discriminant.toXDR())
              
        switch self {
        case .emptyVersion(): xdr.append(Data())
        }

        return xdr
      }

    }
  }
}

// === xdr source ============================================================

//  enum ManageAccountRoleOpAction
//  {
//      CREATE = 0,
//      REMOVE = 1
//  };

//  ===========================================================================
public enum ManageAccountRoleOpAction: Int32, XDREnum {
  case create = 0
  case remove = 1
}

// === xdr source ============================================================

//  struct CreateAccountRoleData
//  {
//      longstring name;
//  
//      // reserved for future use
//      union switch (LedgerVersion v)
//      {
//      case EMPTY_VERSION:
//          void;
//      } ext;
//  };

//  ===========================================================================
public struct CreateAccountRoleData: XDREncodable {
  public var name: Longstring
  public var ext: CreateAccountRoleDataExt

  public init(
      name: Longstring,
      ext: CreateAccountRoleDataExt) {

    self.name = name
    self.ext = ext
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.name.toXDR())
    xdr.append(self.ext.toXDR())

    return xdr
  }

  public enum CreateAccountRoleDataExt: XDRDiscriminatedUnion {
    case emptyVersion()

    public var discriminant: Int32 {
      switch self {
      case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .emptyVersion(): xdr.append(Data())
      }

      return xdr
    }

  }
}

// === xdr source ============================================================

//  struct RemoveAccountRoleData
//  {
//      uint64 accountRoleID;
//  
//      // reserved for future use
//      union switch (LedgerVersion v)
//      {
//      case EMPTY_VERSION:
//          void;
//      } ext;
//  };

//  ===========================================================================
public struct RemoveAccountRoleData: XDREncodable {
  public var accountRoleID: Uint64
  public var ext: RemoveAccountRoleDataExt

  public init(
      accountRoleID: Uint64,
      ext: RemoveAccountRoleDataExt) {

    self.accountRoleID = accountRoleID
    self.ext = ext
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.accountRoleID.toXDR())
    xdr.append(self.ext.toXDR())

    return xdr
  }

  public enum RemoveAccountRoleDataExt: XDRDiscriminatedUnion {
    case emptyVersion()

    public var discriminant: Int32 {
      switch self {
      case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .emptyVersion(): xdr.append(Data())
      }

      return xdr
    }

  }
}

// === xdr source ============================================================

//  struct ManageAccountRoleOp
//  {
//      union switch (ManageAccountRoleOpAction action)
//      {
//      case CREATE:
//          CreateAccountRoleData createData;
//      case REMOVE:
//          RemoveAccountRoleData removeData;
//      } data;
//  
//      // reserved for future use
//      union switch (LedgerVersion v)
//      {
//      case EMPTY_VERSION:
//          void;
//      }
//      ext;
//  };

//  ===========================================================================
public struct ManageAccountRoleOp: XDREncodable {
  public var data: ManageAccountRoleOpData
  public var ext: ManageAccountRoleOpExt

  public init(
      data: ManageAccountRoleOpData,
      ext: ManageAccountRoleOpExt) {

    self.data = data
    self.ext = ext
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.data.toXDR())
    xdr.append(self.ext.toXDR())

    return xdr
  }

  public enum ManageAccountRoleOpData: XDRDiscriminatedUnion {
    case create(CreateAccountRoleData)
    case remove(RemoveAccountRoleData)

    public var discriminant: Int32 {
      switch self {
      case .create: return ManageAccountRoleOpAction.create.rawValue
      case .remove: return ManageAccountRoleOpAction.remove.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .create(let data): xdr.append(data.toXDR())
      case .remove(let data): xdr.append(data.toXDR())
      }

      return xdr
    }

  }
  public enum ManageAccountRoleOpExt: XDRDiscriminatedUnion {
    case emptyVersion()

    public var discriminant: Int32 {
      switch self {
      case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .emptyVersion(): xdr.append(Data())
      }

      return xdr
    }

  }
}

// === xdr source ============================================================

//  enum ManageAccountRoleResultCode
//  {
//      // codes considered as "success" for the operation
//      SUCCESS = 0,
//  
//      // codes considered as "failure" for the operation
//      NOT_FOUND = -1
//  };

//  ===========================================================================
public enum ManageAccountRoleResultCode: Int32, XDREnum {
  case success = 0
  case notFound = -1
}

// === xdr source ============================================================

//  union ManageAccountRoleResult switch (ManageAccountRoleResultCode code)
//  {
//      case SUCCESS:
//          struct {
//              uint64 accountRoleID;
//  
//              // reserved for future use
//              union switch (LedgerVersion v)
//              {
//              case EMPTY_VERSION:
//                  void;
//              }
//              ext;
//          } success;
//      default:
//          void;
//  };

//  ===========================================================================
public enum ManageAccountRoleResult: XDRDiscriminatedUnion {
  case success(ManageAccountRoleResultSuccess)

  public var discriminant: Int32 {
    switch self {
    case .success: return ManageAccountRoleResultCode.success.rawValue
    }
  }

  public func toXDR() -> Data {
    var xdr = Data()
          
    xdr.append(self.discriminant.toXDR())
          
    switch self {
    case .success(let data): xdr.append(data.toXDR())
    }

    return xdr
  }

  public struct ManageAccountRoleResultSuccess: XDREncodable {
    public var accountRoleID: Uint64
    public var ext: ManageAccountRoleResultSuccessExt

    public init(
        accountRoleID: Uint64,
        ext: ManageAccountRoleResultSuccessExt) {

      self.accountRoleID = accountRoleID
      self.ext = ext
    }

    public func toXDR() -> Data {
      var xdr = Data()

      xdr.append(self.accountRoleID.toXDR())
      xdr.append(self.ext.toXDR())

      return xdr
    }

    public enum ManageAccountRoleResultSuccessExt: XDRDiscriminatedUnion {
      case emptyVersion()

      public var discriminant: Int32 {
        switch self {
        case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
        }
      }

      public func toXDR() -> Data {
        var xdr = Data()
              
        xdr.append(self.discriminant.toXDR())
              
        switch self {
        case .emptyVersion(): xdr.append(Data())
        }

        return xdr
      }

    }
  }
}

// === xdr source ============================================================

//  struct ManageAccountOp
//  {
//      AccountID account; // account to manage
//      AccountType accountType;
//      uint32 blockReasonsToAdd;
//      uint32 blockReasonsToRemove; 
//  	 // reserved for future use
//      union switch (LedgerVersion v)
//      {
//      case EMPTY_VERSION:
//          void;
//      }
//      ext;
//  };

//  ===========================================================================
public struct ManageAccountOp: XDREncodable {
  public var account: AccountID
  public var accountType: AccountType
  public var blockReasonsToAdd: Uint32
  public var blockReasonsToRemove: Uint32
  public var ext: ManageAccountOpExt

  public init(
      account: AccountID,
      accountType: AccountType,
      blockReasonsToAdd: Uint32,
      blockReasonsToRemove: Uint32,
      ext: ManageAccountOpExt) {

    self.account = account
    self.accountType = accountType
    self.blockReasonsToAdd = blockReasonsToAdd
    self.blockReasonsToRemove = blockReasonsToRemove
    self.ext = ext
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.account.toXDR())
    xdr.append(self.accountType.toXDR())
    xdr.append(self.blockReasonsToAdd.toXDR())
    xdr.append(self.blockReasonsToRemove.toXDR())
    xdr.append(self.ext.toXDR())

    return xdr
  }

  public enum ManageAccountOpExt: XDRDiscriminatedUnion {
    case emptyVersion()

    public var discriminant: Int32 {
      switch self {
      case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .emptyVersion(): xdr.append(Data())
      }

      return xdr
    }

  }
}

// === xdr source ============================================================

//  enum ManageAccountResultCode
//  {
//      // codes considered as "success" for the operation
//      SUCCESS = 0, // account was created
//  
//      // codes considered as "failure" for the operation
//      NOT_FOUND = -1,         // account does not exists
//      MALFORMED = -2,
//  	NOT_ALLOWED = -3,         // manage account operation is not allowed on this account
//      TYPE_MISMATCH = -4
//  };

//  ===========================================================================
public enum ManageAccountResultCode: Int32, XDREnum {
  case success = 0
  case notFound = -1
  case malformed = -2
  case notAllowed = -3
  case typeMismatch = -4
}

// === xdr source ============================================================

//  struct ManageAccountSuccess {
//  	uint32 blockReasons;
//   // reserved for future use
//      union switch (LedgerVersion v)
//      {
//      case EMPTY_VERSION:
//          void;
//      }
//      ext;
//  };

//  ===========================================================================
public struct ManageAccountSuccess: XDREncodable {
  public var blockReasons: Uint32
  public var ext: ManageAccountSuccessExt

  public init(
      blockReasons: Uint32,
      ext: ManageAccountSuccessExt) {

    self.blockReasons = blockReasons
    self.ext = ext
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.blockReasons.toXDR())
    xdr.append(self.ext.toXDR())

    return xdr
  }

  public enum ManageAccountSuccessExt: XDRDiscriminatedUnion {
    case emptyVersion()

    public var discriminant: Int32 {
      switch self {
      case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .emptyVersion(): xdr.append(Data())
      }

      return xdr
    }

  }
}

// === xdr source ============================================================

//  union ManageAccountResult switch (ManageAccountResultCode code)
//  {
//  case SUCCESS:
//      ManageAccountSuccess success;
//  default:
//      void;
//  };

//  ===========================================================================
public enum ManageAccountResult: XDRDiscriminatedUnion {
  case success(ManageAccountSuccess)

  public var discriminant: Int32 {
    switch self {
    case .success: return ManageAccountResultCode.success.rawValue
    }
  }

  public func toXDR() -> Data {
    var xdr = Data()
          
    xdr.append(self.discriminant.toXDR())
          
    switch self {
    case .success(let data): xdr.append(data.toXDR())
    }

    return xdr
  }
}

// === xdr source ============================================================

//  enum ManageAssetPairAction
//  {
//      CREATE = 0,
//      UPDATE_PRICE = 1,
//      UPDATE_POLICIES = 2
//  };

//  ===========================================================================
public enum ManageAssetPairAction: Int32, XDREnum {
  case create = 0
  case updatePrice = 1
  case updatePolicies = 2
}

// === xdr source ============================================================

//  struct ManageAssetPairOp
//  {
//      ManageAssetPairAction action;
//  	AssetCode base;
//  	AssetCode quote;
//  
//      int64 physicalPrice;
//  
//  	int64 physicalPriceCorrection; // correction of physical price in percents. If physical price is set and restriction by physical price set, mininal price for offer for this pair will be physicalPrice * physicalPriceCorrection
//  	int64 maxPriceStep;
//  
//  	int32 policies;
//  
//  	 // reserved for future use
//      union switch (LedgerVersion v)
//      {
//      case EMPTY_VERSION:
//          void;
//      }
//      ext;
//  };

//  ===========================================================================
public struct ManageAssetPairOp: XDREncodable {
  public var action: ManageAssetPairAction
  public var base: AssetCode
  public var quote: AssetCode
  public var physicalPrice: Int64
  public var physicalPriceCorrection: Int64
  public var maxPriceStep: Int64
  public var policies: Int32
  public var ext: ManageAssetPairOpExt

  public init(
      action: ManageAssetPairAction,
      base: AssetCode,
      quote: AssetCode,
      physicalPrice: Int64,
      physicalPriceCorrection: Int64,
      maxPriceStep: Int64,
      policies: Int32,
      ext: ManageAssetPairOpExt) {

    self.action = action
    self.base = base
    self.quote = quote
    self.physicalPrice = physicalPrice
    self.physicalPriceCorrection = physicalPriceCorrection
    self.maxPriceStep = maxPriceStep
    self.policies = policies
    self.ext = ext
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.action.toXDR())
    xdr.append(self.base.toXDR())
    xdr.append(self.quote.toXDR())
    xdr.append(self.physicalPrice.toXDR())
    xdr.append(self.physicalPriceCorrection.toXDR())
    xdr.append(self.maxPriceStep.toXDR())
    xdr.append(self.policies.toXDR())
    xdr.append(self.ext.toXDR())

    return xdr
  }

  public enum ManageAssetPairOpExt: XDRDiscriminatedUnion {
    case emptyVersion()

    public var discriminant: Int32 {
      switch self {
      case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .emptyVersion(): xdr.append(Data())
      }

      return xdr
    }

  }
}

// === xdr source ============================================================

//  enum ManageAssetPairResultCode
//  {
//      // codes considered as "success" for the operation
//      SUCCESS = 0,
//  
//      // codes considered as "failure" for the operation
//  	NOT_FOUND = -1,           // failed to find asset with such code
//  	ALREADY_EXISTS = -2,
//      MALFORMED = -3,
//  	INVALID_ASSET = -4,
//  	INVALID_ACTION = -5,
//  	INVALID_POLICIES = -6,
//  	ASSET_NOT_FOUND = -7
//  };

//  ===========================================================================
public enum ManageAssetPairResultCode: Int32, XDREnum {
  case success = 0
  case notFound = -1
  case alreadyExists = -2
  case malformed = -3
  case invalidAsset = -4
  case invalidAction = -5
  case invalidPolicies = -6
  case assetNotFound = -7
}

// === xdr source ============================================================

//  struct ManageAssetPairSuccess
//  {
//  	int64 currentPrice;
//  	// reserved for future use
//      union switch (LedgerVersion v)
//      {
//      case EMPTY_VERSION:
//          void;
//      }
//      ext;
//  };

//  ===========================================================================
public struct ManageAssetPairSuccess: XDREncodable {
  public var currentPrice: Int64
  public var ext: ManageAssetPairSuccessExt

  public init(
      currentPrice: Int64,
      ext: ManageAssetPairSuccessExt) {

    self.currentPrice = currentPrice
    self.ext = ext
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.currentPrice.toXDR())
    xdr.append(self.ext.toXDR())

    return xdr
  }

  public enum ManageAssetPairSuccessExt: XDRDiscriminatedUnion {
    case emptyVersion()

    public var discriminant: Int32 {
      switch self {
      case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .emptyVersion(): xdr.append(Data())
      }

      return xdr
    }

  }
}

// === xdr source ============================================================

//  union ManageAssetPairResult switch (ManageAssetPairResultCode code)
//  {
//  case SUCCESS:
//      ManageAssetPairSuccess success;
//  default:
//      void;
//  };

//  ===========================================================================
public enum ManageAssetPairResult: XDRDiscriminatedUnion {
  case success(ManageAssetPairSuccess)

  public var discriminant: Int32 {
    switch self {
    case .success: return ManageAssetPairResultCode.success.rawValue
    }
  }

  public func toXDR() -> Data {
    var xdr = Data()
          
    xdr.append(self.discriminant.toXDR())
          
    switch self {
    case .success(let data): xdr.append(data.toXDR())
    }

    return xdr
  }
}

// === xdr source ============================================================

//  enum ManageAssetAction
//  {
//      CREATE_ASSET_CREATION_REQUEST = 0,
//      CREATE_ASSET_UPDATE_REQUEST = 1,
//  	CANCEL_ASSET_REQUEST = 2,
//  	CHANGE_PREISSUED_ASSET_SIGNER = 3,
//  	UPDATE_MAX_ISSUANCE = 4
//  };

//  ===========================================================================
public enum ManageAssetAction: Int32, XDREnum {
  case createAssetCreationRequest = 0
  case createAssetUpdateRequest = 1
  case cancelAssetRequest = 2
  case changePreissuedAssetSigner = 3
  case updateMaxIssuance = 4
}

// === xdr source ============================================================

//  struct CancelAssetRequest {
//  
//  	// reserved for future use
//      union switch (LedgerVersion v)
//      {
//      case EMPTY_VERSION:
//          void;
//      }
//      ext;
//  };

//  ===========================================================================
public struct CancelAssetRequest: XDREncodable {
  public var ext: CancelAssetRequestExt

  public init(
      ext: CancelAssetRequestExt) {

    self.ext = ext
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.ext.toXDR())

    return xdr
  }

  public enum CancelAssetRequestExt: XDRDiscriminatedUnion {
    case emptyVersion()

    public var discriminant: Int32 {
      switch self {
      case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .emptyVersion(): xdr.append(Data())
      }

      return xdr
    }

  }
}

// === xdr source ============================================================

//  struct UpdateMaxIssuance {
//  
//  	AssetCode assetCode;
//  	uint64 maxIssuanceAmount;
//  	// reserved for future use
//      union switch (LedgerVersion v)
//      {
//      case EMPTY_VERSION:
//          void;
//      }
//      ext;
//  };

//  ===========================================================================
public struct UpdateMaxIssuance: XDREncodable {
  public var assetCode: AssetCode
  public var maxIssuanceAmount: Uint64
  public var ext: UpdateMaxIssuanceExt

  public init(
      assetCode: AssetCode,
      maxIssuanceAmount: Uint64,
      ext: UpdateMaxIssuanceExt) {

    self.assetCode = assetCode
    self.maxIssuanceAmount = maxIssuanceAmount
    self.ext = ext
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.assetCode.toXDR())
    xdr.append(self.maxIssuanceAmount.toXDR())
    xdr.append(self.ext.toXDR())

    return xdr
  }

  public enum UpdateMaxIssuanceExt: XDRDiscriminatedUnion {
    case emptyVersion()

    public var discriminant: Int32 {
      switch self {
      case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .emptyVersion(): xdr.append(Data())
      }

      return xdr
    }

  }
}

// === xdr source ============================================================

//  struct ManageAssetOp
//  {
//  	uint64 requestID; // 0 to create, non zero will try to update
//      union switch (ManageAssetAction action)
//  	{
//  	case CREATE_ASSET_CREATION_REQUEST:
//  		AssetCreationRequest createAsset;
//  	case CREATE_ASSET_UPDATE_REQUEST:
//  		AssetUpdateRequest updateAsset;
//  	case CANCEL_ASSET_REQUEST:
//  		CancelAssetRequest cancelRequest;
//  	case CHANGE_PREISSUED_ASSET_SIGNER:
//  		AssetChangePreissuedSigner changePreissuedSigner;
//      case UPDATE_MAX_ISSUANCE:
//          UpdateMaxIssuance updateMaxIssuance;
//  	} request;
//  
//  	// reserved for future use
//      union switch (LedgerVersion v)
//      {
//      case EMPTY_VERSION:
//          void;
//      }
//      ext;
//  };

//  ===========================================================================
public struct ManageAssetOp: XDREncodable {
  public var requestID: Uint64
  public var request: ManageAssetOpRequest
  public var ext: ManageAssetOpExt

  public init(
      requestID: Uint64,
      request: ManageAssetOpRequest,
      ext: ManageAssetOpExt) {

    self.requestID = requestID
    self.request = request
    self.ext = ext
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.requestID.toXDR())
    xdr.append(self.request.toXDR())
    xdr.append(self.ext.toXDR())

    return xdr
  }

  public enum ManageAssetOpRequest: XDRDiscriminatedUnion {
    case createAssetCreationRequest(AssetCreationRequest)
    case createAssetUpdateRequest(AssetUpdateRequest)
    case cancelAssetRequest(CancelAssetRequest)
    case changePreissuedAssetSigner(AssetChangePreissuedSigner)
    case updateMaxIssuance(UpdateMaxIssuance)

    public var discriminant: Int32 {
      switch self {
      case .createAssetCreationRequest: return ManageAssetAction.createAssetCreationRequest.rawValue
      case .createAssetUpdateRequest: return ManageAssetAction.createAssetUpdateRequest.rawValue
      case .cancelAssetRequest: return ManageAssetAction.cancelAssetRequest.rawValue
      case .changePreissuedAssetSigner: return ManageAssetAction.changePreissuedAssetSigner.rawValue
      case .updateMaxIssuance: return ManageAssetAction.updateMaxIssuance.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .createAssetCreationRequest(let data): xdr.append(data.toXDR())
      case .createAssetUpdateRequest(let data): xdr.append(data.toXDR())
      case .cancelAssetRequest(let data): xdr.append(data.toXDR())
      case .changePreissuedAssetSigner(let data): xdr.append(data.toXDR())
      case .updateMaxIssuance(let data): xdr.append(data.toXDR())
      }

      return xdr
    }

  }
  public enum ManageAssetOpExt: XDRDiscriminatedUnion {
    case emptyVersion()

    public var discriminant: Int32 {
      switch self {
      case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .emptyVersion(): xdr.append(Data())
      }

      return xdr
    }

  }
}

// === xdr source ============================================================

//  enum ManageAssetResultCode
//  {
//      // codes considered as "success" for the operation
//      SUCCESS = 0,                       // request was successfully created/updated/canceled
//  
//      // codes considered as "failure" for the operation
//  	REQUEST_NOT_FOUND = -1,           // failed to find asset request with such id
//  	ASSET_ALREADY_EXISTS = -3,			   // asset with such code already exist
//      INVALID_MAX_ISSUANCE_AMOUNT = -4, // max issuance amount is 0
//  	INVALID_CODE = -5,                // asset code is invalid (empty or contains space)
//  	INVALID_POLICIES = -7,            // asset policies (has flag which does not belong to AssetPolicies enum)
//  	ASSET_NOT_FOUND = -8,             // asset does not exists
//  	REQUEST_ALREADY_EXISTS = -9,      // request for creation of unique entry already exists
//  	STATS_ASSET_ALREADY_EXISTS = -10, // statistics quote asset already exists
//  	INITIAL_PREISSUED_EXCEEDS_MAX_ISSUANCE = -11, // initial pre issued amount exceeds max issuance amount
//  	INVALID_DETAILS = -12 // details must be a valid json
//  };

//  ===========================================================================
public enum ManageAssetResultCode: Int32, XDREnum {
  case success = 0
  case requestNotFound = -1
  case assetAlreadyExists = -3
  case invalidMaxIssuanceAmount = -4
  case invalidCode = -5
  case invalidPolicies = -7
  case assetNotFound = -8
  case requestAlreadyExists = -9
  case statsAssetAlreadyExists = -10
  case initialPreissuedExceedsMaxIssuance = -11
  case invalidDetails = -12
}

// === xdr source ============================================================

//  struct ManageAssetSuccess
//  {
//  	uint64 requestID;
//  	bool fulfilled;
//      // reserved for future use
//      union switch (LedgerVersion v)
//      {
//      case EMPTY_VERSION:
//          void;
//      }
//      ext;
//  };

//  ===========================================================================
public struct ManageAssetSuccess: XDREncodable {
  public var requestID: Uint64
  public var fulfilled: Bool
  public var ext: ManageAssetSuccessExt

  public init(
      requestID: Uint64,
      fulfilled: Bool,
      ext: ManageAssetSuccessExt) {

    self.requestID = requestID
    self.fulfilled = fulfilled
    self.ext = ext
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.requestID.toXDR())
    xdr.append(self.fulfilled.toXDR())
    xdr.append(self.ext.toXDR())

    return xdr
  }

  public enum ManageAssetSuccessExt: XDRDiscriminatedUnion {
    case emptyVersion()

    public var discriminant: Int32 {
      switch self {
      case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .emptyVersion(): xdr.append(Data())
      }

      return xdr
    }

  }
}

// === xdr source ============================================================

//  union ManageAssetResult switch (ManageAssetResultCode code)
//  {
//  case SUCCESS:
//      ManageAssetSuccess success;
//  default:
//      void;
//  };

//  ===========================================================================
public enum ManageAssetResult: XDRDiscriminatedUnion {
  case success(ManageAssetSuccess)

  public var discriminant: Int32 {
    switch self {
    case .success: return ManageAssetResultCode.success.rawValue
    }
  }

  public func toXDR() -> Data {
    var xdr = Data()
          
    xdr.append(self.discriminant.toXDR())
          
    switch self {
    case .success(let data): xdr.append(data.toXDR())
    }

    return xdr
  }
}

// === xdr source ============================================================

//  enum ManageBalanceAction
//  {
//      CREATE = 0,
//      DELETE_BALANCE = 1,
//  	CREATE_UNIQUE = 2 // ensures that balance will not be created if one for such asset and account exists
//  };

//  ===========================================================================
public enum ManageBalanceAction: Int32, XDREnum {
  case create = 0
  case deleteBalance = 1
  case createUnique = 2
}

// === xdr source ============================================================

//  struct ManageBalanceOp
//  {
//      ManageBalanceAction action;
//      AccountID destination;
//      AssetCode asset;
//  	union switch (LedgerVersion v)
//      {
//      case EMPTY_VERSION:
//          void;
//      }
//      ext;
//  };

//  ===========================================================================
public struct ManageBalanceOp: XDREncodable {
  public var action: ManageBalanceAction
  public var destination: AccountID
  public var asset: AssetCode
  public var ext: ManageBalanceOpExt

  public init(
      action: ManageBalanceAction,
      destination: AccountID,
      asset: AssetCode,
      ext: ManageBalanceOpExt) {

    self.action = action
    self.destination = destination
    self.asset = asset
    self.ext = ext
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.action.toXDR())
    xdr.append(self.destination.toXDR())
    xdr.append(self.asset.toXDR())
    xdr.append(self.ext.toXDR())

    return xdr
  }

  public enum ManageBalanceOpExt: XDRDiscriminatedUnion {
    case emptyVersion()

    public var discriminant: Int32 {
      switch self {
      case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .emptyVersion(): xdr.append(Data())
      }

      return xdr
    }

  }
}

// === xdr source ============================================================

//  enum ManageBalanceResultCode
//  {
//      // codes considered as "success" for the operation
//      SUCCESS = 0,
//  
//      // codes considered as "failure" for the operation
//      MALFORMED = -1,       // invalid destination
//      NOT_FOUND = -2,
//      DESTINATION_NOT_FOUND = -3,
//      ASSET_NOT_FOUND = -4,
//      INVALID_ASSET = -5,
//  	BALANCE_ALREADY_EXISTS = -6,
//  	VERSION_IS_NOT_SUPPORTED_YET = -7 // version specified in request is not supported yet
//  };

//  ===========================================================================
public enum ManageBalanceResultCode: Int32, XDREnum {
  case success = 0
  case malformed = -1
  case notFound = -2
  case destinationNotFound = -3
  case assetNotFound = -4
  case invalidAsset = -5
  case balanceAlreadyExists = -6
  case versionIsNotSupportedYet = -7
}

// === xdr source ============================================================

//  struct ManageBalanceSuccess {
//  	BalanceID balanceID;
//  	// reserved for future use
//      union switch (LedgerVersion v)
//      {
//      case EMPTY_VERSION:
//          void;
//      }
//      ext;
//  };

//  ===========================================================================
public struct ManageBalanceSuccess: XDREncodable {
  public var balanceID: BalanceID
  public var ext: ManageBalanceSuccessExt

  public init(
      balanceID: BalanceID,
      ext: ManageBalanceSuccessExt) {

    self.balanceID = balanceID
    self.ext = ext
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.balanceID.toXDR())
    xdr.append(self.ext.toXDR())

    return xdr
  }

  public enum ManageBalanceSuccessExt: XDRDiscriminatedUnion {
    case emptyVersion()

    public var discriminant: Int32 {
      switch self {
      case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .emptyVersion(): xdr.append(Data())
      }

      return xdr
    }

  }
}

// === xdr source ============================================================

//  union ManageBalanceResult switch (ManageBalanceResultCode code)
//  {
//  case SUCCESS:
//      ManageBalanceSuccess success;
//  default:
//      void;
//  };

//  ===========================================================================
public enum ManageBalanceResult: XDRDiscriminatedUnion {
  case success(ManageBalanceSuccess)

  public var discriminant: Int32 {
    switch self {
    case .success: return ManageBalanceResultCode.success.rawValue
    }
  }

  public func toXDR() -> Data {
    var xdr = Data()
          
    xdr.append(self.discriminant.toXDR())
          
    switch self {
    case .success(let data): xdr.append(data.toXDR())
    }

    return xdr
  }
}

// === xdr source ============================================================

//  enum ManageContractRequestAction
//  {
//      CREATE = 0,
//      REMOVE = 1
//  };

//  ===========================================================================
public enum ManageContractRequestAction: Int32, XDREnum {
  case create = 0
  case remove = 1
}

// === xdr source ============================================================

//  struct ManageContractRequestOp
//  {
//      union switch (ManageContractRequestAction action){
//      case CREATE:
//          ContractRequest contractRequest;
//      case REMOVE:
//          uint64 requestID;
//      } details;
//  
//  	// reserved for future use
//      union switch (LedgerVersion v)
//      {
//      case EMPTY_VERSION:
//          void;
//      }
//      ext;
//  };

//  ===========================================================================
public struct ManageContractRequestOp: XDREncodable {
  public var details: ManageContractRequestOpDetails
  public var ext: ManageContractRequestOpExt

  public init(
      details: ManageContractRequestOpDetails,
      ext: ManageContractRequestOpExt) {

    self.details = details
    self.ext = ext
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.details.toXDR())
    xdr.append(self.ext.toXDR())

    return xdr
  }

  public enum ManageContractRequestOpDetails: XDRDiscriminatedUnion {
    case create(ContractRequest)
    case remove(Uint64)

    public var discriminant: Int32 {
      switch self {
      case .create: return ManageContractRequestAction.create.rawValue
      case .remove: return ManageContractRequestAction.remove.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .create(let data): xdr.append(data.toXDR())
      case .remove(let data): xdr.append(data.toXDR())
      }

      return xdr
    }

  }
  public enum ManageContractRequestOpExt: XDRDiscriminatedUnion {
    case emptyVersion()

    public var discriminant: Int32 {
      switch self {
      case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .emptyVersion(): xdr.append(Data())
      }

      return xdr
    }

  }
}

// === xdr source ============================================================

//  enum ManageContractRequestResultCode
//  {
//      // codes considered as "success" for the operation
//      SUCCESS = 0,
//  
//      // codes considered as "failure" for the operation
//      MALFORMED = -1,
//      NOT_FOUND = -2, // not found contract request, when try to remove
//      TOO_MANY_CONTRACTS = -3,
//      NOT_ALLOWED_TO_REMOVE = -4, // only contract creator can remove contract
//      DETAILS_TOO_LONG = -5
//  };

//  ===========================================================================
public enum ManageContractRequestResultCode: Int32, XDREnum {
  case success = 0
  case malformed = -1
  case notFound = -2
  case tooManyContracts = -3
  case notAllowedToRemove = -4
  case detailsTooLong = -5
}

// === xdr source ============================================================

//  struct CreateContractRequestResponse
//  {
//  	uint64 requestID;
//  
//  	union switch (LedgerVersion v)
//      {
//      case EMPTY_VERSION:
//          void;
//      }
//      ext;
//  };

//  ===========================================================================
public struct CreateContractRequestResponse: XDREncodable {
  public var requestID: Uint64
  public var ext: CreateContractRequestResponseExt

  public init(
      requestID: Uint64,
      ext: CreateContractRequestResponseExt) {

    self.requestID = requestID
    self.ext = ext
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.requestID.toXDR())
    xdr.append(self.ext.toXDR())

    return xdr
  }

  public enum CreateContractRequestResponseExt: XDRDiscriminatedUnion {
    case emptyVersion()

    public var discriminant: Int32 {
      switch self {
      case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .emptyVersion(): xdr.append(Data())
      }

      return xdr
    }

  }
}

// === xdr source ============================================================

//  union ManageContractRequestResult switch (ManageContractRequestResultCode code)
//  {
//  case SUCCESS:
//      struct
//      {
//          union switch (ManageContractRequestAction action)
//          {
//          case CREATE:
//              CreateContractRequestResponse response;
//          case REMOVE:
//              void;
//          } details;
//  
//          // reserved for future use
//          union switch (LedgerVersion v)
//          {
//          case EMPTY_VERSION:
//              void;
//          } ext;
//      } success;
//  default:
//      void;
//  };

//  ===========================================================================
public enum ManageContractRequestResult: XDRDiscriminatedUnion {
  case success(ManageContractRequestResultSuccess)

  public var discriminant: Int32 {
    switch self {
    case .success: return ManageContractRequestResultCode.success.rawValue
    }
  }

  public func toXDR() -> Data {
    var xdr = Data()
          
    xdr.append(self.discriminant.toXDR())
          
    switch self {
    case .success(let data): xdr.append(data.toXDR())
    }

    return xdr
  }

  public struct ManageContractRequestResultSuccess: XDREncodable {
    public var details: ManageContractRequestResultSuccessDetails
    public var ext: ManageContractRequestResultSuccessExt

    public init(
        details: ManageContractRequestResultSuccessDetails,
        ext: ManageContractRequestResultSuccessExt) {

      self.details = details
      self.ext = ext
    }

    public func toXDR() -> Data {
      var xdr = Data()

      xdr.append(self.details.toXDR())
      xdr.append(self.ext.toXDR())

      return xdr
    }

    public enum ManageContractRequestResultSuccessDetails: XDRDiscriminatedUnion {
      case create(CreateContractRequestResponse)
      case remove()

      public var discriminant: Int32 {
        switch self {
        case .create: return ManageContractRequestAction.create.rawValue
        case .remove: return ManageContractRequestAction.remove.rawValue
        }
      }

      public func toXDR() -> Data {
        var xdr = Data()
              
        xdr.append(self.discriminant.toXDR())
              
        switch self {
        case .create(let data): xdr.append(data.toXDR())
        case .remove(): xdr.append(Data())
        }

        return xdr
      }

    }
    public enum ManageContractRequestResultSuccessExt: XDRDiscriminatedUnion {
      case emptyVersion()

      public var discriminant: Int32 {
        switch self {
        case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
        }
      }

      public func toXDR() -> Data {
        var xdr = Data()
              
        xdr.append(self.discriminant.toXDR())
              
        switch self {
        case .emptyVersion(): xdr.append(Data())
        }

        return xdr
      }

    }
  }
}

// === xdr source ============================================================

//  enum ManageContractAction
//  {
//      ADD_DETAILS = 0,
//      CONFIRM_COMPLETED = 1,
//      START_DISPUTE = 2,
//      RESOLVE_DISPUTE = 3
//  };

//  ===========================================================================
public enum ManageContractAction: Int32, XDREnum {
  case addDetails = 0
  case confirmCompleted = 1
  case startDispute = 2
  case resolveDispute = 3
}

// === xdr source ============================================================

//  struct ManageContractOp
//  {
//      uint64 contractID;
//  
//      union switch (ManageContractAction action)
//      {
//      case ADD_DETAILS:
//          longstring details;
//      case CONFIRM_COMPLETED:
//          void;
//      case START_DISPUTE:
//          longstring disputeReason;
//      case RESOLVE_DISPUTE:
//          bool isRevert;
//      }
//      data;
//  
//  	// reserved for future use
//      union switch (LedgerVersion v)
//      {
//      case EMPTY_VERSION:
//          void;
//      }
//      ext;
//  };

//  ===========================================================================
public struct ManageContractOp: XDREncodable {
  public var contractID: Uint64
  public var data: ManageContractOpData
  public var ext: ManageContractOpExt

  public init(
      contractID: Uint64,
      data: ManageContractOpData,
      ext: ManageContractOpExt) {

    self.contractID = contractID
    self.data = data
    self.ext = ext
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.contractID.toXDR())
    xdr.append(self.data.toXDR())
    xdr.append(self.ext.toXDR())

    return xdr
  }

  public enum ManageContractOpData: XDRDiscriminatedUnion {
    case addDetails(Longstring)
    case confirmCompleted()
    case startDispute(Longstring)
    case resolveDispute(Bool)

    public var discriminant: Int32 {
      switch self {
      case .addDetails: return ManageContractAction.addDetails.rawValue
      case .confirmCompleted: return ManageContractAction.confirmCompleted.rawValue
      case .startDispute: return ManageContractAction.startDispute.rawValue
      case .resolveDispute: return ManageContractAction.resolveDispute.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .addDetails(let data): xdr.append(data.toXDR())
      case .confirmCompleted(): xdr.append(Data())
      case .startDispute(let data): xdr.append(data.toXDR())
      case .resolveDispute(let data): xdr.append(data.toXDR())
      }

      return xdr
    }

  }
  public enum ManageContractOpExt: XDRDiscriminatedUnion {
    case emptyVersion()

    public var discriminant: Int32 {
      switch self {
      case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .emptyVersion(): xdr.append(Data())
      }

      return xdr
    }

  }
}

// === xdr source ============================================================

//  enum ManageContractResultCode
//  {
//      // codes considered as "success" for the operation
//      SUCCESS = 0,
//  
//      // codes considered as "failure" for the operation
//      MALFORMED = -1,
//      NOT_FOUND = -2, // not found contract
//      NOT_ALLOWED = -3, // only contractor or customer can add details
//      DETAILS_TOO_LONG = -4,
//      DISPUTE_REASON_TOO_LONG = -5,
//      ALREADY_CONFIRMED = -6,
//      INVOICE_NOT_APPROVED = -7, // all contract invoices must be approved
//      DISPUTE_ALREADY_STARTED = -8,
//      CUSTOMER_BALANCE_OVERFLOW = -9
//  };

//  ===========================================================================
public enum ManageContractResultCode: Int32, XDREnum {
  case success = 0
  case malformed = -1
  case notFound = -2
  case notAllowed = -3
  case detailsTooLong = -4
  case disputeReasonTooLong = -5
  case alreadyConfirmed = -6
  case invoiceNotApproved = -7
  case disputeAlreadyStarted = -8
  case customerBalanceOverflow = -9
}

// === xdr source ============================================================

//  struct ManageContractResponse
//  {
//      union switch (ManageContractAction action)
//      {
//      case CONFIRM_COMPLETED:
//          bool isCompleted;
//      default:
//          void;
//      }
//      data;
//  
//      // reserved for future use
//      union switch (LedgerVersion v)
//      {
//      case EMPTY_VERSION:
//          void;
//      }
//      ext;
//  };

//  ===========================================================================
public struct ManageContractResponse: XDREncodable {
  public var data: ManageContractResponseData
  public var ext: ManageContractResponseExt

  public init(
      data: ManageContractResponseData,
      ext: ManageContractResponseExt) {

    self.data = data
    self.ext = ext
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.data.toXDR())
    xdr.append(self.ext.toXDR())

    return xdr
  }

  public enum ManageContractResponseData: XDRDiscriminatedUnion {
    case confirmCompleted(Bool)

    public var discriminant: Int32 {
      switch self {
      case .confirmCompleted: return ManageContractAction.confirmCompleted.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .confirmCompleted(let data): xdr.append(data.toXDR())
      }

      return xdr
    }

  }
  public enum ManageContractResponseExt: XDRDiscriminatedUnion {
    case emptyVersion()

    public var discriminant: Int32 {
      switch self {
      case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .emptyVersion(): xdr.append(Data())
      }

      return xdr
    }

  }
}

// === xdr source ============================================================

//  union ManageContractResult switch (ManageContractResultCode code)
//  {
//  case SUCCESS:
//      ManageContractResponse response;
//  default:
//      void;
//  };

//  ===========================================================================
public enum ManageContractResult: XDRDiscriminatedUnion {
  case success(ManageContractResponse)

  public var discriminant: Int32 {
    switch self {
    case .success: return ManageContractResultCode.success.rawValue
    }
  }

  public func toXDR() -> Data {
    var xdr = Data()
          
    xdr.append(self.discriminant.toXDR())
          
    switch self {
    case .success(let data): xdr.append(data.toXDR())
    }

    return xdr
  }
}

// === xdr source ============================================================

//  enum ManageExternalSystemAccountIdPoolEntryAction
//  {
//      CREATE = 0,
//      REMOVE = 1
//  };

//  ===========================================================================
public enum ManageExternalSystemAccountIdPoolEntryAction: Int32, XDREnum {
  case create = 0
  case remove = 1
}

// === xdr source ============================================================

//  struct CreateExternalSystemAccountIdPoolEntryActionInput
//  {
//      int32 externalSystemType;
//      longstring data;
//      uint64 parent;
//  
//      union switch (LedgerVersion v)
//      {
//      case EMPTY_VERSION:
//          void;
//      }
//      ext;
//  };

//  ===========================================================================
public struct CreateExternalSystemAccountIdPoolEntryActionInput: XDREncodable {
  public var externalSystemType: Int32
  public var data: Longstring
  public var parent: Uint64
  public var ext: CreateExternalSystemAccountIdPoolEntryActionInputExt

  public init(
      externalSystemType: Int32,
      data: Longstring,
      parent: Uint64,
      ext: CreateExternalSystemAccountIdPoolEntryActionInputExt) {

    self.externalSystemType = externalSystemType
    self.data = data
    self.parent = parent
    self.ext = ext
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.externalSystemType.toXDR())
    xdr.append(self.data.toXDR())
    xdr.append(self.parent.toXDR())
    xdr.append(self.ext.toXDR())

    return xdr
  }

  public enum CreateExternalSystemAccountIdPoolEntryActionInputExt: XDRDiscriminatedUnion {
    case emptyVersion()

    public var discriminant: Int32 {
      switch self {
      case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .emptyVersion(): xdr.append(Data())
      }

      return xdr
    }

  }
}

// === xdr source ============================================================

//  struct DeleteExternalSystemAccountIdPoolEntryActionInput
//  {
//      uint64 poolEntryID;
//  
//      union switch (LedgerVersion v)
//      {
//      case EMPTY_VERSION:
//          void;
//      }
//      ext;
//  };

//  ===========================================================================
public struct DeleteExternalSystemAccountIdPoolEntryActionInput: XDREncodable {
  public var poolEntryID: Uint64
  public var ext: DeleteExternalSystemAccountIdPoolEntryActionInputExt

  public init(
      poolEntryID: Uint64,
      ext: DeleteExternalSystemAccountIdPoolEntryActionInputExt) {

    self.poolEntryID = poolEntryID
    self.ext = ext
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.poolEntryID.toXDR())
    xdr.append(self.ext.toXDR())

    return xdr
  }

  public enum DeleteExternalSystemAccountIdPoolEntryActionInputExt: XDRDiscriminatedUnion {
    case emptyVersion()

    public var discriminant: Int32 {
      switch self {
      case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .emptyVersion(): xdr.append(Data())
      }

      return xdr
    }

  }
}

// === xdr source ============================================================

//  struct ManageExternalSystemAccountIdPoolEntryOp
//  {
//      union switch (ManageExternalSystemAccountIdPoolEntryAction action)
//      {
//      case CREATE:
//          CreateExternalSystemAccountIdPoolEntryActionInput createExternalSystemAccountIdPoolEntryActionInput;
//      case REMOVE:
//          DeleteExternalSystemAccountIdPoolEntryActionInput deleteExternalSystemAccountIdPoolEntryActionInput;
//      } actionInput;
//  
//      union switch (LedgerVersion v)
//      {
//      case EMPTY_VERSION:
//          void;
//      }
//      ext;
//  };

//  ===========================================================================
public struct ManageExternalSystemAccountIdPoolEntryOp: XDREncodable {
  public var actionInput: ManageExternalSystemAccountIdPoolEntryOpActionInput
  public var ext: ManageExternalSystemAccountIdPoolEntryOpExt

  public init(
      actionInput: ManageExternalSystemAccountIdPoolEntryOpActionInput,
      ext: ManageExternalSystemAccountIdPoolEntryOpExt) {

    self.actionInput = actionInput
    self.ext = ext
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.actionInput.toXDR())
    xdr.append(self.ext.toXDR())

    return xdr
  }

  public enum ManageExternalSystemAccountIdPoolEntryOpActionInput: XDRDiscriminatedUnion {
    case create(CreateExternalSystemAccountIdPoolEntryActionInput)
    case remove(DeleteExternalSystemAccountIdPoolEntryActionInput)

    public var discriminant: Int32 {
      switch self {
      case .create: return ManageExternalSystemAccountIdPoolEntryAction.create.rawValue
      case .remove: return ManageExternalSystemAccountIdPoolEntryAction.remove.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .create(let data): xdr.append(data.toXDR())
      case .remove(let data): xdr.append(data.toXDR())
      }

      return xdr
    }

  }
  public enum ManageExternalSystemAccountIdPoolEntryOpExt: XDRDiscriminatedUnion {
    case emptyVersion()

    public var discriminant: Int32 {
      switch self {
      case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .emptyVersion(): xdr.append(Data())
      }

      return xdr
    }

  }
}

// === xdr source ============================================================

//  enum ManageExternalSystemAccountIdPoolEntryResultCode
//  {
//      // codes considered as "success" for the operation
//      SUCCESS = 0,
//  
//      // codes considered as "failure" for the operation
//      MALFORMED = -1,
//      ALREADY_EXISTS = -2,
//      AUTO_GENERATED_TYPE_NOT_ALLOWED = -3,
//      NOT_FOUND = -4
//  };

//  ===========================================================================
public enum ManageExternalSystemAccountIdPoolEntryResultCode: Int32, XDREnum {
  case success = 0
  case malformed = -1
  case alreadyExists = -2
  case autoGeneratedTypeNotAllowed = -3
  case notFound = -4
}

// === xdr source ============================================================

//  struct ManageExternalSystemAccountIdPoolEntrySuccess {
//  	uint64 poolEntryID;
//  	// reserved for future use
//      union switch (LedgerVersion v)
//      {
//      case EMPTY_VERSION:
//          void;
//      }
//      ext;
//  };

//  ===========================================================================
public struct ManageExternalSystemAccountIdPoolEntrySuccess: XDREncodable {
  public var poolEntryID: Uint64
  public var ext: ManageExternalSystemAccountIdPoolEntrySuccessExt

  public init(
      poolEntryID: Uint64,
      ext: ManageExternalSystemAccountIdPoolEntrySuccessExt) {

    self.poolEntryID = poolEntryID
    self.ext = ext
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.poolEntryID.toXDR())
    xdr.append(self.ext.toXDR())

    return xdr
  }

  public enum ManageExternalSystemAccountIdPoolEntrySuccessExt: XDRDiscriminatedUnion {
    case emptyVersion()

    public var discriminant: Int32 {
      switch self {
      case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .emptyVersion(): xdr.append(Data())
      }

      return xdr
    }

  }
}

// === xdr source ============================================================

//  union ManageExternalSystemAccountIdPoolEntryResult switch (ManageExternalSystemAccountIdPoolEntryResultCode code)
//  {
//  case SUCCESS:
//      ManageExternalSystemAccountIdPoolEntrySuccess success;
//  default:
//      void;
//  };

//  ===========================================================================
public enum ManageExternalSystemAccountIdPoolEntryResult: XDRDiscriminatedUnion {
  case success(ManageExternalSystemAccountIdPoolEntrySuccess)

  public var discriminant: Int32 {
    switch self {
    case .success: return ManageExternalSystemAccountIdPoolEntryResultCode.success.rawValue
    }
  }

  public func toXDR() -> Data {
    var xdr = Data()
          
    xdr.append(self.discriminant.toXDR())
          
    switch self {
    case .success(let data): xdr.append(data.toXDR())
    }

    return xdr
  }
}

// === xdr source ============================================================

//  enum ManageInvoiceRequestAction
//  {
//      CREATE = 0,
//      REMOVE = 1
//  };

//  ===========================================================================
public enum ManageInvoiceRequestAction: Int32, XDREnum {
  case create = 0
  case remove = 1
}

// === xdr source ============================================================

//  struct InvoiceCreationRequest
//  {
//      AssetCode asset;
//      AccountID sender;
//      uint64 amount; // not allowed to set 0
//  
//      uint64 *contractID;
//      longstring details;
//  
//      // reserved for future use
//      union switch (LedgerVersion v)
//      {
//      case EMPTY_VERSION:
//          void;
//      }
//      ext;
//  };

//  ===========================================================================
public struct InvoiceCreationRequest: XDREncodable {
  public var asset: AssetCode
  public var sender: AccountID
  public var amount: Uint64
  public var contractID: Uint64?
  public var details: Longstring
  public var ext: InvoiceCreationRequestExt

  public init(
      asset: AssetCode,
      sender: AccountID,
      amount: Uint64,
      contractID: Uint64?,
      details: Longstring,
      ext: InvoiceCreationRequestExt) {

    self.asset = asset
    self.sender = sender
    self.amount = amount
    self.contractID = contractID
    self.details = details
    self.ext = ext
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.asset.toXDR())
    xdr.append(self.sender.toXDR())
    xdr.append(self.amount.toXDR())
    xdr.append(self.contractID.toXDR())
    xdr.append(self.details.toXDR())
    xdr.append(self.ext.toXDR())

    return xdr
  }

  public enum InvoiceCreationRequestExt: XDRDiscriminatedUnion {
    case emptyVersion()

    public var discriminant: Int32 {
      switch self {
      case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .emptyVersion(): xdr.append(Data())
      }

      return xdr
    }

  }
}

// === xdr source ============================================================

//  struct ManageInvoiceRequestOp
//  {
//      union switch (ManageInvoiceRequestAction action){
//      case CREATE:
//          InvoiceCreationRequest invoiceRequest;
//      case REMOVE:
//          uint64 requestID;
//      } details;
//  
//  	// reserved for future use
//      union switch (LedgerVersion v)
//      {
//      case EMPTY_VERSION:
//          void;
//      }
//      ext;
//  };

//  ===========================================================================
public struct ManageInvoiceRequestOp: XDREncodable {
  public var details: ManageInvoiceRequestOpDetails
  public var ext: ManageInvoiceRequestOpExt

  public init(
      details: ManageInvoiceRequestOpDetails,
      ext: ManageInvoiceRequestOpExt) {

    self.details = details
    self.ext = ext
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.details.toXDR())
    xdr.append(self.ext.toXDR())

    return xdr
  }

  public enum ManageInvoiceRequestOpDetails: XDRDiscriminatedUnion {
    case create(InvoiceCreationRequest)
    case remove(Uint64)

    public var discriminant: Int32 {
      switch self {
      case .create: return ManageInvoiceRequestAction.create.rawValue
      case .remove: return ManageInvoiceRequestAction.remove.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .create(let data): xdr.append(data.toXDR())
      case .remove(let data): xdr.append(data.toXDR())
      }

      return xdr
    }

  }
  public enum ManageInvoiceRequestOpExt: XDRDiscriminatedUnion {
    case emptyVersion()

    public var discriminant: Int32 {
      switch self {
      case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .emptyVersion(): xdr.append(Data())
      }

      return xdr
    }

  }
}

// === xdr source ============================================================

//  enum ManageInvoiceRequestResultCode
//  {
//      // codes considered as "success" for the operation
//      SUCCESS = 0,
//  
//      // codes considered as "failure" for the operation
//      MALFORMED = -1,
//      BALANCE_NOT_FOUND = -2, // sender balance not found
//      NOT_FOUND = -3, // not found invoice request, when try to remove
//      TOO_MANY_INVOICES = -4,
//      DETAILS_TOO_LONG = -5,
//      NOT_ALLOWED_TO_REMOVE = -6, // only invoice creator can remove invoice
//      CONTRACT_NOT_FOUND = -7,
//      ONLY_CONTRACTOR_CAN_ATTACH_INVOICE_TO_CONTRACT = -8,
//      SENDER_ACCOUNT_MISMATCHED = -9,
//      INVOICE_IS_APPROVED = -10 // not allowed to remove approved invoice
//  };

//  ===========================================================================
public enum ManageInvoiceRequestResultCode: Int32, XDREnum {
  case success = 0
  case malformed = -1
  case balanceNotFound = -2
  case notFound = -3
  case tooManyInvoices = -4
  case detailsTooLong = -5
  case notAllowedToRemove = -6
  case contractNotFound = -7
  case onlyContractorCanAttachInvoiceToContract = -8
  case senderAccountMismatched = -9
  case invoiceIsApproved = -10
}

// === xdr source ============================================================

//  struct CreateInvoiceRequestResponse
//  {
//  	BalanceID receiverBalance;
//  	BalanceID senderBalance;
//  
//  	uint64 requestID;
//  
//  	union switch (LedgerVersion v)
//      {
//      case EMPTY_VERSION:
//          void;
//      }
//      ext;
//  };

//  ===========================================================================
public struct CreateInvoiceRequestResponse: XDREncodable {
  public var receiverBalance: BalanceID
  public var senderBalance: BalanceID
  public var requestID: Uint64
  public var ext: CreateInvoiceRequestResponseExt

  public init(
      receiverBalance: BalanceID,
      senderBalance: BalanceID,
      requestID: Uint64,
      ext: CreateInvoiceRequestResponseExt) {

    self.receiverBalance = receiverBalance
    self.senderBalance = senderBalance
    self.requestID = requestID
    self.ext = ext
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.receiverBalance.toXDR())
    xdr.append(self.senderBalance.toXDR())
    xdr.append(self.requestID.toXDR())
    xdr.append(self.ext.toXDR())

    return xdr
  }

  public enum CreateInvoiceRequestResponseExt: XDRDiscriminatedUnion {
    case emptyVersion()

    public var discriminant: Int32 {
      switch self {
      case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .emptyVersion(): xdr.append(Data())
      }

      return xdr
    }

  }
}

// === xdr source ============================================================

//  union ManageInvoiceRequestResult switch (ManageInvoiceRequestResultCode code)
//  {
//  case SUCCESS:
//      struct
//      {
//          union switch (ManageInvoiceRequestAction action)
//          {
//          case CREATE:
//              CreateInvoiceRequestResponse response;
//          case REMOVE:
//              void;
//          } details;
//  
//          // reserved for future use
//          union switch (LedgerVersion v)
//          {
//          case EMPTY_VERSION:
//              void;
//          } ext;
//      } success;
//  default:
//      void;
//  };

//  ===========================================================================
public enum ManageInvoiceRequestResult: XDRDiscriminatedUnion {
  case success(ManageInvoiceRequestResultSuccess)

  public var discriminant: Int32 {
    switch self {
    case .success: return ManageInvoiceRequestResultCode.success.rawValue
    }
  }

  public func toXDR() -> Data {
    var xdr = Data()
          
    xdr.append(self.discriminant.toXDR())
          
    switch self {
    case .success(let data): xdr.append(data.toXDR())
    }

    return xdr
  }

  public struct ManageInvoiceRequestResultSuccess: XDREncodable {
    public var details: ManageInvoiceRequestResultSuccessDetails
    public var ext: ManageInvoiceRequestResultSuccessExt

    public init(
        details: ManageInvoiceRequestResultSuccessDetails,
        ext: ManageInvoiceRequestResultSuccessExt) {

      self.details = details
      self.ext = ext
    }

    public func toXDR() -> Data {
      var xdr = Data()

      xdr.append(self.details.toXDR())
      xdr.append(self.ext.toXDR())

      return xdr
    }

    public enum ManageInvoiceRequestResultSuccessDetails: XDRDiscriminatedUnion {
      case create(CreateInvoiceRequestResponse)
      case remove()

      public var discriminant: Int32 {
        switch self {
        case .create: return ManageInvoiceRequestAction.create.rawValue
        case .remove: return ManageInvoiceRequestAction.remove.rawValue
        }
      }

      public func toXDR() -> Data {
        var xdr = Data()
              
        xdr.append(self.discriminant.toXDR())
              
        switch self {
        case .create(let data): xdr.append(data.toXDR())
        case .remove(): xdr.append(Data())
        }

        return xdr
      }

    }
    public enum ManageInvoiceRequestResultSuccessExt: XDRDiscriminatedUnion {
      case emptyVersion()

      public var discriminant: Int32 {
        switch self {
        case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
        }
      }

      public func toXDR() -> Data {
        var xdr = Data()
              
        xdr.append(self.discriminant.toXDR())
              
        switch self {
        case .emptyVersion(): xdr.append(Data())
        }

        return xdr
      }

    }
  }
}

// === xdr source ============================================================

//  enum ManageKVAction
//      {
//          PUT = 1,
//          REMOVE = 2
//      };

//  ===========================================================================
public enum ManageKVAction: Int32, XDREnum {
  case put = 1
  case remove = 2
}

// === xdr source ============================================================

//  struct ManageKeyValueOp
//      {
//          string256 key;
//          union switch(ManageKVAction action)
//          {
//              case PUT:
//                  KeyValueEntry value;
//              case REMOVE:
//                  void;
//          }
//          action;
//  
//          // reserved for future use
//          union switch (LedgerVersion v)
//          {
//          case EMPTY_VERSION:
//              void;
//          }
//          ext;
//      };

//  ===========================================================================
public struct ManageKeyValueOp: XDREncodable {
  public var key: String256
  public var action: ManageKeyValueOpAction
  public var ext: ManageKeyValueOpExt

  public init(
      key: String256,
      action: ManageKeyValueOpAction,
      ext: ManageKeyValueOpExt) {

    self.key = key
    self.action = action
    self.ext = ext
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.key.toXDR())
    xdr.append(self.action.toXDR())
    xdr.append(self.ext.toXDR())

    return xdr
  }

  public enum ManageKeyValueOpAction: XDRDiscriminatedUnion {
    case put(KeyValueEntry)
    case remove()

    public var discriminant: Int32 {
      switch self {
      case .put: return ManageKVAction.put.rawValue
      case .remove: return ManageKVAction.remove.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .put(let data): xdr.append(data.toXDR())
      case .remove(): xdr.append(Data())
      }

      return xdr
    }

  }
  public enum ManageKeyValueOpExt: XDRDiscriminatedUnion {
    case emptyVersion()

    public var discriminant: Int32 {
      switch self {
      case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .emptyVersion(): xdr.append(Data())
      }

      return xdr
    }

  }
}

// === xdr source ============================================================

//  struct ManageKeyValueSuccess
//      {
//          // reserved for future use
//          union switch (LedgerVersion v)
//          {
//              case EMPTY_VERSION:
//                  void;
//          }
//          ext;
//      };

//  ===========================================================================
public struct ManageKeyValueSuccess: XDREncodable {
  public var ext: ManageKeyValueSuccessExt

  public init(
      ext: ManageKeyValueSuccessExt) {

    self.ext = ext
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.ext.toXDR())

    return xdr
  }

  public enum ManageKeyValueSuccessExt: XDRDiscriminatedUnion {
    case emptyVersion()

    public var discriminant: Int32 {
      switch self {
      case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .emptyVersion(): xdr.append(Data())
      }

      return xdr
    }

  }
}

// === xdr source ============================================================

//  enum ManageKeyValueResultCode
//      {
//          SUCCESS = 1,
//          NOT_FOUND = -1,
//          INVALID_TYPE = -2
//      };

//  ===========================================================================
public enum ManageKeyValueResultCode: Int32, XDREnum {
  case success = 1
  case notFound = -1
  case invalidType = -2
}

// === xdr source ============================================================

//  union ManageKeyValueResult switch (ManageKeyValueResultCode code)
//      {
//          case SUCCESS:
//              ManageKeyValueSuccess success;
//          default:
//              void;
//      };

//  ===========================================================================
public enum ManageKeyValueResult: XDRDiscriminatedUnion {
  case success(ManageKeyValueSuccess)

  public var discriminant: Int32 {
    switch self {
    case .success: return ManageKeyValueResultCode.success.rawValue
    }
  }

  public func toXDR() -> Data {
    var xdr = Data()
          
    xdr.append(self.discriminant.toXDR())
          
    switch self {
    case .success(let data): xdr.append(data.toXDR())
    }

    return xdr
  }
}

// === xdr source ============================================================

//  enum ManageLimitsAction
//  {
//      CREATE = 0,
//      REMOVE = 1
//  };

//  ===========================================================================
public enum ManageLimitsAction: Int32, XDREnum {
  case create = 0
  case remove = 1
}

// === xdr source ============================================================

//  struct LimitsCreateDetails
//  {
//      AccountType *accountType;
//      AccountID   *accountID;
//      StatsOpType statsOpType;
//      AssetCode   assetCode;
//      bool        isConvertNeeded;
//  
//      uint64 dailyOut;
//      uint64 weeklyOut;
//      uint64 monthlyOut;
//      uint64 annualOut;
//  };

//  ===========================================================================
public struct LimitsCreateDetails: XDREncodable {
  public var accountType: AccountType?
  public var accountID: AccountID?
  public var statsOpType: StatsOpType
  public var assetCode: AssetCode
  public var isConvertNeeded: Bool
  public var dailyOut: Uint64
  public var weeklyOut: Uint64
  public var monthlyOut: Uint64
  public var annualOut: Uint64

  public init(
      accountType: AccountType?,
      accountID: AccountID?,
      statsOpType: StatsOpType,
      assetCode: AssetCode,
      isConvertNeeded: Bool,
      dailyOut: Uint64,
      weeklyOut: Uint64,
      monthlyOut: Uint64,
      annualOut: Uint64) {

    self.accountType = accountType
    self.accountID = accountID
    self.statsOpType = statsOpType
    self.assetCode = assetCode
    self.isConvertNeeded = isConvertNeeded
    self.dailyOut = dailyOut
    self.weeklyOut = weeklyOut
    self.monthlyOut = monthlyOut
    self.annualOut = annualOut
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.accountType.toXDR())
    xdr.append(self.accountID.toXDR())
    xdr.append(self.statsOpType.toXDR())
    xdr.append(self.assetCode.toXDR())
    xdr.append(self.isConvertNeeded.toXDR())
    xdr.append(self.dailyOut.toXDR())
    xdr.append(self.weeklyOut.toXDR())
    xdr.append(self.monthlyOut.toXDR())
    xdr.append(self.annualOut.toXDR())

    return xdr
  }
}

// === xdr source ============================================================

//  struct ManageLimitsOp
//  {
//      union switch (ManageLimitsAction action)
//      {
//      case CREATE:
//          LimitsCreateDetails limitsCreateDetails;
//      case REMOVE:
//          uint64 id;
//      } details;
//  
//       // reserved for future use
//      union switch (LedgerVersion v)
//      {
//      case EMPTY_VERSION:
//          void;
//      }
//      ext;
//  };

//  ===========================================================================
public struct ManageLimitsOp: XDREncodable {
  public var details: ManageLimitsOpDetails
  public var ext: ManageLimitsOpExt

  public init(
      details: ManageLimitsOpDetails,
      ext: ManageLimitsOpExt) {

    self.details = details
    self.ext = ext
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.details.toXDR())
    xdr.append(self.ext.toXDR())

    return xdr
  }

  public enum ManageLimitsOpDetails: XDRDiscriminatedUnion {
    case create(LimitsCreateDetails)
    case remove(Uint64)

    public var discriminant: Int32 {
      switch self {
      case .create: return ManageLimitsAction.create.rawValue
      case .remove: return ManageLimitsAction.remove.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .create(let data): xdr.append(data.toXDR())
      case .remove(let data): xdr.append(data.toXDR())
      }

      return xdr
    }

  }
  public enum ManageLimitsOpExt: XDRDiscriminatedUnion {
    case emptyVersion()

    public var discriminant: Int32 {
      switch self {
      case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .emptyVersion(): xdr.append(Data())
      }

      return xdr
    }

  }
}

// === xdr source ============================================================

//  enum ManageLimitsResultCode
//  {
//      // codes considered as "success" for the operation
//      SUCCESS = 0,
//  
//      // codes considered as "failure" for the operation
//      MALFORMED = -1,
//      NOT_FOUND = -2,
//      ALREADY_EXISTS = -3,
//      CANNOT_CREATE_FOR_ACC_ID_AND_ACC_TYPE = -4, // limits cannot be created for account ID and account type simultaneously
//      INVALID_LIMITS = -5
//  };

//  ===========================================================================
public enum ManageLimitsResultCode: Int32, XDREnum {
  case success = 0
  case malformed = -1
  case notFound = -2
  case alreadyExists = -3
  case cannotCreateForAccIdAndAccType = -4
  case invalidLimits = -5
}

// === xdr source ============================================================

//  union ManageLimitsResult switch (ManageLimitsResultCode code)
//  {
//  case SUCCESS:
//      struct {
//          union switch (ManageLimitsAction action)
//          {
//          case CREATE:
//              uint64 id;
//          case REMOVE:
//              void;
//          } details;
//  
//  		// reserved for future use
//  		union switch (LedgerVersion v)
//  		{
//  		case EMPTY_VERSION:
//  			void;
//  		}
//  		ext;
//  	} success;
//  default:
//      void;
//  };

//  ===========================================================================
public enum ManageLimitsResult: XDRDiscriminatedUnion {
  case success(ManageLimitsResultSuccess)

  public var discriminant: Int32 {
    switch self {
    case .success: return ManageLimitsResultCode.success.rawValue
    }
  }

  public func toXDR() -> Data {
    var xdr = Data()
          
    xdr.append(self.discriminant.toXDR())
          
    switch self {
    case .success(let data): xdr.append(data.toXDR())
    }

    return xdr
  }

  public struct ManageLimitsResultSuccess: XDREncodable {
    public var details: ManageLimitsResultSuccessDetails
    public var ext: ManageLimitsResultSuccessExt

    public init(
        details: ManageLimitsResultSuccessDetails,
        ext: ManageLimitsResultSuccessExt) {

      self.details = details
      self.ext = ext
    }

    public func toXDR() -> Data {
      var xdr = Data()

      xdr.append(self.details.toXDR())
      xdr.append(self.ext.toXDR())

      return xdr
    }

    public enum ManageLimitsResultSuccessDetails: XDRDiscriminatedUnion {
      case create(Uint64)
      case remove()

      public var discriminant: Int32 {
        switch self {
        case .create: return ManageLimitsAction.create.rawValue
        case .remove: return ManageLimitsAction.remove.rawValue
        }
      }

      public func toXDR() -> Data {
        var xdr = Data()
              
        xdr.append(self.discriminant.toXDR())
              
        switch self {
        case .create(let data): xdr.append(data.toXDR())
        case .remove(): xdr.append(Data())
        }

        return xdr
      }

    }
    public enum ManageLimitsResultSuccessExt: XDRDiscriminatedUnion {
      case emptyVersion()

      public var discriminant: Int32 {
        switch self {
        case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
        }
      }

      public func toXDR() -> Data {
        var xdr = Data()
              
        xdr.append(self.discriminant.toXDR())
              
        switch self {
        case .emptyVersion(): xdr.append(Data())
        }

        return xdr
      }

    }
  }
}

// === xdr source ============================================================

//  struct ManageOfferOp
//  {
//      BalanceID baseBalance; // balance for base asset
//  	BalanceID quoteBalance; // balance for quote asset
//  	bool isBuy;
//      int64 amount; // if set to 0, delete the offer
//      int64 price;  // price of base asset in terms of quote
//  
//      int64 fee;
//  
//      // 0=create a new offer, otherwise edit an existing offer
//      uint64 offerID;
//  	uint64 orderBookID;
//  	// reserved for future use
//      union switch (LedgerVersion v)
//      {
//      case EMPTY_VERSION:
//          void;
//      }
//      ext;
//  };

//  ===========================================================================
public struct ManageOfferOp: XDREncodable {
  public var baseBalance: BalanceID
  public var quoteBalance: BalanceID
  public var isBuy: Bool
  public var amount: Int64
  public var price: Int64
  public var fee: Int64
  public var offerID: Uint64
  public var orderBookID: Uint64
  public var ext: ManageOfferOpExt

  public init(
      baseBalance: BalanceID,
      quoteBalance: BalanceID,
      isBuy: Bool,
      amount: Int64,
      price: Int64,
      fee: Int64,
      offerID: Uint64,
      orderBookID: Uint64,
      ext: ManageOfferOpExt) {

    self.baseBalance = baseBalance
    self.quoteBalance = quoteBalance
    self.isBuy = isBuy
    self.amount = amount
    self.price = price
    self.fee = fee
    self.offerID = offerID
    self.orderBookID = orderBookID
    self.ext = ext
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.baseBalance.toXDR())
    xdr.append(self.quoteBalance.toXDR())
    xdr.append(self.isBuy.toXDR())
    xdr.append(self.amount.toXDR())
    xdr.append(self.price.toXDR())
    xdr.append(self.fee.toXDR())
    xdr.append(self.offerID.toXDR())
    xdr.append(self.orderBookID.toXDR())
    xdr.append(self.ext.toXDR())

    return xdr
  }

  public enum ManageOfferOpExt: XDRDiscriminatedUnion {
    case emptyVersion()

    public var discriminant: Int32 {
      switch self {
      case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .emptyVersion(): xdr.append(Data())
      }

      return xdr
    }

  }
}

// === xdr source ============================================================

//  enum ManageOfferResultCode
//  {
//      // codes considered as "success" for the operation
//      SUCCESS = 0,
//  
//      // codes considered as "failure" for the operation
//      MALFORMED = -1,     // generated offer would be invalid
//      PAIR_NOT_TRADED = -2, // it's not allowed to trage with this pair
//      BALANCE_NOT_FOUND = -3,  // does not own balance for buying or selling
//      UNDERFUNDED = -4,    // doesn't hold what it's trying to sell
//      CROSS_SELF = -5,     // would cross an offer from the same user
//  	OFFER_OVERFLOW = -6,
//  	ASSET_PAIR_NOT_TRADABLE = -7,
//  	PHYSICAL_PRICE_RESTRICTION = -8, // offer price violates physical price restriction
//  	CURRENT_PRICE_RESTRICTION = -9,
//      NOT_FOUND = -10, // offerID does not match an existing offer
//      INVALID_PERCENT_FEE = -11,
//  	INSUFFICIENT_PRICE = -12,
//  	ORDER_BOOK_DOES_NOT_EXISTS = -13, // specified order book does not exists
//  	SALE_IS_NOT_STARTED_YET = -14, // sale is not started yet
//  	SALE_ALREADY_ENDED = -15, // sale has already ended
//  	ORDER_VIOLATES_HARD_CAP = -16, // currentcap + order will exceed hard cap
//  	CANT_PARTICIPATE_OWN_SALE = -17, // it's not allowed to participate in own sale
//  	ASSET_MISMATCHED = -18, // sale assets does not match assets for specified balances
//  	PRICE_DOES_NOT_MATCH = -19, // price does not match sale price
//  	PRICE_IS_INVALID = -20, // price must be positive
//  	UPDATE_IS_NOT_ALLOWED = -21, // update of the offer is not allowed
//  	INVALID_AMOUNT = -22, // amount must be positive 
//  	SALE_IS_NOT_ACTIVE = -23,
//  	REQUIRES_KYC = -24, // source must have KYC in order to participate
//  	SOURCE_UNDERFUNDED = -25,
//  	SOURCE_BALANCE_LOCK_OVERFLOW = -26,
//  	REQUIRES_VERIFICATION = -27 // source must be verified in order to participate
//  };

//  ===========================================================================
public enum ManageOfferResultCode: Int32, XDREnum {
  case success = 0
  case malformed = -1
  case pairNotTraded = -2
  case balanceNotFound = -3
  case underfunded = -4
  case crossSelf = -5
  case offerOverflow = -6
  case assetPairNotTradable = -7
  case physicalPriceRestriction = -8
  case currentPriceRestriction = -9
  case notFound = -10
  case invalidPercentFee = -11
  case insufficientPrice = -12
  case orderBookDoesNotExists = -13
  case saleIsNotStartedYet = -14
  case saleAlreadyEnded = -15
  case orderViolatesHardCap = -16
  case cantParticipateOwnSale = -17
  case assetMismatched = -18
  case priceDoesNotMatch = -19
  case priceIsInvalid = -20
  case updateIsNotAllowed = -21
  case invalidAmount = -22
  case saleIsNotActive = -23
  case requiresKyc = -24
  case sourceUnderfunded = -25
  case sourceBalanceLockOverflow = -26
  case requiresVerification = -27
}

// === xdr source ============================================================

//  enum ManageOfferEffect
//  {
//      CREATED = 0,
//      UPDATED = 1,
//      DELETED = 2
//  };

//  ===========================================================================
public enum ManageOfferEffect: Int32, XDREnum {
  case created = 0
  case updated = 1
  case deleted = 2
}

// === xdr source ============================================================

//  struct ClaimOfferAtom
//  {
//      // emitted to identify the offer
//      AccountID bAccountID; // Account that owns the offer
//      uint64 offerID;
//  	int64 baseAmount;
//  	int64 quoteAmount;
//  	int64 bFeePaid;
//  	int64 aFeePaid;
//  	BalanceID baseBalance;
//  	BalanceID quoteBalance;
//  
//  	int64 currentPrice;
//  
//  	union switch (LedgerVersion v)
//      {
//      case EMPTY_VERSION:
//          void;
//      }
//      ext;
//  };

//  ===========================================================================
public struct ClaimOfferAtom: XDREncodable {
  public var bAccountID: AccountID
  public var offerID: Uint64
  public var baseAmount: Int64
  public var quoteAmount: Int64
  public var bFeePaid: Int64
  public var aFeePaid: Int64
  public var baseBalance: BalanceID
  public var quoteBalance: BalanceID
  public var currentPrice: Int64
  public var ext: ClaimOfferAtomExt

  public init(
      bAccountID: AccountID,
      offerID: Uint64,
      baseAmount: Int64,
      quoteAmount: Int64,
      bFeePaid: Int64,
      aFeePaid: Int64,
      baseBalance: BalanceID,
      quoteBalance: BalanceID,
      currentPrice: Int64,
      ext: ClaimOfferAtomExt) {

    self.bAccountID = bAccountID
    self.offerID = offerID
    self.baseAmount = baseAmount
    self.quoteAmount = quoteAmount
    self.bFeePaid = bFeePaid
    self.aFeePaid = aFeePaid
    self.baseBalance = baseBalance
    self.quoteBalance = quoteBalance
    self.currentPrice = currentPrice
    self.ext = ext
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.bAccountID.toXDR())
    xdr.append(self.offerID.toXDR())
    xdr.append(self.baseAmount.toXDR())
    xdr.append(self.quoteAmount.toXDR())
    xdr.append(self.bFeePaid.toXDR())
    xdr.append(self.aFeePaid.toXDR())
    xdr.append(self.baseBalance.toXDR())
    xdr.append(self.quoteBalance.toXDR())
    xdr.append(self.currentPrice.toXDR())
    xdr.append(self.ext.toXDR())

    return xdr
  }

  public enum ClaimOfferAtomExt: XDRDiscriminatedUnion {
    case emptyVersion()

    public var discriminant: Int32 {
      switch self {
      case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .emptyVersion(): xdr.append(Data())
      }

      return xdr
    }

  }
}

// === xdr source ============================================================

//  struct ManageOfferSuccessResult
//  {
//  
//      // offers that got claimed while creating this offer
//      ClaimOfferAtom offersClaimed<>;
//  	AssetCode baseAsset;
//  	AssetCode quoteAsset;
//  
//      union switch (ManageOfferEffect effect)
//      {
//      case CREATED:
//      case UPDATED:
//          OfferEntry offer;
//      default:
//          void;
//      }
//      offer;
//  
//  	union switch (LedgerVersion v)
//      {
//      case EMPTY_VERSION:
//          void;
//      }
//      ext;
//  };

//  ===========================================================================
public struct ManageOfferSuccessResult: XDREncodable {
  public var offersClaimed: [ClaimOfferAtom]
  public var baseAsset: AssetCode
  public var quoteAsset: AssetCode
  public var offer: ManageOfferSuccessResultOffer
  public var ext: ManageOfferSuccessResultExt

  public init(
      offersClaimed: [ClaimOfferAtom],
      baseAsset: AssetCode,
      quoteAsset: AssetCode,
      offer: ManageOfferSuccessResultOffer,
      ext: ManageOfferSuccessResultExt) {

    self.offersClaimed = offersClaimed
    self.baseAsset = baseAsset
    self.quoteAsset = quoteAsset
    self.offer = offer
    self.ext = ext
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.offersClaimed.toXDR())
    xdr.append(self.baseAsset.toXDR())
    xdr.append(self.quoteAsset.toXDR())
    xdr.append(self.offer.toXDR())
    xdr.append(self.ext.toXDR())

    return xdr
  }

  public enum ManageOfferSuccessResultOffer: XDRDiscriminatedUnion {
    case created(OfferEntry)
    case updated(OfferEntry)

    public var discriminant: Int32 {
      switch self {
      case .created: return ManageOfferEffect.created.rawValue
      case .updated: return ManageOfferEffect.updated.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .created(let data): xdr.append(data.toXDR())
      case .updated(let data): xdr.append(data.toXDR())
      }

      return xdr
    }

  }
  public enum ManageOfferSuccessResultExt: XDRDiscriminatedUnion {
    case emptyVersion()

    public var discriminant: Int32 {
      switch self {
      case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .emptyVersion(): xdr.append(Data())
      }

      return xdr
    }

  }
}

// === xdr source ============================================================

//  union ManageOfferResult switch (ManageOfferResultCode code)
//  {
//  case SUCCESS:
//      ManageOfferSuccessResult success;
//  case PHYSICAL_PRICE_RESTRICTION:
//  	struct {
//  		int64 physicalPrice;
//  		union switch (LedgerVersion v)
//  		{
//  		case EMPTY_VERSION:
//  			void;
//  		}
//  		ext;
//  	} physicalPriceRestriction;
//  case CURRENT_PRICE_RESTRICTION:
//  	struct {
//  		int64 currentPrice;
//  		union switch (LedgerVersion v)
//  		{
//  		case EMPTY_VERSION:
//  			void;
//  		}
//  		ext;
//  	} currentPriceRestriction;
//  
//  default:
//      void;
//  };

//  ===========================================================================
public enum ManageOfferResult: XDRDiscriminatedUnion {
  case success(ManageOfferSuccessResult)
  case physicalPriceRestriction(ManageOfferResultPhysicalPriceRestriction)
  case currentPriceRestriction(ManageOfferResultCurrentPriceRestriction)

  public var discriminant: Int32 {
    switch self {
    case .success: return ManageOfferResultCode.success.rawValue
    case .physicalPriceRestriction: return ManageOfferResultCode.physicalPriceRestriction.rawValue
    case .currentPriceRestriction: return ManageOfferResultCode.currentPriceRestriction.rawValue
    }
  }

  public func toXDR() -> Data {
    var xdr = Data()
          
    xdr.append(self.discriminant.toXDR())
          
    switch self {
    case .success(let data): xdr.append(data.toXDR())
    case .physicalPriceRestriction(let data): xdr.append(data.toXDR())
    case .currentPriceRestriction(let data): xdr.append(data.toXDR())
    }

    return xdr
  }

  public struct ManageOfferResultPhysicalPriceRestriction: XDREncodable {
    public var physicalPrice: Int64
    public var ext: ManageOfferResultPhysicalPriceRestrictionExt

    public init(
        physicalPrice: Int64,
        ext: ManageOfferResultPhysicalPriceRestrictionExt) {

      self.physicalPrice = physicalPrice
      self.ext = ext
    }

    public func toXDR() -> Data {
      var xdr = Data()

      xdr.append(self.physicalPrice.toXDR())
      xdr.append(self.ext.toXDR())

      return xdr
    }

    public enum ManageOfferResultPhysicalPriceRestrictionExt: XDRDiscriminatedUnion {
      case emptyVersion()

      public var discriminant: Int32 {
        switch self {
        case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
        }
      }

      public func toXDR() -> Data {
        var xdr = Data()
              
        xdr.append(self.discriminant.toXDR())
              
        switch self {
        case .emptyVersion(): xdr.append(Data())
        }

        return xdr
      }

    }
  }
  public struct ManageOfferResultCurrentPriceRestriction: XDREncodable {
    public var currentPrice: Int64
    public var ext: ManageOfferResultCurrentPriceRestrictionExt

    public init(
        currentPrice: Int64,
        ext: ManageOfferResultCurrentPriceRestrictionExt) {

      self.currentPrice = currentPrice
      self.ext = ext
    }

    public func toXDR() -> Data {
      var xdr = Data()

      xdr.append(self.currentPrice.toXDR())
      xdr.append(self.ext.toXDR())

      return xdr
    }

    public enum ManageOfferResultCurrentPriceRestrictionExt: XDRDiscriminatedUnion {
      case emptyVersion()

      public var discriminant: Int32 {
        switch self {
        case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
        }
      }

      public func toXDR() -> Data {
        var xdr = Data()
              
        xdr.append(self.discriminant.toXDR())
              
        switch self {
        case .emptyVersion(): xdr.append(Data())
        }

        return xdr
      }

    }
  }
}

// === xdr source ============================================================

//  enum ManageSaleAction
//  {
//      CREATE_UPDATE_DETAILS_REQUEST = 1,
//      CANCEL = 2,
//  	SET_STATE = 3,
//  	CREATE_PROMOTION_UPDATE_REQUEST = 4,
//  	CREATE_UPDATE_END_TIME_REQUEST = 5
//  };

//  ===========================================================================
public enum ManageSaleAction: Int32, XDREnum {
  case createUpdateDetailsRequest = 1
  case cancel = 2
  case setState = 3
  case createPromotionUpdateRequest = 4
  case createUpdateEndTimeRequest = 5
}

// === xdr source ============================================================

//  struct UpdateSaleDetailsData {
//      uint64 requestID; // if requestID is 0 - create request, else - update
//      longstring newDetails;
//  
//      // reserved for future use
//      union switch (LedgerVersion v)
//      {
//      case EMPTY_VERSION:
//          void;
//      } ext;
//  };

//  ===========================================================================
public struct UpdateSaleDetailsData: XDREncodable {
  public var requestID: Uint64
  public var newDetails: Longstring
  public var ext: UpdateSaleDetailsDataExt

  public init(
      requestID: Uint64,
      newDetails: Longstring,
      ext: UpdateSaleDetailsDataExt) {

    self.requestID = requestID
    self.newDetails = newDetails
    self.ext = ext
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.requestID.toXDR())
    xdr.append(self.newDetails.toXDR())
    xdr.append(self.ext.toXDR())

    return xdr
  }

  public enum UpdateSaleDetailsDataExt: XDRDiscriminatedUnion {
    case emptyVersion()

    public var discriminant: Int32 {
      switch self {
      case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .emptyVersion(): xdr.append(Data())
      }

      return xdr
    }

  }
}

// === xdr source ============================================================

//  struct PromotionUpdateData {
//      uint64 requestID; // if requestID is 0 - create request, else - update
//      SaleCreationRequest newPromotionData;
//  
//      union switch (LedgerVersion v)
//      {
//      case EMPTY_VERSION:
//          void;
//      } ext;
//  };

//  ===========================================================================
public struct PromotionUpdateData: XDREncodable {
  public var requestID: Uint64
  public var newPromotionData: SaleCreationRequest
  public var ext: PromotionUpdateDataExt

  public init(
      requestID: Uint64,
      newPromotionData: SaleCreationRequest,
      ext: PromotionUpdateDataExt) {

    self.requestID = requestID
    self.newPromotionData = newPromotionData
    self.ext = ext
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.requestID.toXDR())
    xdr.append(self.newPromotionData.toXDR())
    xdr.append(self.ext.toXDR())

    return xdr
  }

  public enum PromotionUpdateDataExt: XDRDiscriminatedUnion {
    case emptyVersion()

    public var discriminant: Int32 {
      switch self {
      case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .emptyVersion(): xdr.append(Data())
      }

      return xdr
    }

  }
}

// === xdr source ============================================================

//  struct UpdateSaleEndTimeData {
//      uint64 requestID; // if requestID is 0 - create request, else - update
//      uint64 newEndTime;
//  
//      // reserved for future use
//      union switch (LedgerVersion v)
//      {
//      case EMPTY_VERSION:
//          void;
//      } ext;
//  };

//  ===========================================================================
public struct UpdateSaleEndTimeData: XDREncodable {
  public var requestID: Uint64
  public var newEndTime: Uint64
  public var ext: UpdateSaleEndTimeDataExt

  public init(
      requestID: Uint64,
      newEndTime: Uint64,
      ext: UpdateSaleEndTimeDataExt) {

    self.requestID = requestID
    self.newEndTime = newEndTime
    self.ext = ext
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.requestID.toXDR())
    xdr.append(self.newEndTime.toXDR())
    xdr.append(self.ext.toXDR())

    return xdr
  }

  public enum UpdateSaleEndTimeDataExt: XDRDiscriminatedUnion {
    case emptyVersion()

    public var discriminant: Int32 {
      switch self {
      case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .emptyVersion(): xdr.append(Data())
      }

      return xdr
    }

  }
}

// === xdr source ============================================================

//  struct ManageSaleOp
//  {
//      uint64 saleID;
//  
//      union switch (ManageSaleAction action) {
//      case CREATE_UPDATE_DETAILS_REQUEST:
//          UpdateSaleDetailsData updateSaleDetailsData;
//      case CANCEL:
//          void;
//  	case SET_STATE:
//  		SaleState saleState;
//      case CREATE_PROMOTION_UPDATE_REQUEST:
//          PromotionUpdateData promotionUpdateData;
//      case CREATE_UPDATE_END_TIME_REQUEST:
//          UpdateSaleEndTimeData updateSaleEndTimeData;
//      } data;
//  
//      // reserved for future use
//      union switch (LedgerVersion v)
//      {
//      case EMPTY_VERSION:
//          void;
//      } ext;
//  };

//  ===========================================================================
public struct ManageSaleOp: XDREncodable {
  public var saleID: Uint64
  public var data: ManageSaleOpData
  public var ext: ManageSaleOpExt

  public init(
      saleID: Uint64,
      data: ManageSaleOpData,
      ext: ManageSaleOpExt) {

    self.saleID = saleID
    self.data = data
    self.ext = ext
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.saleID.toXDR())
    xdr.append(self.data.toXDR())
    xdr.append(self.ext.toXDR())

    return xdr
  }

  public enum ManageSaleOpData: XDRDiscriminatedUnion {
    case createUpdateDetailsRequest(UpdateSaleDetailsData)
    case cancel()
    case setState(SaleState)
    case createPromotionUpdateRequest(PromotionUpdateData)
    case createUpdateEndTimeRequest(UpdateSaleEndTimeData)

    public var discriminant: Int32 {
      switch self {
      case .createUpdateDetailsRequest: return ManageSaleAction.createUpdateDetailsRequest.rawValue
      case .cancel: return ManageSaleAction.cancel.rawValue
      case .setState: return ManageSaleAction.setState.rawValue
      case .createPromotionUpdateRequest: return ManageSaleAction.createPromotionUpdateRequest.rawValue
      case .createUpdateEndTimeRequest: return ManageSaleAction.createUpdateEndTimeRequest.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .createUpdateDetailsRequest(let data): xdr.append(data.toXDR())
      case .cancel(): xdr.append(Data())
      case .setState(let data): xdr.append(data.toXDR())
      case .createPromotionUpdateRequest(let data): xdr.append(data.toXDR())
      case .createUpdateEndTimeRequest(let data): xdr.append(data.toXDR())
      }

      return xdr
    }

  }
  public enum ManageSaleOpExt: XDRDiscriminatedUnion {
    case emptyVersion()

    public var discriminant: Int32 {
      switch self {
      case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .emptyVersion(): xdr.append(Data())
      }

      return xdr
    }

  }
}

// === xdr source ============================================================

//  enum ManageSaleResultCode
//  {
//      SUCCESS = 0,
//  
//      SALE_NOT_FOUND = -1, // sale not found
//  
//      // errors related to action "CREATE_UPDATE_DETAILS_REQUEST"
//      INVALID_NEW_DETAILS = -2, // newDetails field is invalid JSON
//      UPDATE_DETAILS_REQUEST_ALREADY_EXISTS = -3,
//      UPDATE_DETAILS_REQUEST_NOT_FOUND = -4,
//  
//      // errors related to action "SET_STATE"
//      NOT_ALLOWED = -5, // it's not allowed to set state for non master account
//  
//      // errors related to action "CREATE_PROMOTION_UPDATE_REQUEST"
//      PROMOTION_UPDATE_REQUEST_INVALID_ASSET_PAIR = -6, // one of the assets has invalid code or base asset is equal to quote asset
//      PROMOTION_UPDATE_REQUEST_INVALID_PRICE = -7, // price cannot be 0
//      PROMOTION_UPDATE_REQUEST_START_END_INVALID = -8, // sale ends before start
//      PROMOTION_UPDATE_REQUEST_INVALID_CAP = -9, // hard cap is < soft cap
//      PROMOTION_UPDATE_REQUEST_INVALID_DETAILS = -10, // details field is invalid JSON
//      INVALID_SALE_STATE = -11, // sale state must be "PROMOTION"
//      PROMOTION_UPDATE_REQUEST_ALREADY_EXISTS = -12,
//      PROMOTION_UPDATE_REQUEST_NOT_FOUND = -13,
//  
//      // errors related to action "CREATE_UPDATE_END_TIME_REQUEST"
//      INVALID_NEW_END_TIME = -14, // new end time is before start time or current ledger close time
//      UPDATE_END_TIME_REQUEST_ALREADY_EXISTS = -15,
//      UPDATE_END_TIME_REQUEST_NOT_FOUND = -16
//  };

//  ===========================================================================
public enum ManageSaleResultCode: Int32, XDREnum {
  case success = 0
  case saleNotFound = -1
  case invalidNewDetails = -2
  case updateDetailsRequestAlreadyExists = -3
  case updateDetailsRequestNotFound = -4
  case notAllowed = -5
  case promotionUpdateRequestInvalidAssetPair = -6
  case promotionUpdateRequestInvalidPrice = -7
  case promotionUpdateRequestStartEndInvalid = -8
  case promotionUpdateRequestInvalidCap = -9
  case promotionUpdateRequestInvalidDetails = -10
  case invalidSaleState = -11
  case promotionUpdateRequestAlreadyExists = -12
  case promotionUpdateRequestNotFound = -13
  case invalidNewEndTime = -14
  case updateEndTimeRequestAlreadyExists = -15
  case updateEndTimeRequestNotFound = -16
}

// === xdr source ============================================================

//  struct ManageSaleResultSuccess
//  {
//      union switch (ManageSaleAction action) {
//      case CREATE_UPDATE_DETAILS_REQUEST:
//          uint64 requestID;
//      case CANCEL:
//          void;
//  	case SET_STATE:
//  		void;
//      case CREATE_PROMOTION_UPDATE_REQUEST:
//          uint64 promotionUpdateRequestID;
//  	case CREATE_UPDATE_END_TIME_REQUEST:
//  	    uint64 updateEndTimeRequestID;
//      } response;
//  
//      // reserved for future use
//      union switch (LedgerVersion v)
//      {
//      case EMPTY_VERSION:
//          void;
//      case ALLOW_TO_UPDATE_VOTING_SALES_AS_PROMOTION:
//          bool fulfilled; // can be used for any reviewable request type created with manage sale operation
//      }
//      ext;
//  };

//  ===========================================================================
public struct ManageSaleResultSuccess: XDREncodable {
  public var response: ManageSaleResultSuccessResponse
  public var ext: ManageSaleResultSuccessExt

  public init(
      response: ManageSaleResultSuccessResponse,
      ext: ManageSaleResultSuccessExt) {

    self.response = response
    self.ext = ext
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.response.toXDR())
    xdr.append(self.ext.toXDR())

    return xdr
  }

  public enum ManageSaleResultSuccessResponse: XDRDiscriminatedUnion {
    case createUpdateDetailsRequest(Uint64)
    case cancel()
    case setState()
    case createPromotionUpdateRequest(Uint64)
    case createUpdateEndTimeRequest(Uint64)

    public var discriminant: Int32 {
      switch self {
      case .createUpdateDetailsRequest: return ManageSaleAction.createUpdateDetailsRequest.rawValue
      case .cancel: return ManageSaleAction.cancel.rawValue
      case .setState: return ManageSaleAction.setState.rawValue
      case .createPromotionUpdateRequest: return ManageSaleAction.createPromotionUpdateRequest.rawValue
      case .createUpdateEndTimeRequest: return ManageSaleAction.createUpdateEndTimeRequest.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .createUpdateDetailsRequest(let data): xdr.append(data.toXDR())
      case .cancel(): xdr.append(Data())
      case .setState(): xdr.append(Data())
      case .createPromotionUpdateRequest(let data): xdr.append(data.toXDR())
      case .createUpdateEndTimeRequest(let data): xdr.append(data.toXDR())
      }

      return xdr
    }

  }
  public enum ManageSaleResultSuccessExt: XDRDiscriminatedUnion {
    case emptyVersion()
    case allowToUpdateVotingSalesAsPromotion(Bool)

    public var discriminant: Int32 {
      switch self {
      case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
      case .allowToUpdateVotingSalesAsPromotion: return LedgerVersion.allowToUpdateVotingSalesAsPromotion.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .emptyVersion(): xdr.append(Data())
      case .allowToUpdateVotingSalesAsPromotion(let data): xdr.append(data.toXDR())
      }

      return xdr
    }

  }
}

// === xdr source ============================================================

//  union ManageSaleResult switch (ManageSaleResultCode code)
//  {
//  case SUCCESS:
//      ManageSaleResultSuccess success;
//  default:
//      void;
//  };

//  ===========================================================================
public enum ManageSaleResult: XDRDiscriminatedUnion {
  case success(ManageSaleResultSuccess)

  public var discriminant: Int32 {
    switch self {
    case .success: return ManageSaleResultCode.success.rawValue
    }
  }

  public func toXDR() -> Data {
    var xdr = Data()
          
    xdr.append(self.discriminant.toXDR())
          
    switch self {
    case .success(let data): xdr.append(data.toXDR())
    }

    return xdr
  }
}

// === xdr source ============================================================

//  struct FeeDataV2 {
//      uint64 maxPaymentFee;
//      uint64 fixedFee;
//  
//      // Cross asset fees
//      AssetCode feeAsset;
//  
//  	// reserved for future use
//      union switch (LedgerVersion v)
//      {
//      case EMPTY_VERSION:
//          void;
//      }
//      ext;
//  };

//  ===========================================================================
public struct FeeDataV2: XDREncodable {
  public var maxPaymentFee: Uint64
  public var fixedFee: Uint64
  public var feeAsset: AssetCode
  public var ext: FeeDataV2Ext

  public init(
      maxPaymentFee: Uint64,
      fixedFee: Uint64,
      feeAsset: AssetCode,
      ext: FeeDataV2Ext) {

    self.maxPaymentFee = maxPaymentFee
    self.fixedFee = fixedFee
    self.feeAsset = feeAsset
    self.ext = ext
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.maxPaymentFee.toXDR())
    xdr.append(self.fixedFee.toXDR())
    xdr.append(self.feeAsset.toXDR())
    xdr.append(self.ext.toXDR())

    return xdr
  }

  public enum FeeDataV2Ext: XDRDiscriminatedUnion {
    case emptyVersion()

    public var discriminant: Int32 {
      switch self {
      case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .emptyVersion(): xdr.append(Data())
      }

      return xdr
    }

  }
}

// === xdr source ============================================================

//  struct PaymentFeeDataV2 {
//      FeeDataV2 sourceFee;
//      FeeDataV2 destinationFee;
//      bool sourcePaysForDest; // if true - source account pays fee, else destination
//  
//      union switch (LedgerVersion v)
//      {
//      case EMPTY_VERSION:
//          void;
//      }
//      ext;
//  };

//  ===========================================================================
public struct PaymentFeeDataV2: XDREncodable {
  public var sourceFee: FeeDataV2
  public var destinationFee: FeeDataV2
  public var sourcePaysForDest: Bool
  public var ext: PaymentFeeDataV2Ext

  public init(
      sourceFee: FeeDataV2,
      destinationFee: FeeDataV2,
      sourcePaysForDest: Bool,
      ext: PaymentFeeDataV2Ext) {

    self.sourceFee = sourceFee
    self.destinationFee = destinationFee
    self.sourcePaysForDest = sourcePaysForDest
    self.ext = ext
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.sourceFee.toXDR())
    xdr.append(self.destinationFee.toXDR())
    xdr.append(self.sourcePaysForDest.toXDR())
    xdr.append(self.ext.toXDR())

    return xdr
  }

  public enum PaymentFeeDataV2Ext: XDRDiscriminatedUnion {
    case emptyVersion()

    public var discriminant: Int32 {
      switch self {
      case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .emptyVersion(): xdr.append(Data())
      }

      return xdr
    }

  }
}

// === xdr source ============================================================

//  enum PaymentDestinationType {
//      ACCOUNT = 0,
//      BALANCE = 1
//  };

//  ===========================================================================
public enum PaymentDestinationType: Int32, XDREnum {
  case account = 0
  case balance = 1
}

// === xdr source ============================================================

//  struct PaymentOpV2
//  {
//      BalanceID sourceBalanceID;
//  
//      union switch (PaymentDestinationType type) {
//          case ACCOUNT:
//              AccountID accountID;
//          case BALANCE:
//              BalanceID balanceID;
//      } destination;
//  
//      uint64 amount;
//  
//      PaymentFeeDataV2 feeData;
//  
//      longstring subject;
//      longstring reference;
//  
//      // reserved for future use
//      union switch (LedgerVersion v)
//      {
//      case EMPTY_VERSION:
//          void;
//      }
//      ext;
//  };

//  ===========================================================================
public struct PaymentOpV2: XDREncodable {
  public var sourceBalanceID: BalanceID
  public var destination: PaymentOpV2Destination
  public var amount: Uint64
  public var feeData: PaymentFeeDataV2
  public var subject: Longstring
  public var reference: Longstring
  public var ext: PaymentOpV2Ext

  public init(
      sourceBalanceID: BalanceID,
      destination: PaymentOpV2Destination,
      amount: Uint64,
      feeData: PaymentFeeDataV2,
      subject: Longstring,
      reference: Longstring,
      ext: PaymentOpV2Ext) {

    self.sourceBalanceID = sourceBalanceID
    self.destination = destination
    self.amount = amount
    self.feeData = feeData
    self.subject = subject
    self.reference = reference
    self.ext = ext
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.sourceBalanceID.toXDR())
    xdr.append(self.destination.toXDR())
    xdr.append(self.amount.toXDR())
    xdr.append(self.feeData.toXDR())
    xdr.append(self.subject.toXDR())
    xdr.append(self.reference.toXDR())
    xdr.append(self.ext.toXDR())

    return xdr
  }

  public enum PaymentOpV2Destination: XDRDiscriminatedUnion {
    case account(AccountID)
    case balance(BalanceID)

    public var discriminant: Int32 {
      switch self {
      case .account: return PaymentDestinationType.account.rawValue
      case .balance: return PaymentDestinationType.balance.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .account(let data): xdr.append(data.toXDR())
      case .balance(let data): xdr.append(data.toXDR())
      }

      return xdr
    }

  }
  public enum PaymentOpV2Ext: XDRDiscriminatedUnion {
    case emptyVersion()

    public var discriminant: Int32 {
      switch self {
      case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .emptyVersion(): xdr.append(Data())
      }

      return xdr
    }

  }
}

// === xdr source ============================================================

//  enum PaymentV2ResultCode
//  {
//      // codes considered as "success" for the operation
//      SUCCESS = 0, // payment successfully completed
//  
//      // codes considered as "failure" for the operation
//      MALFORMED = -1, // bad input
//      UNDERFUNDED = -2, // not enough funds in source account
//      LINE_FULL = -3, // destination would go above their limit
//  	DESTINATION_BALANCE_NOT_FOUND = -4,
//      BALANCE_ASSETS_MISMATCHED = -5,
//  	SRC_BALANCE_NOT_FOUND = -6, // source balance not found
//      REFERENCE_DUPLICATION = -7,
//      STATS_OVERFLOW = -8,
//      LIMITS_EXCEEDED = -9,
//      NOT_ALLOWED_BY_ASSET_POLICY = -10,
//      INVALID_DESTINATION_FEE = -11,
//      INVALID_DESTINATION_FEE_ASSET = -12, // destination fee asset must be the same as source balance asset
//      FEE_ASSET_MISMATCHED = -13,
//      INSUFFICIENT_FEE_AMOUNT = -14,
//      BALANCE_TO_CHARGE_FEE_FROM_NOT_FOUND = -15,
//      PAYMENT_AMOUNT_IS_LESS_THAN_DEST_FEE = -16,
//      DESTINATION_ACCOUNT_NOT_FOUND = -17
//  
//       // !!! Add new result code to review invoice op too !!!
//  };

//  ===========================================================================
public enum PaymentV2ResultCode: Int32, XDREnum {
  case success = 0
  case malformed = -1
  case underfunded = -2
  case lineFull = -3
  case destinationBalanceNotFound = -4
  case balanceAssetsMismatched = -5
  case srcBalanceNotFound = -6
  case referenceDuplication = -7
  case statsOverflow = -8
  case limitsExceeded = -9
  case notAllowedByAssetPolicy = -10
  case invalidDestinationFee = -11
  case invalidDestinationFeeAsset = -12
  case feeAssetMismatched = -13
  case insufficientFeeAmount = -14
  case balanceToChargeFeeFromNotFound = -15
  case paymentAmountIsLessThanDestFee = -16
  case destinationAccountNotFound = -17
}

// === xdr source ============================================================

//  struct PaymentV2Response {
//      AccountID destination;
//      BalanceID destinationBalanceID;
//  
//      AssetCode asset;
//      uint64 sourceSentUniversal;
//      uint64 paymentID;
//  
//      uint64 actualSourcePaymentFee;
//      uint64 actualDestinationPaymentFee;
//  
//      // reserved for future use
//      union switch (LedgerVersion v)
//      {
//      case EMPTY_VERSION:
//          void;
//      }
//      ext;
//  };

//  ===========================================================================
public struct PaymentV2Response: XDREncodable {
  public var destination: AccountID
  public var destinationBalanceID: BalanceID
  public var asset: AssetCode
  public var sourceSentUniversal: Uint64
  public var paymentID: Uint64
  public var actualSourcePaymentFee: Uint64
  public var actualDestinationPaymentFee: Uint64
  public var ext: PaymentV2ResponseExt

  public init(
      destination: AccountID,
      destinationBalanceID: BalanceID,
      asset: AssetCode,
      sourceSentUniversal: Uint64,
      paymentID: Uint64,
      actualSourcePaymentFee: Uint64,
      actualDestinationPaymentFee: Uint64,
      ext: PaymentV2ResponseExt) {

    self.destination = destination
    self.destinationBalanceID = destinationBalanceID
    self.asset = asset
    self.sourceSentUniversal = sourceSentUniversal
    self.paymentID = paymentID
    self.actualSourcePaymentFee = actualSourcePaymentFee
    self.actualDestinationPaymentFee = actualDestinationPaymentFee
    self.ext = ext
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.destination.toXDR())
    xdr.append(self.destinationBalanceID.toXDR())
    xdr.append(self.asset.toXDR())
    xdr.append(self.sourceSentUniversal.toXDR())
    xdr.append(self.paymentID.toXDR())
    xdr.append(self.actualSourcePaymentFee.toXDR())
    xdr.append(self.actualDestinationPaymentFee.toXDR())
    xdr.append(self.ext.toXDR())

    return xdr
  }

  public enum PaymentV2ResponseExt: XDRDiscriminatedUnion {
    case emptyVersion()

    public var discriminant: Int32 {
      switch self {
      case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .emptyVersion(): xdr.append(Data())
      }

      return xdr
    }

  }
}

// === xdr source ============================================================

//  union PaymentV2Result switch (PaymentV2ResultCode code)
//  {
//  case SUCCESS:
//      PaymentV2Response paymentV2Response;
//  default:
//      void;
//  };

//  ===========================================================================
public enum PaymentV2Result: XDRDiscriminatedUnion {
  case success(PaymentV2Response)

  public var discriminant: Int32 {
    switch self {
    case .success: return PaymentV2ResultCode.success.rawValue
    }
  }

  public func toXDR() -> Data {
    var xdr = Data()
          
    xdr.append(self.discriminant.toXDR())
          
    switch self {
    case .success(let data): xdr.append(data.toXDR())
    }

    return xdr
  }
}

// === xdr source ============================================================

//  struct InvoiceReference {
//      uint64 invoiceID;
//      bool accept;
//  	// reserved for future use
//      union switch (LedgerVersion v)
//      {
//      case EMPTY_VERSION:
//          void;
//      }
//      ext;
//  };

//  ===========================================================================
public struct InvoiceReference: XDREncodable {
  public var invoiceID: Uint64
  public var accept: Bool
  public var ext: InvoiceReferenceExt

  public init(
      invoiceID: Uint64,
      accept: Bool,
      ext: InvoiceReferenceExt) {

    self.invoiceID = invoiceID
    self.accept = accept
    self.ext = ext
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.invoiceID.toXDR())
    xdr.append(self.accept.toXDR())
    xdr.append(self.ext.toXDR())

    return xdr
  }

  public enum InvoiceReferenceExt: XDRDiscriminatedUnion {
    case emptyVersion()

    public var discriminant: Int32 {
      switch self {
      case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .emptyVersion(): xdr.append(Data())
      }

      return xdr
    }

  }
}

// === xdr source ============================================================

//  struct FeeData {
//      int64 paymentFee;
//      int64 fixedFee;
//  	// reserved for future use
//      union switch (LedgerVersion v)
//      {
//      case EMPTY_VERSION:
//          void;
//      }
//      ext;
//  };

//  ===========================================================================
public struct FeeData: XDREncodable {
  public var paymentFee: Int64
  public var fixedFee: Int64
  public var ext: FeeDataExt

  public init(
      paymentFee: Int64,
      fixedFee: Int64,
      ext: FeeDataExt) {

    self.paymentFee = paymentFee
    self.fixedFee = fixedFee
    self.ext = ext
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.paymentFee.toXDR())
    xdr.append(self.fixedFee.toXDR())
    xdr.append(self.ext.toXDR())

    return xdr
  }

  public enum FeeDataExt: XDRDiscriminatedUnion {
    case emptyVersion()

    public var discriminant: Int32 {
      switch self {
      case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .emptyVersion(): xdr.append(Data())
      }

      return xdr
    }

  }
}

// === xdr source ============================================================

//  struct PaymentFeeData {
//      FeeData sourceFee;
//      FeeData destinationFee;
//      bool sourcePaysForDest;    // if true source account pays fee, else destination
//  	// reserved for future use
//      union switch (LedgerVersion v)
//      {
//      case EMPTY_VERSION:
//          void;
//      }
//      ext;
//  };

//  ===========================================================================
public struct PaymentFeeData: XDREncodable {
  public var sourceFee: FeeData
  public var destinationFee: FeeData
  public var sourcePaysForDest: Bool
  public var ext: PaymentFeeDataExt

  public init(
      sourceFee: FeeData,
      destinationFee: FeeData,
      sourcePaysForDest: Bool,
      ext: PaymentFeeDataExt) {

    self.sourceFee = sourceFee
    self.destinationFee = destinationFee
    self.sourcePaysForDest = sourcePaysForDest
    self.ext = ext
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.sourceFee.toXDR())
    xdr.append(self.destinationFee.toXDR())
    xdr.append(self.sourcePaysForDest.toXDR())
    xdr.append(self.ext.toXDR())

    return xdr
  }

  public enum PaymentFeeDataExt: XDRDiscriminatedUnion {
    case emptyVersion()

    public var discriminant: Int32 {
      switch self {
      case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .emptyVersion(): xdr.append(Data())
      }

      return xdr
    }

  }
}

// === xdr source ============================================================

//  struct PaymentOp
//  {
//      BalanceID sourceBalanceID;
//      BalanceID destinationBalanceID;
//      int64 amount;          // amount they end up with
//  
//      PaymentFeeData feeData;
//  
//      string256 subject;
//      string64 reference;
//      
//      InvoiceReference* invoiceReference;
//  
//  	// reserved for future use
//      union switch (LedgerVersion v)
//      {
//      case EMPTY_VERSION:
//          void;
//      }
//      ext;
//  };

//  ===========================================================================
public struct PaymentOp: XDREncodable {
  public var sourceBalanceID: BalanceID
  public var destinationBalanceID: BalanceID
  public var amount: Int64
  public var feeData: PaymentFeeData
  public var subject: String256
  public var reference: String64
  public var invoiceReference: InvoiceReference?
  public var ext: PaymentOpExt

  public init(
      sourceBalanceID: BalanceID,
      destinationBalanceID: BalanceID,
      amount: Int64,
      feeData: PaymentFeeData,
      subject: String256,
      reference: String64,
      invoiceReference: InvoiceReference?,
      ext: PaymentOpExt) {

    self.sourceBalanceID = sourceBalanceID
    self.destinationBalanceID = destinationBalanceID
    self.amount = amount
    self.feeData = feeData
    self.subject = subject
    self.reference = reference
    self.invoiceReference = invoiceReference
    self.ext = ext
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.sourceBalanceID.toXDR())
    xdr.append(self.destinationBalanceID.toXDR())
    xdr.append(self.amount.toXDR())
    xdr.append(self.feeData.toXDR())
    xdr.append(self.subject.toXDR())
    xdr.append(self.reference.toXDR())
    xdr.append(self.invoiceReference.toXDR())
    xdr.append(self.ext.toXDR())

    return xdr
  }

  public enum PaymentOpExt: XDRDiscriminatedUnion {
    case emptyVersion()

    public var discriminant: Int32 {
      switch self {
      case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .emptyVersion(): xdr.append(Data())
      }

      return xdr
    }

  }
}

// === xdr source ============================================================

//  enum PaymentResultCode
//  {
//      // codes considered as "success" for the operation
//      SUCCESS = 0, // payment successfuly completed
//  
//      // codes considered as "failure" for the operation
//      MALFORMED = -1,       // bad input
//      UNDERFUNDED = -2,     // not enough funds in source account
//      LINE_FULL = -3,       // destination would go above their limit
//  	FEE_MISMATCHED = -4,   // fee is not equal to expected fee
//      BALANCE_NOT_FOUND = -5, // destination balance not found
//      BALANCE_ACCOUNT_MISMATCHED = -6,
//      BALANCE_ASSETS_MISMATCHED = -7,
//  	SRC_BALANCE_NOT_FOUND = -8, // source balance not found
//      REFERENCE_DUPLICATION = -9,
//      STATS_OVERFLOW = -10,
//      LIMITS_EXCEEDED = -11,
//      NOT_ALLOWED_BY_ASSET_POLICY = -12,
//      INVOICE_NOT_FOUND = -13,
//      INVOICE_WRONG_AMOUNT = -14,
//      INVOICE_BALANCE_MISMATCH = -15,
//      INVOICE_ACCOUNT_MISMATCH = -16,
//      INVOICE_ALREADY_PAID = -17,
//      PAYMENT_V1_NO_LONGER_SUPPORTED = -18
//  };

//  ===========================================================================
public enum PaymentResultCode: Int32, XDREnum {
  case success = 0
  case malformed = -1
  case underfunded = -2
  case lineFull = -3
  case feeMismatched = -4
  case balanceNotFound = -5
  case balanceAccountMismatched = -6
  case balanceAssetsMismatched = -7
  case srcBalanceNotFound = -8
  case referenceDuplication = -9
  case statsOverflow = -10
  case limitsExceeded = -11
  case notAllowedByAssetPolicy = -12
  case invoiceNotFound = -13
  case invoiceWrongAmount = -14
  case invoiceBalanceMismatch = -15
  case invoiceAccountMismatch = -16
  case invoiceAlreadyPaid = -17
  case paymentV1NoLongerSupported = -18
}

// === xdr source ============================================================

//  struct PaymentResponse {
//      AccountID destination;
//      uint64 paymentID;
//      AssetCode asset;
//      // reserved for future use
//      union switch (LedgerVersion v)
//      {
//      case EMPTY_VERSION:
//          void;
//      }
//      ext;
//  };

//  ===========================================================================
public struct PaymentResponse: XDREncodable {
  public var destination: AccountID
  public var paymentID: Uint64
  public var asset: AssetCode
  public var ext: PaymentResponseExt

  public init(
      destination: AccountID,
      paymentID: Uint64,
      asset: AssetCode,
      ext: PaymentResponseExt) {

    self.destination = destination
    self.paymentID = paymentID
    self.asset = asset
    self.ext = ext
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.destination.toXDR())
    xdr.append(self.paymentID.toXDR())
    xdr.append(self.asset.toXDR())
    xdr.append(self.ext.toXDR())

    return xdr
  }

  public enum PaymentResponseExt: XDRDiscriminatedUnion {
    case emptyVersion()

    public var discriminant: Int32 {
      switch self {
      case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .emptyVersion(): xdr.append(Data())
      }

      return xdr
    }

  }
}

// === xdr source ============================================================

//  union PaymentResult switch (PaymentResultCode code)
//  {
//  case SUCCESS:
//      PaymentResponse paymentResponse;
//  default:
//      void;
//  };

//  ===========================================================================
public enum PaymentResult: XDRDiscriminatedUnion {
  case success(PaymentResponse)

  public var discriminant: Int32 {
    switch self {
    case .success: return PaymentResultCode.success.rawValue
    }
  }

  public func toXDR() -> Data {
    var xdr = Data()
          
    xdr.append(self.discriminant.toXDR())
          
    switch self {
    case .success(let data): xdr.append(data.toXDR())
    }

    return xdr
  }
}

// === xdr source ============================================================

//  struct PayoutOp
//  {
//      AssetCode asset; // asset, which holders will receive dividends
//      BalanceID sourceBalanceID; // balance, from which payout will be performed
//  
//      uint64 maxPayoutAmount; // max amount of asset, that owner wants to pay out
//      uint64 minPayoutAmount; // min tokens amount which will be payed for one balance;
//      uint64 minAssetHolderAmount; // min tokens amount for which holder will received dividends
//  
//      Fee fee;
//  
//      // reserved for future use
//      union switch (LedgerVersion v)
//      {
//      case EMPTY_VERSION:
//          void;
//      }
//      ext;
//  };

//  ===========================================================================
public struct PayoutOp: XDREncodable {
  public var asset: AssetCode
  public var sourceBalanceID: BalanceID
  public var maxPayoutAmount: Uint64
  public var minPayoutAmount: Uint64
  public var minAssetHolderAmount: Uint64
  public var fee: Fee
  public var ext: PayoutOpExt

  public init(
      asset: AssetCode,
      sourceBalanceID: BalanceID,
      maxPayoutAmount: Uint64,
      minPayoutAmount: Uint64,
      minAssetHolderAmount: Uint64,
      fee: Fee,
      ext: PayoutOpExt) {

    self.asset = asset
    self.sourceBalanceID = sourceBalanceID
    self.maxPayoutAmount = maxPayoutAmount
    self.minPayoutAmount = minPayoutAmount
    self.minAssetHolderAmount = minAssetHolderAmount
    self.fee = fee
    self.ext = ext
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.asset.toXDR())
    xdr.append(self.sourceBalanceID.toXDR())
    xdr.append(self.maxPayoutAmount.toXDR())
    xdr.append(self.minPayoutAmount.toXDR())
    xdr.append(self.minAssetHolderAmount.toXDR())
    xdr.append(self.fee.toXDR())
    xdr.append(self.ext.toXDR())

    return xdr
  }

  public enum PayoutOpExt: XDRDiscriminatedUnion {
    case emptyVersion()

    public var discriminant: Int32 {
      switch self {
      case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .emptyVersion(): xdr.append(Data())
      }

      return xdr
    }

  }
}

// === xdr source ============================================================

//  enum PayoutResultCode
//  {
//      // codes considered as "success" for the operation
//      SUCCESS = 0,    // payout successfully completed
//  
//      // codes considered as "failure" for the operation
//      INVALID_AMOUNT = -1, // max payout amount can not be zero
//      INVALID_ASSET = -2,
//      ASSET_NOT_FOUND = -3,
//      ASSET_NOT_TRANSFERABLE = -4, // asset must have policy transferable
//      BALANCE_NOT_FOUND = -5,
//      INSUFFICIENT_FEE_AMOUNT = -6,
//      FEE_EXCEEDS_ACTUAL_AMOUNT = -7,
//      TOTAL_FEE_OVERFLOW = -8,
//      UNDERFUNDED = -9, // not enough amount on source balance
//      HOLDERS_NOT_FOUND = -10, // there is no holders of such asset
//      MIN_AMOUNT_TOO_BIG = -11, // there is no appropriate holders balances
//      LINE_FULL = -12, // destination balance amount overflows
//      STATS_OVERFLOW = -13, // source statistics overflow
//      LIMITS_EXCEEDED = -14 // source account limit exceeded
//  };

//  ===========================================================================
public enum PayoutResultCode: Int32, XDREnum {
  case success = 0
  case invalidAmount = -1
  case invalidAsset = -2
  case assetNotFound = -3
  case assetNotTransferable = -4
  case balanceNotFound = -5
  case insufficientFeeAmount = -6
  case feeExceedsActualAmount = -7
  case totalFeeOverflow = -8
  case underfunded = -9
  case holdersNotFound = -10
  case minAmountTooBig = -11
  case lineFull = -12
  case statsOverflow = -13
  case limitsExceeded = -14
}

// === xdr source ============================================================

//  struct PayoutResponse
//  {
//      AccountID receiverID;
//      BalanceID receiverBalanceID;
//      uint64 receivedAmount;
//  
//      // reserved for future use
//      union switch (LedgerVersion v)
//      {
//      case EMPTY_VERSION:
//          void;
//      }
//      ext;
//  };

//  ===========================================================================
public struct PayoutResponse: XDREncodable {
  public var receiverID: AccountID
  public var receiverBalanceID: BalanceID
  public var receivedAmount: Uint64
  public var ext: PayoutResponseExt

  public init(
      receiverID: AccountID,
      receiverBalanceID: BalanceID,
      receivedAmount: Uint64,
      ext: PayoutResponseExt) {

    self.receiverID = receiverID
    self.receiverBalanceID = receiverBalanceID
    self.receivedAmount = receivedAmount
    self.ext = ext
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.receiverID.toXDR())
    xdr.append(self.receiverBalanceID.toXDR())
    xdr.append(self.receivedAmount.toXDR())
    xdr.append(self.ext.toXDR())

    return xdr
  }

  public enum PayoutResponseExt: XDRDiscriminatedUnion {
    case emptyVersion()

    public var discriminant: Int32 {
      switch self {
      case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .emptyVersion(): xdr.append(Data())
      }

      return xdr
    }

  }
}

// === xdr source ============================================================

//  struct PayoutSuccessResult
//  {
//      PayoutResponse payoutResponses<>;
//      uint64 actualPayoutAmount;
//      Fee actualFee;
//  
//      // reserved for future use
//      union switch (LedgerVersion v)
//      {
//      case EMPTY_VERSION:
//          void;
//      }
//      ext;
//  };

//  ===========================================================================
public struct PayoutSuccessResult: XDREncodable {
  public var payoutResponses: [PayoutResponse]
  public var actualPayoutAmount: Uint64
  public var actualFee: Fee
  public var ext: PayoutSuccessResultExt

  public init(
      payoutResponses: [PayoutResponse],
      actualPayoutAmount: Uint64,
      actualFee: Fee,
      ext: PayoutSuccessResultExt) {

    self.payoutResponses = payoutResponses
    self.actualPayoutAmount = actualPayoutAmount
    self.actualFee = actualFee
    self.ext = ext
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.payoutResponses.toXDR())
    xdr.append(self.actualPayoutAmount.toXDR())
    xdr.append(self.actualFee.toXDR())
    xdr.append(self.ext.toXDR())

    return xdr
  }

  public enum PayoutSuccessResultExt: XDRDiscriminatedUnion {
    case emptyVersion()

    public var discriminant: Int32 {
      switch self {
      case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .emptyVersion(): xdr.append(Data())
      }

      return xdr
    }

  }
}

// === xdr source ============================================================

//  union PayoutResult switch (PayoutResultCode code)
//  {
//      case SUCCESS:
//          PayoutSuccessResult success;
//      default:
//          void;
//  };

//  ===========================================================================
public enum PayoutResult: XDRDiscriminatedUnion {
  case success(PayoutSuccessResult)

  public var discriminant: Int32 {
    switch self {
    case .success: return PayoutResultCode.success.rawValue
    }
  }

  public func toXDR() -> Data {
    var xdr = Data()
          
    xdr.append(self.discriminant.toXDR())
          
    switch self {
    case .success(let data): xdr.append(data.toXDR())
    }

    return xdr
  }
}

// === xdr source ============================================================

//  enum ReviewRequestOpAction {
//  	APPROVE = 1,
//  	REJECT = 2,
//  	PERMANENT_REJECT = 3
//  };

//  ===========================================================================
public enum ReviewRequestOpAction: Int32, XDREnum {
  case approve = 1
  case reject = 2
  case permanentReject = 3
}

// === xdr source ============================================================

//  struct LimitsUpdateDetails {
//      LimitsV2Entry newLimitsV2;
//      union switch (LedgerVersion v)
//      {
//      case EMPTY_VERSION:
//          void;
//      }
//      ext;
//  };

//  ===========================================================================
public struct LimitsUpdateDetails: XDREncodable {
  public var newLimitsV2: LimitsV2Entry
  public var ext: LimitsUpdateDetailsExt

  public init(
      newLimitsV2: LimitsV2Entry,
      ext: LimitsUpdateDetailsExt) {

    self.newLimitsV2 = newLimitsV2
    self.ext = ext
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.newLimitsV2.toXDR())
    xdr.append(self.ext.toXDR())

    return xdr
  }

  public enum LimitsUpdateDetailsExt: XDRDiscriminatedUnion {
    case emptyVersion()

    public var discriminant: Int32 {
      switch self {
      case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .emptyVersion(): xdr.append(Data())
      }

      return xdr
    }

  }
}

// === xdr source ============================================================

//  struct WithdrawalDetails {
//  	string externalDetails<>;
//  	// reserved for future use
//      union switch (LedgerVersion v)
//      {
//      case EMPTY_VERSION:
//          void;
//      }
//      ext;
//  };

//  ===========================================================================
public struct WithdrawalDetails: XDREncodable {
  public var externalDetails: String
  public var ext: WithdrawalDetailsExt

  public init(
      externalDetails: String,
      ext: WithdrawalDetailsExt) {

    self.externalDetails = externalDetails
    self.ext = ext
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.externalDetails.toXDR())
    xdr.append(self.ext.toXDR())

    return xdr
  }

  public enum WithdrawalDetailsExt: XDRDiscriminatedUnion {
    case emptyVersion()

    public var discriminant: Int32 {
      switch self {
      case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .emptyVersion(): xdr.append(Data())
      }

      return xdr
    }

  }
}

// === xdr source ============================================================

//  struct AMLAlertDetails {
//  	string comment<>;
//  	// reserved for future use
//      union switch (LedgerVersion v)
//      {
//      case EMPTY_VERSION:
//          void;
//      }
//      ext;
//  };

//  ===========================================================================
public struct AMLAlertDetails: XDREncodable {
  public var comment: String
  public var ext: AMLAlertDetailsExt

  public init(
      comment: String,
      ext: AMLAlertDetailsExt) {

    self.comment = comment
    self.ext = ext
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.comment.toXDR())
    xdr.append(self.ext.toXDR())

    return xdr
  }

  public enum AMLAlertDetailsExt: XDRDiscriminatedUnion {
    case emptyVersion()

    public var discriminant: Int32 {
      switch self {
      case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .emptyVersion(): xdr.append(Data())
      }

      return xdr
    }

  }
}

// === xdr source ============================================================

//  struct UpdateKYCDetails {
//      uint32 tasksToAdd;
//      uint32 tasksToRemove;
//      string externalDetails<>;
//      // Reserved for future use
//      union switch (LedgerVersion v)
//      {
//      case EMPTY_VERSION:
//          void;
//      }
//      ext;
//  };

//  ===========================================================================
public struct UpdateKYCDetails: XDREncodable {
  public var tasksToAdd: Uint32
  public var tasksToRemove: Uint32
  public var externalDetails: String
  public var ext: UpdateKYCDetailsExt

  public init(
      tasksToAdd: Uint32,
      tasksToRemove: Uint32,
      externalDetails: String,
      ext: UpdateKYCDetailsExt) {

    self.tasksToAdd = tasksToAdd
    self.tasksToRemove = tasksToRemove
    self.externalDetails = externalDetails
    self.ext = ext
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.tasksToAdd.toXDR())
    xdr.append(self.tasksToRemove.toXDR())
    xdr.append(self.externalDetails.toXDR())
    xdr.append(self.ext.toXDR())

    return xdr
  }

  public enum UpdateKYCDetailsExt: XDRDiscriminatedUnion {
    case emptyVersion()

    public var discriminant: Int32 {
      switch self {
      case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .emptyVersion(): xdr.append(Data())
      }

      return xdr
    }

  }
}

// === xdr source ============================================================

//  struct ContractDetails {
//      longstring details;
//  
//      // Reserved for future use
//      union switch (LedgerVersion v)
//      {
//      case EMPTY_VERSION:
//          void;
//      }
//      ext;
//  };

//  ===========================================================================
public struct ContractDetails: XDREncodable {
  public var details: Longstring
  public var ext: ContractDetailsExt

  public init(
      details: Longstring,
      ext: ContractDetailsExt) {

    self.details = details
    self.ext = ext
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.details.toXDR())
    xdr.append(self.ext.toXDR())

    return xdr
  }

  public enum ContractDetailsExt: XDRDiscriminatedUnion {
    case emptyVersion()

    public var discriminant: Int32 {
      switch self {
      case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .emptyVersion(): xdr.append(Data())
      }

      return xdr
    }

  }
}

// === xdr source ============================================================

//  struct BillPayDetails {
//      PaymentOpV2 paymentDetails;
//  
//      // reserved for future use
//      union switch (LedgerVersion v)
//      {
//      case EMPTY_VERSION:
//          void;
//      }
//      ext;
//  };

//  ===========================================================================
public struct BillPayDetails: XDREncodable {
  public var paymentDetails: PaymentOpV2
  public var ext: BillPayDetailsExt

  public init(
      paymentDetails: PaymentOpV2,
      ext: BillPayDetailsExt) {

    self.paymentDetails = paymentDetails
    self.ext = ext
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.paymentDetails.toXDR())
    xdr.append(self.ext.toXDR())

    return xdr
  }

  public enum BillPayDetailsExt: XDRDiscriminatedUnion {
    case emptyVersion()

    public var discriminant: Int32 {
      switch self {
      case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .emptyVersion(): xdr.append(Data())
      }

      return xdr
    }

  }
}

// === xdr source ============================================================

//  struct ReviewDetails {
//      uint32 tasksToAdd;
//      uint32 tasksToRemove;
//      string externalDetails<>;
//      // Reserved for future use
//      union switch (LedgerVersion v)
//      {
//      case EMPTY_VERSION:
//          void;
//      }
//      ext;
//  };

//  ===========================================================================
public struct ReviewDetails: XDREncodable {
  public var tasksToAdd: Uint32
  public var tasksToRemove: Uint32
  public var externalDetails: String
  public var ext: ReviewDetailsExt

  public init(
      tasksToAdd: Uint32,
      tasksToRemove: Uint32,
      externalDetails: String,
      ext: ReviewDetailsExt) {

    self.tasksToAdd = tasksToAdd
    self.tasksToRemove = tasksToRemove
    self.externalDetails = externalDetails
    self.ext = ext
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.tasksToAdd.toXDR())
    xdr.append(self.tasksToRemove.toXDR())
    xdr.append(self.externalDetails.toXDR())
    xdr.append(self.ext.toXDR())

    return xdr
  }

  public enum ReviewDetailsExt: XDRDiscriminatedUnion {
    case emptyVersion()

    public var discriminant: Int32 {
      switch self {
      case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .emptyVersion(): xdr.append(Data())
      }

      return xdr
    }

  }
}

// === xdr source ============================================================

//  struct SaleExtended {
//      uint64 saleID;
//  
//      // Reserved for future use
//      union switch (LedgerVersion v)
//      {
//      case EMPTY_VERSION:
//          void;
//      }
//      ext;
//  };

//  ===========================================================================
public struct SaleExtended: XDREncodable {
  public var saleID: Uint64
  public var ext: SaleExtendedExt

  public init(
      saleID: Uint64,
      ext: SaleExtendedExt) {

    self.saleID = saleID
    self.ext = ext
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.saleID.toXDR())
    xdr.append(self.ext.toXDR())

    return xdr
  }

  public enum SaleExtendedExt: XDRDiscriminatedUnion {
    case emptyVersion()

    public var discriminant: Int32 {
      switch self {
      case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .emptyVersion(): xdr.append(Data())
      }

      return xdr
    }

  }
}

// === xdr source ============================================================

//  struct ExtendedResult {
//      bool fulfilled;
//  
//      union switch(ReviewableRequestType requestType) {
//      case SALE:
//          SaleExtended saleExtended;
//      case NONE:
//          void;
//      } typeExt;
//  
//     // Reserved for future use
//     union switch (LedgerVersion v)
//     {
//     case EMPTY_VERSION:
//         void;
//     }
//     ext;
//  };

//  ===========================================================================
public struct ExtendedResult: XDREncodable {
  public var fulfilled: Bool
  public var typeExt: ExtendedResultTypeExt
  public var ext: ExtendedResultExt

  public init(
      fulfilled: Bool,
      typeExt: ExtendedResultTypeExt,
      ext: ExtendedResultExt) {

    self.fulfilled = fulfilled
    self.typeExt = typeExt
    self.ext = ext
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.fulfilled.toXDR())
    xdr.append(self.typeExt.toXDR())
    xdr.append(self.ext.toXDR())

    return xdr
  }

  public enum ExtendedResultTypeExt: XDRDiscriminatedUnion {
    case sale(SaleExtended)
    case none()

    public var discriminant: Int32 {
      switch self {
      case .sale: return ReviewableRequestType.sale.rawValue
      case .none: return ReviewableRequestType.none.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .sale(let data): xdr.append(data.toXDR())
      case .none(): xdr.append(Data())
      }

      return xdr
    }

  }
  public enum ExtendedResultExt: XDRDiscriminatedUnion {
    case emptyVersion()

    public var discriminant: Int32 {
      switch self {
      case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .emptyVersion(): xdr.append(Data())
      }

      return xdr
    }

  }
}

// === xdr source ============================================================

//  struct ReviewRequestOp
//  {
//  	uint64 requestID;
//  	Hash requestHash;
//  	union switch(ReviewableRequestType requestType) {
//  	case WITHDRAW:
//  		WithdrawalDetails withdrawal;
//      case LIMITS_UPDATE:
//          LimitsUpdateDetails limitsUpdate;
//  	case TWO_STEP_WITHDRAWAL:
//  		WithdrawalDetails twoStepWithdrawal;
//      case AML_ALERT:
//          AMLAlertDetails amlAlertDetails;
//      case UPDATE_KYC:
//          UpdateKYCDetails updateKYC;
//      case INVOICE:
//          BillPayDetails billPay;
//      case CONTRACT:
//          ContractDetails contract;
//  	default:
//  		void;
//  	} requestDetails;
//  	ReviewRequestOpAction action;
//  	longstring reason;
//  	// reserved for future use
//      union switch (LedgerVersion v)
//      {
//      case EMPTY_VERSION:
//          void;
//      case ADD_TASKS_TO_REVIEWABLE_REQUEST:
//          ReviewDetails reviewDetails;
//      }
//      ext;
//  };

//  ===========================================================================
public struct ReviewRequestOp: XDREncodable {
  public var requestID: Uint64
  public var requestHash: Hash
  public var requestDetails: ReviewRequestOpRequestDetails
  public var action: ReviewRequestOpAction
  public var reason: Longstring
  public var ext: ReviewRequestOpExt

  public init(
      requestID: Uint64,
      requestHash: Hash,
      requestDetails: ReviewRequestOpRequestDetails,
      action: ReviewRequestOpAction,
      reason: Longstring,
      ext: ReviewRequestOpExt) {

    self.requestID = requestID
    self.requestHash = requestHash
    self.requestDetails = requestDetails
    self.action = action
    self.reason = reason
    self.ext = ext
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.requestID.toXDR())
    xdr.append(self.requestHash.toXDR())
    xdr.append(self.requestDetails.toXDR())
    xdr.append(self.action.toXDR())
    xdr.append(self.reason.toXDR())
    xdr.append(self.ext.toXDR())

    return xdr
  }

  public enum ReviewRequestOpRequestDetails: XDRDiscriminatedUnion {
    case withdraw(WithdrawalDetails)
    case limitsUpdate(LimitsUpdateDetails)
    case twoStepWithdrawal(WithdrawalDetails)
    case amlAlert(AMLAlertDetails)
    case updateKyc(UpdateKYCDetails)
    case invoice(BillPayDetails)
    case contract(ContractDetails)

    public var discriminant: Int32 {
      switch self {
      case .withdraw: return ReviewableRequestType.withdraw.rawValue
      case .limitsUpdate: return ReviewableRequestType.limitsUpdate.rawValue
      case .twoStepWithdrawal: return ReviewableRequestType.twoStepWithdrawal.rawValue
      case .amlAlert: return ReviewableRequestType.amlAlert.rawValue
      case .updateKyc: return ReviewableRequestType.updateKyc.rawValue
      case .invoice: return ReviewableRequestType.invoice.rawValue
      case .contract: return ReviewableRequestType.contract.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .withdraw(let data): xdr.append(data.toXDR())
      case .limitsUpdate(let data): xdr.append(data.toXDR())
      case .twoStepWithdrawal(let data): xdr.append(data.toXDR())
      case .amlAlert(let data): xdr.append(data.toXDR())
      case .updateKyc(let data): xdr.append(data.toXDR())
      case .invoice(let data): xdr.append(data.toXDR())
      case .contract(let data): xdr.append(data.toXDR())
      }

      return xdr
    }

  }
  public enum ReviewRequestOpExt: XDRDiscriminatedUnion {
    case emptyVersion()
    case addTasksToReviewableRequest(ReviewDetails)

    public var discriminant: Int32 {
      switch self {
      case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
      case .addTasksToReviewableRequest: return LedgerVersion.addTasksToReviewableRequest.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .emptyVersion(): xdr.append(Data())
      case .addTasksToReviewableRequest(let data): xdr.append(data.toXDR())
      }

      return xdr
    }

  }
}

// === xdr source ============================================================

//  enum ReviewRequestResultCode
//  {
//      // Codes considered as "success" for the operation
//      SUCCESS = 0,
//  
//      // Codes considered as "failure" for the operation
//      INVALID_REASON = -1,        // reason must be empty if approving and not empty if rejecting
//  	INVALID_ACTION = -2,
//  	HASH_MISMATCHED = -3,
//  	NOT_FOUND = -4,
//  	TYPE_MISMATCHED = -5,
//  	REJECT_NOT_ALLOWED = -6, // reject not allowed, use permanent reject
//  	INVALID_EXTERNAL_DETAILS = -7,
//  	REQUESTOR_IS_BLOCKED = -8,
//  	PERMANENT_REJECT_NOT_ALLOWED = -9, // permanent reject not allowed, use reject
//  
//  	// Asset requests
//  	ASSET_ALREADY_EXISTS = -20,
//  	ASSET_DOES_NOT_EXISTS = -21,
//  
//  	// Issuance requests
//  	MAX_ISSUANCE_AMOUNT_EXCEEDED = -40,
//  	INSUFFICIENT_AVAILABLE_FOR_ISSUANCE_AMOUNT = -41,
//  	FULL_LINE = -42, // can't fund balance - total funds exceed UINT64_MAX
//  	SYSTEM_TASKS_NOT_ALLOWED = -43,
//  
//  	// Sale creation requests
//  	BASE_ASSET_DOES_NOT_EXISTS = -50,
//  	HARD_CAP_WILL_EXCEED_MAX_ISSUANCE = -51,
//  	INSUFFICIENT_PREISSUED_FOR_HARD_CAP = -52,
//  
//  	// Update KYC requests
//  	NON_ZERO_TASKS_TO_REMOVE_NOT_ALLOWED = -60,
//  
//  	// Update sale details, end time and promotion requests
//  	SALE_NOT_FOUND = -70,
//  
//  	// Promotion update requests
//  	INVALID_SALE_STATE = -80, // sale state must be "PROMOTION"
//  
//  	// Update sale end time requests
//      INVALID_SALE_NEW_END_TIME = -90, // new end time is before start time or current ledger close time
//  
//      // Invoice requests
//      AMOUNT_MISMATCHED = -101, // amount does not match
//      DESTINATION_BALANCE_MISMATCHED = -102, // invoice balance and payment balance do not match
//      NOT_ALLOWED_ACCOUNT_DESTINATION = -103,
//      REQUIRED_SOURCE_PAY_FOR_DESTINATION = -104, // not allowed shift fee responsibility to destination
//      SOURCE_BALANCE_MISMATCHED = -105, // source balance must match invoice sender account
//      CONTRACT_NOT_FOUND = -106,
//      INVOICE_RECEIVER_BALANCE_LOCK_AMOUNT_OVERFLOW = -107,
//      INVOICE_ALREADY_APPROVED = -108,
//  
//      // codes considered as "failure" for the payment operation
//      PAYMENT_V2_MALFORMED = -110, // bad input, requestID must be > 0
//      UNDERFUNDED = -111, // not enough funds in source account
//      LINE_FULL = -112, // destination would go above their limit
//      DESTINATION_BALANCE_NOT_FOUND = -113,
//      BALANCE_ASSETS_MISMATCHED = -114,
//      SRC_BALANCE_NOT_FOUND = -115, // source balance not found
//      REFERENCE_DUPLICATION = -116,
//      STATS_OVERFLOW = -117,
//      LIMITS_EXCEEDED = -118,
//      NOT_ALLOWED_BY_ASSET_POLICY = -119,
//      INVALID_DESTINATION_FEE = -120,
//      INVALID_DESTINATION_FEE_ASSET = -121, // destination fee asset must be the same as source balance asset
//      FEE_ASSET_MISMATCHED = -122,
//      INSUFFICIENT_FEE_AMOUNT = -123,
//      BALANCE_TO_CHARGE_FEE_FROM_NOT_FOUND = -124,
//      PAYMENT_AMOUNT_IS_LESS_THAN_DEST_FEE = -125,
//      DESTINATION_ACCOUNT_NOT_FOUND = -126,
//  
//      // Limits update requests
//      CANNOT_CREATE_FOR_ACC_ID_AND_ACC_TYPE = 130, // limits cannot be created for account ID and account type simultaneously
//      INVALID_LIMITS = 131,
//  
//      // Contract requests
//      CONTRACT_DETAILS_TOO_LONG = -140 // customer details reached length limit
//  };

//  ===========================================================================
public enum ReviewRequestResultCode: Int32, XDREnum {
  case success = 0
  case invalidReason = -1
  case invalidAction = -2
  case hashMismatched = -3
  case notFound = -4
  case typeMismatched = -5
  case rejectNotAllowed = -6
  case invalidExternalDetails = -7
  case requestorIsBlocked = -8
  case permanentRejectNotAllowed = -9
  case assetAlreadyExists = -20
  case assetDoesNotExists = -21
  case maxIssuanceAmountExceeded = -40
  case insufficientAvailableForIssuanceAmount = -41
  case fullLine = -42
  case systemTasksNotAllowed = -43
  case baseAssetDoesNotExists = -50
  case hardCapWillExceedMaxIssuance = -51
  case insufficientPreissuedForHardCap = -52
  case nonZeroTasksToRemoveNotAllowed = -60
  case saleNotFound = -70
  case invalidSaleState = -80
  case invalidSaleNewEndTime = -90
  case amountMismatched = -101
  case destinationBalanceMismatched = -102
  case notAllowedAccountDestination = -103
  case requiredSourcePayForDestination = -104
  case sourceBalanceMismatched = -105
  case contractNotFound = -106
  case invoiceReceiverBalanceLockAmountOverflow = -107
  case invoiceAlreadyApproved = -108
  case paymentV2Malformed = -110
  case underfunded = -111
  case lineFull = -112
  case destinationBalanceNotFound = -113
  case balanceAssetsMismatched = -114
  case srcBalanceNotFound = -115
  case referenceDuplication = -116
  case statsOverflow = -117
  case limitsExceeded = -118
  case notAllowedByAssetPolicy = -119
  case invalidDestinationFee = -120
  case invalidDestinationFeeAsset = -121
  case feeAssetMismatched = -122
  case insufficientFeeAmount = -123
  case balanceToChargeFeeFromNotFound = -124
  case paymentAmountIsLessThanDestFee = -125
  case destinationAccountNotFound = -126
  case cannotCreateForAccIdAndAccType = 130
  case invalidLimits = 131
  case contractDetailsTooLong = -140
}

// === xdr source ============================================================

//  union ReviewRequestResult switch (ReviewRequestResultCode code)
//  {
//  case SUCCESS:
//  	struct {
//  		// reserved for future use
//  		union switch (LedgerVersion v)
//  		{
//  		case ADD_SALE_ID_REVIEW_REQUEST_RESULT:
//  		    uint64 saleID;
//  		case ADD_REVIEW_INVOICE_REQUEST_PAYMENT_RESPONSE:
//  		    PaymentV2Response paymentV2Response;
//  		case ADD_CONTRACT_ID_REVIEW_REQUEST_RESULT:
//  		    uint64 contractID;
//  		case EMPTY_VERSION:
//  			void;
//          case ADD_TASKS_TO_REVIEWABLE_REQUEST:
//              ExtendedResult extendedResult;
//  		}
//  		ext;
//  	} success;
//  default:
//      void;
//  };

//  ===========================================================================
public enum ReviewRequestResult: XDRDiscriminatedUnion {
  case success(ReviewRequestResultSuccess)

  public var discriminant: Int32 {
    switch self {
    case .success: return ReviewRequestResultCode.success.rawValue
    }
  }

  public func toXDR() -> Data {
    var xdr = Data()
          
    xdr.append(self.discriminant.toXDR())
          
    switch self {
    case .success(let data): xdr.append(data.toXDR())
    }

    return xdr
  }

  public struct ReviewRequestResultSuccess: XDREncodable {
    public var ext: ReviewRequestResultSuccessExt

    public init(
        ext: ReviewRequestResultSuccessExt) {

      self.ext = ext
    }

    public func toXDR() -> Data {
      var xdr = Data()

      xdr.append(self.ext.toXDR())

      return xdr
    }

    public enum ReviewRequestResultSuccessExt: XDRDiscriminatedUnion {
      case addSaleIdReviewRequestResult(Uint64)
      case addReviewInvoiceRequestPaymentResponse(PaymentV2Response)
      case addContractIdReviewRequestResult(Uint64)
      case emptyVersion()
      case addTasksToReviewableRequest(ExtendedResult)

      public var discriminant: Int32 {
        switch self {
        case .addSaleIdReviewRequestResult: return LedgerVersion.addSaleIdReviewRequestResult.rawValue
        case .addReviewInvoiceRequestPaymentResponse: return LedgerVersion.addReviewInvoiceRequestPaymentResponse.rawValue
        case .addContractIdReviewRequestResult: return LedgerVersion.addContractIdReviewRequestResult.rawValue
        case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
        case .addTasksToReviewableRequest: return LedgerVersion.addTasksToReviewableRequest.rawValue
        }
      }

      public func toXDR() -> Data {
        var xdr = Data()
              
        xdr.append(self.discriminant.toXDR())
              
        switch self {
        case .addSaleIdReviewRequestResult(let data): xdr.append(data.toXDR())
        case .addReviewInvoiceRequestPaymentResponse(let data): xdr.append(data.toXDR())
        case .addContractIdReviewRequestResult(let data): xdr.append(data.toXDR())
        case .emptyVersion(): xdr.append(Data())
        case .addTasksToReviewableRequest(let data): xdr.append(data.toXDR())
        }

        return xdr
      }

    }
  }
}

// === xdr source ============================================================

//  struct SetFeesOp
//      {
//          FeeEntry* fee;
//  		bool isDelete;
//  		// reserved for future use
//  		union switch (LedgerVersion v)
//  		{
//  		case EMPTY_VERSION:
//  			void;
//  		}
//  		ext;
//      };

//  ===========================================================================
public struct SetFeesOp: XDREncodable {
  public var fee: FeeEntry?
  public var isDelete: Bool
  public var ext: SetFeesOpExt

  public init(
      fee: FeeEntry?,
      isDelete: Bool,
      ext: SetFeesOpExt) {

    self.fee = fee
    self.isDelete = isDelete
    self.ext = ext
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.fee.toXDR())
    xdr.append(self.isDelete.toXDR())
    xdr.append(self.ext.toXDR())

    return xdr
  }

  public enum SetFeesOpExt: XDRDiscriminatedUnion {
    case emptyVersion()

    public var discriminant: Int32 {
      switch self {
      case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .emptyVersion(): xdr.append(Data())
      }

      return xdr
    }

  }
}

// === xdr source ============================================================

//  enum SetFeesResultCode
//      {
//          // codes considered as "success" for the operation
//          SUCCESS = 0,
//          
//          // codes considered as "failure" for the operation
//          INVALID_AMOUNT = -1,      // amount is negative
//  		INVALID_FEE_TYPE = -2,     // operation type is invalid
//          ASSET_NOT_FOUND = -3,
//          INVALID_ASSET = -4,
//          MALFORMED = -5,
//  		MALFORMED_RANGE = -6,
//  		RANGE_OVERLAP = -7,
//  		NOT_FOUND = -8,
//  		SUB_TYPE_NOT_EXIST = -9,
//  		INVALID_FEE_VERSION = -10, // version of fee entry is greater than ledger version
//  		INVALID_FEE_ASSET = -11,
//  		FEE_ASSET_NOT_ALLOWED = -12, // feeAsset can be set only if feeType is PAYMENT
//  		CROSS_ASSET_FEE_NOT_ALLOWED = -13, // feeAsset on payment fee type can differ from asset only if payment fee subtype is OUTGOING
//  		FEE_ASSET_NOT_FOUND = -14,
//  		ASSET_PAIR_NOT_FOUND = -15, // cannot create cross asset fee entry without existing asset pair
//  		INVALID_ASSET_PAIR_PRICE = -16
//      };

//  ===========================================================================
public enum SetFeesResultCode: Int32, XDREnum {
  case success = 0
  case invalidAmount = -1
  case invalidFeeType = -2
  case assetNotFound = -3
  case invalidAsset = -4
  case malformed = -5
  case malformedRange = -6
  case rangeOverlap = -7
  case notFound = -8
  case subTypeNotExist = -9
  case invalidFeeVersion = -10
  case invalidFeeAsset = -11
  case feeAssetNotAllowed = -12
  case crossAssetFeeNotAllowed = -13
  case feeAssetNotFound = -14
  case assetPairNotFound = -15
  case invalidAssetPairPrice = -16
}

// === xdr source ============================================================

//  union SetFeesResult switch (SetFeesResultCode code)
//      {
//          case SUCCESS:
//              struct {
//  				// reserved for future use
//  				union switch (LedgerVersion v)
//  				{
//  				case EMPTY_VERSION:
//  					void;
//  				}
//  				ext;
//  			} success;
//          default:
//              void;
//      };

//  ===========================================================================
public enum SetFeesResult: XDRDiscriminatedUnion {
  case success(SetFeesResultSuccess)

  public var discriminant: Int32 {
    switch self {
    case .success: return SetFeesResultCode.success.rawValue
    }
  }

  public func toXDR() -> Data {
    var xdr = Data()
          
    xdr.append(self.discriminant.toXDR())
          
    switch self {
    case .success(let data): xdr.append(data.toXDR())
    }

    return xdr
  }

  public struct SetFeesResultSuccess: XDREncodable {
    public var ext: SetFeesResultSuccessExt

    public init(
        ext: SetFeesResultSuccessExt) {

      self.ext = ext
    }

    public func toXDR() -> Data {
      var xdr = Data()

      xdr.append(self.ext.toXDR())

      return xdr
    }

    public enum SetFeesResultSuccessExt: XDRDiscriminatedUnion {
      case emptyVersion()

      public var discriminant: Int32 {
        switch self {
        case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
        }
      }

      public func toXDR() -> Data {
        var xdr = Data()
              
        xdr.append(self.discriminant.toXDR())
              
        switch self {
        case .emptyVersion(): xdr.append(Data())
        }

        return xdr
      }

    }
  }
}

// === xdr source ============================================================

//  enum ManageTrustAction
//  {
//      TRUST_ADD = 0,
//      TRUST_REMOVE = 1
//  };

//  ===========================================================================
public enum ManageTrustAction: Int32, XDREnum {
  case trustAdd = 0
  case trustRemove = 1
}

// === xdr source ============================================================

//  struct TrustData {
//      TrustEntry trust;
//      ManageTrustAction action;
//  	// reserved for future use
//  	union switch (LedgerVersion v)
//  	{
//  	case EMPTY_VERSION:
//  		void;
//  	}
//  	ext;
//  };

//  ===========================================================================
public struct TrustData: XDREncodable {
  public var trust: TrustEntry
  public var action: ManageTrustAction
  public var ext: TrustDataExt

  public init(
      trust: TrustEntry,
      action: ManageTrustAction,
      ext: TrustDataExt) {

    self.trust = trust
    self.action = action
    self.ext = ext
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.trust.toXDR())
    xdr.append(self.action.toXDR())
    xdr.append(self.ext.toXDR())

    return xdr
  }

  public enum TrustDataExt: XDRDiscriminatedUnion {
    case emptyVersion()

    public var discriminant: Int32 {
      switch self {
      case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .emptyVersion(): xdr.append(Data())
      }

      return xdr
    }

  }
}

// === xdr source ============================================================

//  struct LimitsUpdateRequestData {
//      Hash documentHash;
//      union switch (LedgerVersion v)
//      {
//      case EMPTY_VERSION:
//          void;
//      }
//      ext;
//  };

//  ===========================================================================
public struct LimitsUpdateRequestData: XDREncodable {
  public var documentHash: Hash
  public var ext: LimitsUpdateRequestDataExt

  public init(
      documentHash: Hash,
      ext: LimitsUpdateRequestDataExt) {

    self.documentHash = documentHash
    self.ext = ext
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.documentHash.toXDR())
    xdr.append(self.ext.toXDR())

    return xdr
  }

  public enum LimitsUpdateRequestDataExt: XDRDiscriminatedUnion {
    case emptyVersion()

    public var discriminant: Int32 {
      switch self {
      case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .emptyVersion(): xdr.append(Data())
      }

      return xdr
    }

  }
}

// === xdr source ============================================================

//  struct SetOptionsOp
//  {
//      // account threshold manipulation
//      uint32* masterWeight; // weight of the master account
//      uint32* lowThreshold;
//      uint32* medThreshold;
//      uint32* highThreshold;
//  
//      // Add, update or remove a signer for the account
//      // signer is deleted if the weight is 0
//      Signer* signer;
//  
//      TrustData* trustData;
//  
//      // Create LimitsUpdateRequest for account
//      LimitsUpdateRequestData* limitsUpdateRequestData;
//  
//  	// reserved for future use
//  	union switch (LedgerVersion v)
//  	{
//  	case EMPTY_VERSION:
//  		void;
//  	}
//  	ext;
//      
//  };

//  ===========================================================================
public struct SetOptionsOp: XDREncodable {
  public var masterWeight: Uint32?
  public var lowThreshold: Uint32?
  public var medThreshold: Uint32?
  public var highThreshold: Uint32?
  public var signer: Signer?
  public var trustData: TrustData?
  public var limitsUpdateRequestData: LimitsUpdateRequestData?
  public var ext: SetOptionsOpExt

  public init(
      masterWeight: Uint32?,
      lowThreshold: Uint32?,
      medThreshold: Uint32?,
      highThreshold: Uint32?,
      signer: Signer?,
      trustData: TrustData?,
      limitsUpdateRequestData: LimitsUpdateRequestData?,
      ext: SetOptionsOpExt) {

    self.masterWeight = masterWeight
    self.lowThreshold = lowThreshold
    self.medThreshold = medThreshold
    self.highThreshold = highThreshold
    self.signer = signer
    self.trustData = trustData
    self.limitsUpdateRequestData = limitsUpdateRequestData
    self.ext = ext
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.masterWeight.toXDR())
    xdr.append(self.lowThreshold.toXDR())
    xdr.append(self.medThreshold.toXDR())
    xdr.append(self.highThreshold.toXDR())
    xdr.append(self.signer.toXDR())
    xdr.append(self.trustData.toXDR())
    xdr.append(self.limitsUpdateRequestData.toXDR())
    xdr.append(self.ext.toXDR())

    return xdr
  }

  public enum SetOptionsOpExt: XDRDiscriminatedUnion {
    case emptyVersion()

    public var discriminant: Int32 {
      switch self {
      case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .emptyVersion(): xdr.append(Data())
      }

      return xdr
    }

  }
}

// === xdr source ============================================================

//  enum SetOptionsResultCode
//  {
//      // codes considered as "success" for the operation
//      SUCCESS = 0,
//      // codes considered as "failure" for the operation
//      TOO_MANY_SIGNERS = -1, // max number of signers already reached
//      THRESHOLD_OUT_OF_RANGE = -2, // bad value for weight/threshold
//      BAD_SIGNER = -3,             // signer cannot be masterkey
//      BALANCE_NOT_FOUND = -4,
//      TRUST_MALFORMED = -5,
//  	TRUST_TOO_MANY = -6,
//  	INVALID_SIGNER_VERSION = -7, // if signer version is higher than ledger version
//  	LIMITS_UPDATE_REQUEST_REFERENCE_DUPLICATION = -8
//  };

//  ===========================================================================
public enum SetOptionsResultCode: Int32, XDREnum {
  case success = 0
  case tooManySigners = -1
  case thresholdOutOfRange = -2
  case badSigner = -3
  case balanceNotFound = -4
  case trustMalformed = -5
  case trustTooMany = -6
  case invalidSignerVersion = -7
  case limitsUpdateRequestReferenceDuplication = -8
}

// === xdr source ============================================================

//  union SetOptionsResult switch (SetOptionsResultCode code)
//  {
//  case SUCCESS:
//      struct {
//          uint64 limitsUpdateRequestID;
//  		// reserved for future use
//  		union switch (LedgerVersion v)
//  		{
//  		case EMPTY_VERSION:
//  			void;
//  		}
//  		ext;
//  	} success;
//  default:
//      void;
//  };

//  ===========================================================================
public enum SetOptionsResult: XDRDiscriminatedUnion {
  case success(SetOptionsResultSuccess)

  public var discriminant: Int32 {
    switch self {
    case .success: return SetOptionsResultCode.success.rawValue
    }
  }

  public func toXDR() -> Data {
    var xdr = Data()
          
    xdr.append(self.discriminant.toXDR())
          
    switch self {
    case .success(let data): xdr.append(data.toXDR())
    }

    return xdr
  }

  public struct SetOptionsResultSuccess: XDREncodable {
    public var limitsUpdateRequestID: Uint64
    public var ext: SetOptionsResultSuccessExt

    public init(
        limitsUpdateRequestID: Uint64,
        ext: SetOptionsResultSuccessExt) {

      self.limitsUpdateRequestID = limitsUpdateRequestID
      self.ext = ext
    }

    public func toXDR() -> Data {
      var xdr = Data()

      xdr.append(self.limitsUpdateRequestID.toXDR())
      xdr.append(self.ext.toXDR())

      return xdr
    }

    public enum SetOptionsResultSuccessExt: XDRDiscriminatedUnion {
      case emptyVersion()

      public var discriminant: Int32 {
        switch self {
        case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
        }
      }

      public func toXDR() -> Data {
        var xdr = Data()
              
        xdr.append(self.discriminant.toXDR())
              
        switch self {
        case .emptyVersion(): xdr.append(Data())
        }

        return xdr
      }

    }
  }
}

// === xdr source ============================================================

//  enum ErrorCode
//  {
//      MISC = 0, // Unspecific error
//      DATA = 1, // Malformed data
//      CONF = 2, // Misconfiguration error
//      AUTH = 3, // Authentication failure
//      LOAD = 4  // System overloaded
//  };

//  ===========================================================================
public enum ErrorCode: Int32, XDREnum {
  case misc = 0
  case data = 1
  case conf = 2
  case auth = 3
  case load = 4
}

// === xdr source ============================================================

//  struct Error
//  {
//      ErrorCode code;
//      string msg<100>;
//  };

//  ===========================================================================
public struct Error: XDREncodable {
  public var code: ErrorCode
  public var msg: String

  public init(
      code: ErrorCode,
      msg: String) {

    self.code = code
    self.msg = msg
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.code.toXDR())
    xdr.append(self.msg.toXDR())

    return xdr
  }
}

// === xdr source ============================================================

//  struct AuthCert
//  {
//      Curve25519Public pubkey;
//      uint64 expiration;
//      Signature sig;
//  };

//  ===========================================================================
public struct AuthCert: XDREncodable {
  public var pubkey: Curve25519Public
  public var expiration: Uint64
  public var sig: Signature

  public init(
      pubkey: Curve25519Public,
      expiration: Uint64,
      sig: Signature) {

    self.pubkey = pubkey
    self.expiration = expiration
    self.sig = sig
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.pubkey.toXDR())
    xdr.append(self.expiration.toXDR())
    xdr.append(self.sig.toXDR())

    return xdr
  }
}

// === xdr source ============================================================

//  struct Hello
//  {
//      uint32 ledgerVersion;
//      uint32 overlayVersion;
//      uint32 overlayMinVersion;
//      Hash networkID;
//      string versionStr<100>;
//      int listeningPort;
//      NodeID peerID;
//      AuthCert cert;
//      uint256 nonce;
//  };

//  ===========================================================================
public struct Hello: XDREncodable {
  public var ledgerVersion: Uint32
  public var overlayVersion: Uint32
  public var overlayMinVersion: Uint32
  public var networkID: Hash
  public var versionStr: String
  public var listeningPort: Int32
  public var peerID: NodeID
  public var cert: AuthCert
  public var nonce: Uint256

  public init(
      ledgerVersion: Uint32,
      overlayVersion: Uint32,
      overlayMinVersion: Uint32,
      networkID: Hash,
      versionStr: String,
      listeningPort: Int32,
      peerID: NodeID,
      cert: AuthCert,
      nonce: Uint256) {

    self.ledgerVersion = ledgerVersion
    self.overlayVersion = overlayVersion
    self.overlayMinVersion = overlayMinVersion
    self.networkID = networkID
    self.versionStr = versionStr
    self.listeningPort = listeningPort
    self.peerID = peerID
    self.cert = cert
    self.nonce = nonce
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.ledgerVersion.toXDR())
    xdr.append(self.overlayVersion.toXDR())
    xdr.append(self.overlayMinVersion.toXDR())
    xdr.append(self.networkID.toXDR())
    xdr.append(self.versionStr.toXDR())
    xdr.append(self.listeningPort.toXDR())
    xdr.append(self.peerID.toXDR())
    xdr.append(self.cert.toXDR())
    xdr.append(self.nonce.toXDR())

    return xdr
  }
}

// === xdr source ============================================================

//  struct Auth
//  {
//      // Empty message, just to confirm
//      // establishment of MAC keys.
//      int unused;
//  };

//  ===========================================================================
public struct Auth: XDREncodable {
  public var unused: Int32

  public init(
      unused: Int32) {

    self.unused = unused
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.unused.toXDR())

    return xdr
  }
}

// === xdr source ============================================================

//  enum IPAddrType
//  {
//      IPv4 = 0,
//      IPv6 = 1
//  };

//  ===========================================================================
public enum IPAddrType: Int32, XDREnum {
  case ipv4 = 0
  case ipv6 = 1
}

// === xdr source ============================================================

//  struct PeerAddress
//  {
//      union switch (IPAddrType type)
//      {
//      case IPv4:
//          opaque ipv4[4];
//      case IPv6:
//          opaque ipv6[16];
//      }
//      ip;
//      uint32 port;
//      uint32 numFailures;
//  };

//  ===========================================================================
public struct PeerAddress: XDREncodable {
  public var ip: PeerAddressIp
  public var port: Uint32
  public var numFailures: Uint32

  public init(
      ip: PeerAddressIp,
      port: Uint32,
      numFailures: Uint32) {

    self.ip = ip
    self.port = port
    self.numFailures = numFailures
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.ip.toXDR())
    xdr.append(self.port.toXDR())
    xdr.append(self.numFailures.toXDR())

    return xdr
  }

  public enum PeerAddressIp: XDRDiscriminatedUnion {
    case ipv4(XDRDataFixed4)
    case ipv6(XDRDataFixed16)

    public var discriminant: Int32 {
      switch self {
      case .ipv4: return IPAddrType.ipv4.rawValue
      case .ipv6: return IPAddrType.ipv6.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .ipv4(let data): xdr.append(data.toXDR())
      case .ipv6(let data): xdr.append(data.toXDR())
      }

      return xdr
    }

  }
}

// === xdr source ============================================================

//  enum MessageType
//  {
//      ERROR_MSG = 0,
//      AUTH = 2,
//      DONT_HAVE = 3,
//  
//      GET_PEERS = 4, // gets a list of peers this guy knows about
//      PEERS = 5,
//  
//      GET_TX_SET = 6, // gets a particular txset by hash
//      TX_SET = 7,
//  
//      TRANSACTION = 8, // pass on a tx you have heard about
//  
//      // SCP
//      GET_SCP_QUORUMSET = 9,
//      SCP_QUORUMSET = 10,
//      SCP_MESSAGE = 11,
//      GET_SCP_STATE = 12,
//  
//      // new messages
//      HELLO = 13
//  };

//  ===========================================================================
public enum MessageType: Int32, XDREnum {
  case errorMsg = 0
  case auth = 2
  case dontHave = 3
  case getPeers = 4
  case peers = 5
  case getTxSet = 6
  case txSet = 7
  case transaction = 8
  case getScpQuorumset = 9
  case scpQuorumset = 10
  case scpMessage = 11
  case getScpState = 12
  case hello = 13
}

// === xdr source ============================================================

//  struct DontHave
//  {
//      MessageType type;
//      uint256 reqHash;
//  };

//  ===========================================================================
public struct DontHave: XDREncodable {
  public var type: MessageType
  public var reqHash: Uint256

  public init(
      type: MessageType,
      reqHash: Uint256) {

    self.type = type
    self.reqHash = reqHash
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.type.toXDR())
    xdr.append(self.reqHash.toXDR())

    return xdr
  }
}

// === xdr source ============================================================

//  union StellarMessage switch (MessageType type)
//  {
//  case ERROR_MSG:
//      Error error;
//  case HELLO:
//      Hello hello;
//  case AUTH:
//      Auth auth;
//  case DONT_HAVE:
//      DontHave dontHave;
//  case GET_PEERS:
//      void;
//  case PEERS:
//      PeerAddress peers<>;
//  
//  case GET_TX_SET:
//      uint256 txSetHash;
//  case TX_SET:
//      TransactionSet txSet;
//  
//  case TRANSACTION:
//      TransactionEnvelope transaction;
//  
//  // SCP
//  case GET_SCP_QUORUMSET:
//      uint256 qSetHash;
//  case SCP_QUORUMSET:
//      SCPQuorumSet qSet;
//  case SCP_MESSAGE:
//      SCPEnvelope envelope;
//  case GET_SCP_STATE:
//      uint32 getSCPLedgerSeq; // ledger seq requested ; if 0, requests the latest
//  };

//  ===========================================================================
public enum StellarMessage: XDRDiscriminatedUnion {
  case errorMsg(Error)
  case hello(Hello)
  case auth(Auth)
  case dontHave(DontHave)
  case getPeers()
  case peers([PeerAddress])
  case getTxSet(Uint256)
  case txSet(TransactionSet)
  case transaction(TransactionEnvelope)
  case getScpQuorumset(Uint256)
  case scpQuorumset(SCPQuorumSet)
  case scpMessage(SCPEnvelope)
  case getScpState(Uint32)

  public var discriminant: Int32 {
    switch self {
    case .errorMsg: return MessageType.errorMsg.rawValue
    case .hello: return MessageType.hello.rawValue
    case .auth: return MessageType.auth.rawValue
    case .dontHave: return MessageType.dontHave.rawValue
    case .getPeers: return MessageType.getPeers.rawValue
    case .peers: return MessageType.peers.rawValue
    case .getTxSet: return MessageType.getTxSet.rawValue
    case .txSet: return MessageType.txSet.rawValue
    case .transaction: return MessageType.transaction.rawValue
    case .getScpQuorumset: return MessageType.getScpQuorumset.rawValue
    case .scpQuorumset: return MessageType.scpQuorumset.rawValue
    case .scpMessage: return MessageType.scpMessage.rawValue
    case .getScpState: return MessageType.getScpState.rawValue
    }
  }

  public func toXDR() -> Data {
    var xdr = Data()
          
    xdr.append(self.discriminant.toXDR())
          
    switch self {
    case .errorMsg(let data): xdr.append(data.toXDR())
    case .hello(let data): xdr.append(data.toXDR())
    case .auth(let data): xdr.append(data.toXDR())
    case .dontHave(let data): xdr.append(data.toXDR())
    case .getPeers(): xdr.append(Data())
    case .peers(let data): xdr.append(data.toXDR())
    case .getTxSet(let data): xdr.append(data.toXDR())
    case .txSet(let data): xdr.append(data.toXDR())
    case .transaction(let data): xdr.append(data.toXDR())
    case .getScpQuorumset(let data): xdr.append(data.toXDR())
    case .scpQuorumset(let data): xdr.append(data.toXDR())
    case .scpMessage(let data): xdr.append(data.toXDR())
    case .getScpState(let data): xdr.append(data.toXDR())
    }

    return xdr
  }
}

// === xdr source ============================================================

//  union AuthenticatedMessage switch (LedgerVersion v)
//  {
//  case EMPTY_VERSION:
//      struct
//  {
//     uint64 sequence;
//     StellarMessage message;
//     HmacSha256Mac mac;
//      } v0;
//  };

//  ===========================================================================
public enum AuthenticatedMessage: XDRDiscriminatedUnion {
  case emptyVersion(AuthenticatedMessageV0)

  public var discriminant: Int32 {
    switch self {
    case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
    }
  }

  public func toXDR() -> Data {
    var xdr = Data()
          
    xdr.append(self.discriminant.toXDR())
          
    switch self {
    case .emptyVersion(let data): xdr.append(data.toXDR())
    }

    return xdr
  }

  public struct AuthenticatedMessageV0: XDREncodable {
    public var sequence: Uint64
    public var message: StellarMessage
    public var mac: HmacSha256Mac

    public init(
        sequence: Uint64,
        message: StellarMessage,
        mac: HmacSha256Mac) {

      self.sequence = sequence
      self.message = message
      self.mac = mac
    }

    public func toXDR() -> Data {
      var xdr = Data()

      xdr.append(self.sequence.toXDR())
      xdr.append(self.message.toXDR())
      xdr.append(self.mac.toXDR())

      return xdr
    }

  }
}

// === xdr source ============================================================

//  struct AMLAlertRequest {
//      BalanceID balanceID;
//      uint64 amount;
//      longstring reason;
//  	union switch (LedgerVersion v)
//      {
//      case EMPTY_VERSION:
//          void;
//      }
//      ext;
//  };

//  ===========================================================================
public struct AMLAlertRequest: XDREncodable {
  public var balanceID: BalanceID
  public var amount: Uint64
  public var reason: Longstring
  public var ext: AMLAlertRequestExt

  public init(
      balanceID: BalanceID,
      amount: Uint64,
      reason: Longstring,
      ext: AMLAlertRequestExt) {

    self.balanceID = balanceID
    self.amount = amount
    self.reason = reason
    self.ext = ext
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.balanceID.toXDR())
    xdr.append(self.amount.toXDR())
    xdr.append(self.reason.toXDR())
    xdr.append(self.ext.toXDR())

    return xdr
  }

  public enum AMLAlertRequestExt: XDRDiscriminatedUnion {
    case emptyVersion()

    public var discriminant: Int32 {
      switch self {
      case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .emptyVersion(): xdr.append(Data())
      }

      return xdr
    }

  }
}

// === xdr source ============================================================

//  struct AssetCreationRequest {
//  
//  	AssetCode code;
//  	AccountID preissuedAssetSigner;
//  	uint64 maxIssuanceAmount;
//  	uint64 initialPreissuedAmount;
//      uint32 policies;
//      longstring details;
//  
//  	// reserved for future use
//      union switch (LedgerVersion v)
//      {
//      case EMPTY_VERSION:
//          void;
//      }
//      ext;
//  };

//  ===========================================================================
public struct AssetCreationRequest: XDREncodable {
  public var code: AssetCode
  public var preissuedAssetSigner: AccountID
  public var maxIssuanceAmount: Uint64
  public var initialPreissuedAmount: Uint64
  public var policies: Uint32
  public var details: Longstring
  public var ext: AssetCreationRequestExt

  public init(
      code: AssetCode,
      preissuedAssetSigner: AccountID,
      maxIssuanceAmount: Uint64,
      initialPreissuedAmount: Uint64,
      policies: Uint32,
      details: Longstring,
      ext: AssetCreationRequestExt) {

    self.code = code
    self.preissuedAssetSigner = preissuedAssetSigner
    self.maxIssuanceAmount = maxIssuanceAmount
    self.initialPreissuedAmount = initialPreissuedAmount
    self.policies = policies
    self.details = details
    self.ext = ext
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.code.toXDR())
    xdr.append(self.preissuedAssetSigner.toXDR())
    xdr.append(self.maxIssuanceAmount.toXDR())
    xdr.append(self.initialPreissuedAmount.toXDR())
    xdr.append(self.policies.toXDR())
    xdr.append(self.details.toXDR())
    xdr.append(self.ext.toXDR())

    return xdr
  }

  public enum AssetCreationRequestExt: XDRDiscriminatedUnion {
    case emptyVersion()

    public var discriminant: Int32 {
      switch self {
      case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .emptyVersion(): xdr.append(Data())
      }

      return xdr
    }

  }
}

// === xdr source ============================================================

//  struct AssetUpdateRequest {
//  	AssetCode code;
//  	longstring details;
//  	uint32 policies;
//  
//  	// reserved for future use
//      union switch (LedgerVersion v)
//      {
//      case EMPTY_VERSION:
//          void;
//      }
//      ext;
//  };

//  ===========================================================================
public struct AssetUpdateRequest: XDREncodable {
  public var code: AssetCode
  public var details: Longstring
  public var policies: Uint32
  public var ext: AssetUpdateRequestExt

  public init(
      code: AssetCode,
      details: Longstring,
      policies: Uint32,
      ext: AssetUpdateRequestExt) {

    self.code = code
    self.details = details
    self.policies = policies
    self.ext = ext
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.code.toXDR())
    xdr.append(self.details.toXDR())
    xdr.append(self.policies.toXDR())
    xdr.append(self.ext.toXDR())

    return xdr
  }

  public enum AssetUpdateRequestExt: XDRDiscriminatedUnion {
    case emptyVersion()

    public var discriminant: Int32 {
      switch self {
      case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .emptyVersion(): xdr.append(Data())
      }

      return xdr
    }

  }
}

// === xdr source ============================================================

//  struct AssetChangePreissuedSigner {
//  	AssetCode code;
//  	AccountID accountID;
//  	// reserved for future use
//      union switch (LedgerVersion v)
//      {
//      case EMPTY_VERSION:
//          void;
//      }
//      ext;
//  };

//  ===========================================================================
public struct AssetChangePreissuedSigner: XDREncodable {
  public var code: AssetCode
  public var accountID: AccountID
  public var ext: AssetChangePreissuedSignerExt

  public init(
      code: AssetCode,
      accountID: AccountID,
      ext: AssetChangePreissuedSignerExt) {

    self.code = code
    self.accountID = accountID
    self.ext = ext
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.code.toXDR())
    xdr.append(self.accountID.toXDR())
    xdr.append(self.ext.toXDR())

    return xdr
  }

  public enum AssetChangePreissuedSignerExt: XDRDiscriminatedUnion {
    case emptyVersion()

    public var discriminant: Int32 {
      switch self {
      case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .emptyVersion(): xdr.append(Data())
      }

      return xdr
    }

  }
}

// === xdr source ============================================================

//  struct ContractRequest
//  {
//      AccountID customer;
//      AccountID escrow;
//      longstring details;
//  
//      uint64 startTime;
//      uint64 endTime;
//  
//      // reserved for future use
//      union switch (LedgerVersion v)
//      {
//      case EMPTY_VERSION:
//          void;
//      }
//      ext;
//  };

//  ===========================================================================
public struct ContractRequest: XDREncodable {
  public var customer: AccountID
  public var escrow: AccountID
  public var details: Longstring
  public var startTime: Uint64
  public var endTime: Uint64
  public var ext: ContractRequestExt

  public init(
      customer: AccountID,
      escrow: AccountID,
      details: Longstring,
      startTime: Uint64,
      endTime: Uint64,
      ext: ContractRequestExt) {

    self.customer = customer
    self.escrow = escrow
    self.details = details
    self.startTime = startTime
    self.endTime = endTime
    self.ext = ext
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.customer.toXDR())
    xdr.append(self.escrow.toXDR())
    xdr.append(self.details.toXDR())
    xdr.append(self.startTime.toXDR())
    xdr.append(self.endTime.toXDR())
    xdr.append(self.ext.toXDR())

    return xdr
  }

  public enum ContractRequestExt: XDRDiscriminatedUnion {
    case emptyVersion()

    public var discriminant: Int32 {
      switch self {
      case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .emptyVersion(): xdr.append(Data())
      }

      return xdr
    }

  }
}

// === xdr source ============================================================

//  struct InvoiceRequest
//  {
//      AssetCode asset;
//      uint64 amount; // not allowed to set 0
//      BalanceID senderBalance;
//      BalanceID receiverBalance;
//  
//      uint64 *contractID;
//      bool isApproved;
//      longstring details;
//  
//      // reserved for future use
//      union switch (LedgerVersion v)
//      {
//      case EMPTY_VERSION:
//          void;
//      }
//      ext;
//  };

//  ===========================================================================
public struct InvoiceRequest: XDREncodable {
  public var asset: AssetCode
  public var amount: Uint64
  public var senderBalance: BalanceID
  public var receiverBalance: BalanceID
  public var contractID: Uint64?
  public var isApproved: Bool
  public var details: Longstring
  public var ext: InvoiceRequestExt

  public init(
      asset: AssetCode,
      amount: Uint64,
      senderBalance: BalanceID,
      receiverBalance: BalanceID,
      contractID: Uint64?,
      isApproved: Bool,
      details: Longstring,
      ext: InvoiceRequestExt) {

    self.asset = asset
    self.amount = amount
    self.senderBalance = senderBalance
    self.receiverBalance = receiverBalance
    self.contractID = contractID
    self.isApproved = isApproved
    self.details = details
    self.ext = ext
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.asset.toXDR())
    xdr.append(self.amount.toXDR())
    xdr.append(self.senderBalance.toXDR())
    xdr.append(self.receiverBalance.toXDR())
    xdr.append(self.contractID.toXDR())
    xdr.append(self.isApproved.toXDR())
    xdr.append(self.details.toXDR())
    xdr.append(self.ext.toXDR())

    return xdr
  }

  public enum InvoiceRequestExt: XDRDiscriminatedUnion {
    case emptyVersion()

    public var discriminant: Int32 {
      switch self {
      case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .emptyVersion(): xdr.append(Data())
      }

      return xdr
    }

  }
}

// === xdr source ============================================================

//  struct PreIssuanceRequest {
//  	AssetCode asset;
//  	uint64 amount;
//  	DecoratedSignature signature;
//  	string64 reference;
//  
//  	// reserved for future use
//      union switch (LedgerVersion v)
//      {
//      case EMPTY_VERSION:
//          void;
//      }
//      ext;
//  };

//  ===========================================================================
public struct PreIssuanceRequest: XDREncodable {
  public var asset: AssetCode
  public var amount: Uint64
  public var signature: DecoratedSignature
  public var reference: String64
  public var ext: PreIssuanceRequestExt

  public init(
      asset: AssetCode,
      amount: Uint64,
      signature: DecoratedSignature,
      reference: String64,
      ext: PreIssuanceRequestExt) {

    self.asset = asset
    self.amount = amount
    self.signature = signature
    self.reference = reference
    self.ext = ext
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.asset.toXDR())
    xdr.append(self.amount.toXDR())
    xdr.append(self.signature.toXDR())
    xdr.append(self.reference.toXDR())
    xdr.append(self.ext.toXDR())

    return xdr
  }

  public enum PreIssuanceRequestExt: XDRDiscriminatedUnion {
    case emptyVersion()

    public var discriminant: Int32 {
      switch self {
      case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .emptyVersion(): xdr.append(Data())
      }

      return xdr
    }

  }
}

// === xdr source ============================================================

//  struct IssuanceRequest {
//  	AssetCode asset;
//  	uint64 amount;
//  	BalanceID receiver;
//  	longstring externalDetails; // details of the issuance (External system id, etc.)
//  	Fee fee; //totalFee to be payed (calculated automatically)
//  	// reserved for future use
//      union switch (LedgerVersion v)
//      {
//      case EMPTY_VERSION:
//          void;
//      }
//      ext;
//  };

//  ===========================================================================
public struct IssuanceRequest: XDREncodable {
  public var asset: AssetCode
  public var amount: Uint64
  public var receiver: BalanceID
  public var externalDetails: Longstring
  public var fee: Fee
  public var ext: IssuanceRequestExt

  public init(
      asset: AssetCode,
      amount: Uint64,
      receiver: BalanceID,
      externalDetails: Longstring,
      fee: Fee,
      ext: IssuanceRequestExt) {

    self.asset = asset
    self.amount = amount
    self.receiver = receiver
    self.externalDetails = externalDetails
    self.fee = fee
    self.ext = ext
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.asset.toXDR())
    xdr.append(self.amount.toXDR())
    xdr.append(self.receiver.toXDR())
    xdr.append(self.externalDetails.toXDR())
    xdr.append(self.fee.toXDR())
    xdr.append(self.ext.toXDR())

    return xdr
  }

  public enum IssuanceRequestExt: XDRDiscriminatedUnion {
    case emptyVersion()

    public var discriminant: Int32 {
      switch self {
      case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .emptyVersion(): xdr.append(Data())
      }

      return xdr
    }

  }
}

// === xdr source ============================================================

//  struct LimitsUpdateRequest {
//      Hash deprecatedDocumentHash;
//  
//      // reserved for future use
//      union switch (LedgerVersion v)
//      {
//      case EMPTY_VERSION:
//          void;
//      case LIMITS_UPDATE_REQUEST_DEPRECATED_DOCUMENT_HASH:
//          longstring details;
//      }
//      ext;
//  };

//  ===========================================================================
public struct LimitsUpdateRequest: XDREncodable {
  public var deprecatedDocumentHash: Hash
  public var ext: LimitsUpdateRequestExt

  public init(
      deprecatedDocumentHash: Hash,
      ext: LimitsUpdateRequestExt) {

    self.deprecatedDocumentHash = deprecatedDocumentHash
    self.ext = ext
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.deprecatedDocumentHash.toXDR())
    xdr.append(self.ext.toXDR())

    return xdr
  }

  public enum LimitsUpdateRequestExt: XDRDiscriminatedUnion {
    case emptyVersion()
    case limitsUpdateRequestDeprecatedDocumentHash(Longstring)

    public var discriminant: Int32 {
      switch self {
      case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
      case .limitsUpdateRequestDeprecatedDocumentHash: return LedgerVersion.limitsUpdateRequestDeprecatedDocumentHash.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .emptyVersion(): xdr.append(Data())
      case .limitsUpdateRequestDeprecatedDocumentHash(let data): xdr.append(data.toXDR())
      }

      return xdr
    }

  }
}

// === xdr source ============================================================

//  struct SaleCreationRequestQuoteAsset {
//  	AssetCode quoteAsset; // asset in which participation will be accepted
//  	uint64 price; // price for 1 baseAsset in terms of quote asset
//  	union switch (LedgerVersion v)
//      {
//      case EMPTY_VERSION:
//          void;
//      }
//      ext;
//  };

//  ===========================================================================
public struct SaleCreationRequestQuoteAsset: XDREncodable {
  public var quoteAsset: AssetCode
  public var price: Uint64
  public var ext: SaleCreationRequestQuoteAssetExt

  public init(
      quoteAsset: AssetCode,
      price: Uint64,
      ext: SaleCreationRequestQuoteAssetExt) {

    self.quoteAsset = quoteAsset
    self.price = price
    self.ext = ext
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.quoteAsset.toXDR())
    xdr.append(self.price.toXDR())
    xdr.append(self.ext.toXDR())

    return xdr
  }

  public enum SaleCreationRequestQuoteAssetExt: XDRDiscriminatedUnion {
    case emptyVersion()

    public var discriminant: Int32 {
      switch self {
      case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .emptyVersion(): xdr.append(Data())
      }

      return xdr
    }

  }
}

// === xdr source ============================================================

//  struct SaleCreationRequest {
//  	AssetCode baseAsset; // asset for which sale will be performed
//  	AssetCode defaultQuoteAsset; // asset for soft and hard cap
//  	uint64 startTime; // start time of the sale
//  	uint64 endTime; // close time of the sale
//  	uint64 softCap; // minimum amount of quote asset to be received at which sale will be considered a successful
//  	uint64 hardCap; // max amount of quote asset to be received
//  	longstring details; // sale specific details
//  
//  	SaleCreationRequestQuoteAsset quoteAssets<100>;
//  
//  	union switch (LedgerVersion v)
//      {
//      case EMPTY_VERSION:
//          void;
//  	case TYPED_SALE:
//  		SaleTypeExt saleTypeExt;
//      case ALLOW_TO_SPECIFY_REQUIRED_BASE_ASSET_AMOUNT_FOR_HARD_CAP:
//          struct {
//              SaleTypeExt saleTypeExt;
//              uint64 requiredBaseAssetForHardCap;
//          } extV2;
//  	case STATABLE_SALES:
//  		struct {
//  			SaleTypeExt saleTypeExt;
//              uint64 requiredBaseAssetForHardCap;
//  			SaleState state;
//  		} extV3;
//      }
//      ext;
//  };

//  ===========================================================================
public struct SaleCreationRequest: XDREncodable {
  public var baseAsset: AssetCode
  public var defaultQuoteAsset: AssetCode
  public var startTime: Uint64
  public var endTime: Uint64
  public var softCap: Uint64
  public var hardCap: Uint64
  public var details: Longstring
  public var quoteAssets: [SaleCreationRequestQuoteAsset]
  public var ext: SaleCreationRequestExt

  public init(
      baseAsset: AssetCode,
      defaultQuoteAsset: AssetCode,
      startTime: Uint64,
      endTime: Uint64,
      softCap: Uint64,
      hardCap: Uint64,
      details: Longstring,
      quoteAssets: [SaleCreationRequestQuoteAsset],
      ext: SaleCreationRequestExt) {

    self.baseAsset = baseAsset
    self.defaultQuoteAsset = defaultQuoteAsset
    self.startTime = startTime
    self.endTime = endTime
    self.softCap = softCap
    self.hardCap = hardCap
    self.details = details
    self.quoteAssets = quoteAssets
    self.ext = ext
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.baseAsset.toXDR())
    xdr.append(self.defaultQuoteAsset.toXDR())
    xdr.append(self.startTime.toXDR())
    xdr.append(self.endTime.toXDR())
    xdr.append(self.softCap.toXDR())
    xdr.append(self.hardCap.toXDR())
    xdr.append(self.details.toXDR())
    xdr.append(self.quoteAssets.toXDR())
    xdr.append(self.ext.toXDR())

    return xdr
  }

  public enum SaleCreationRequestExt: XDRDiscriminatedUnion {
    case emptyVersion()
    case typedSale(SaleTypeExt)
    case allowToSpecifyRequiredBaseAssetAmountForHardCap(SaleCreationRequestExtV2)
    case statableSales(SaleCreationRequestExtV3)

    public var discriminant: Int32 {
      switch self {
      case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
      case .typedSale: return LedgerVersion.typedSale.rawValue
      case .allowToSpecifyRequiredBaseAssetAmountForHardCap: return LedgerVersion.allowToSpecifyRequiredBaseAssetAmountForHardCap.rawValue
      case .statableSales: return LedgerVersion.statableSales.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .emptyVersion(): xdr.append(Data())
      case .typedSale(let data): xdr.append(data.toXDR())
      case .allowToSpecifyRequiredBaseAssetAmountForHardCap(let data): xdr.append(data.toXDR())
      case .statableSales(let data): xdr.append(data.toXDR())
      }

      return xdr
    }

    public struct SaleCreationRequestExtV2: XDREncodable {
      public var saleTypeExt: SaleTypeExt
      public var requiredBaseAssetForHardCap: Uint64

      public init(
          saleTypeExt: SaleTypeExt,
          requiredBaseAssetForHardCap: Uint64) {

        self.saleTypeExt = saleTypeExt
        self.requiredBaseAssetForHardCap = requiredBaseAssetForHardCap
      }

      public func toXDR() -> Data {
        var xdr = Data()

        xdr.append(self.saleTypeExt.toXDR())
        xdr.append(self.requiredBaseAssetForHardCap.toXDR())

        return xdr
      }

    }
    public struct SaleCreationRequestExtV3: XDREncodable {
      public var saleTypeExt: SaleTypeExt
      public var requiredBaseAssetForHardCap: Uint64
      public var state: SaleState

      public init(
          saleTypeExt: SaleTypeExt,
          requiredBaseAssetForHardCap: Uint64,
          state: SaleState) {

        self.saleTypeExt = saleTypeExt
        self.requiredBaseAssetForHardCap = requiredBaseAssetForHardCap
        self.state = state
      }

      public func toXDR() -> Data {
        var xdr = Data()

        xdr.append(self.saleTypeExt.toXDR())
        xdr.append(self.requiredBaseAssetForHardCap.toXDR())
        xdr.append(self.state.toXDR())

        return xdr
      }

    }
  }
}

// === xdr source ============================================================

//  struct UpdateKYCRequest {
//  	AccountID accountToUpdateKYC;
//  	AccountType accountTypeToSet;
//  	uint32 kycLevel;
//  	longstring kycData;
//  
//  	// Tasks are represented by a bit mask. Each flag(task) in mask refers to specific KYC data validity checker
//  	uint32 allTasks;
//  	uint32 pendingTasks;
//  
//  	// Sequence number increases when request is rejected
//  	uint32 sequenceNumber;
//  
//  	// External details vector consists of comments written by KYC data validity checkers
//  	longstring externalDetails<>;
//  
//  	// Reserved for future use
//      union switch (LedgerVersion v)
//      {
//      case EMPTY_VERSION:
//          void;
//      }
//      ext;
//  };

//  ===========================================================================
public struct UpdateKYCRequest: XDREncodable {
  public var accountToUpdateKYC: AccountID
  public var accountTypeToSet: AccountType
  public var kycLevel: Uint32
  public var kycData: Longstring
  public var allTasks: Uint32
  public var pendingTasks: Uint32
  public var sequenceNumber: Uint32
  public var externalDetails: [Longstring]
  public var ext: UpdateKYCRequestExt

  public init(
      accountToUpdateKYC: AccountID,
      accountTypeToSet: AccountType,
      kycLevel: Uint32,
      kycData: Longstring,
      allTasks: Uint32,
      pendingTasks: Uint32,
      sequenceNumber: Uint32,
      externalDetails: [Longstring],
      ext: UpdateKYCRequestExt) {

    self.accountToUpdateKYC = accountToUpdateKYC
    self.accountTypeToSet = accountTypeToSet
    self.kycLevel = kycLevel
    self.kycData = kycData
    self.allTasks = allTasks
    self.pendingTasks = pendingTasks
    self.sequenceNumber = sequenceNumber
    self.externalDetails = externalDetails
    self.ext = ext
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.accountToUpdateKYC.toXDR())
    xdr.append(self.accountTypeToSet.toXDR())
    xdr.append(self.kycLevel.toXDR())
    xdr.append(self.kycData.toXDR())
    xdr.append(self.allTasks.toXDR())
    xdr.append(self.pendingTasks.toXDR())
    xdr.append(self.sequenceNumber.toXDR())
    xdr.append(self.externalDetails.toXDR())
    xdr.append(self.ext.toXDR())

    return xdr
  }

  public enum UpdateKYCRequestExt: XDRDiscriminatedUnion {
    case emptyVersion()

    public var discriminant: Int32 {
      switch self {
      case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .emptyVersion(): xdr.append(Data())
      }

      return xdr
    }

  }
}

// === xdr source ============================================================

//  struct PromotionUpdateRequest {
//      uint64 promotionID;
//      SaleCreationRequest newPromotionData;
//  
//      union switch (LedgerVersion v)
//      {
//      case EMPTY_VERSION:
//          void;
//      }
//      ext;
//  };

//  ===========================================================================
public struct PromotionUpdateRequest: XDREncodable {
  public var promotionID: Uint64
  public var newPromotionData: SaleCreationRequest
  public var ext: PromotionUpdateRequestExt

  public init(
      promotionID: Uint64,
      newPromotionData: SaleCreationRequest,
      ext: PromotionUpdateRequestExt) {

    self.promotionID = promotionID
    self.newPromotionData = newPromotionData
    self.ext = ext
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.promotionID.toXDR())
    xdr.append(self.newPromotionData.toXDR())
    xdr.append(self.ext.toXDR())

    return xdr
  }

  public enum PromotionUpdateRequestExt: XDRDiscriminatedUnion {
    case emptyVersion()

    public var discriminant: Int32 {
      switch self {
      case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .emptyVersion(): xdr.append(Data())
      }

      return xdr
    }

  }
}

// === xdr source ============================================================

//  struct UpdateSaleDetailsRequest {
//      uint64 saleID; // ID of sale to update details
//      longstring newDetails;
//  
//      // Reserved for future use
//      union switch (LedgerVersion v)
//      {
//      case EMPTY_VERSION:
//          void;
//      }
//      ext;
//  };

//  ===========================================================================
public struct UpdateSaleDetailsRequest: XDREncodable {
  public var saleID: Uint64
  public var newDetails: Longstring
  public var ext: UpdateSaleDetailsRequestExt

  public init(
      saleID: Uint64,
      newDetails: Longstring,
      ext: UpdateSaleDetailsRequestExt) {

    self.saleID = saleID
    self.newDetails = newDetails
    self.ext = ext
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.saleID.toXDR())
    xdr.append(self.newDetails.toXDR())
    xdr.append(self.ext.toXDR())

    return xdr
  }

  public enum UpdateSaleDetailsRequestExt: XDRDiscriminatedUnion {
    case emptyVersion()

    public var discriminant: Int32 {
      switch self {
      case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .emptyVersion(): xdr.append(Data())
      }

      return xdr
    }

  }
}

// === xdr source ============================================================

//  struct UpdateSaleEndTimeRequest {
//      uint64 saleID; // ID of the sale to update end time
//      uint64 newEndTime;
//  
//      // Reserved for future use
//      union switch (LedgerVersion v)
//      {
//      case EMPTY_VERSION:
//          void;
//      }
//      ext;
//  };

//  ===========================================================================
public struct UpdateSaleEndTimeRequest: XDREncodable {
  public var saleID: Uint64
  public var newEndTime: Uint64
  public var ext: UpdateSaleEndTimeRequestExt

  public init(
      saleID: Uint64,
      newEndTime: Uint64,
      ext: UpdateSaleEndTimeRequestExt) {

    self.saleID = saleID
    self.newEndTime = newEndTime
    self.ext = ext
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.saleID.toXDR())
    xdr.append(self.newEndTime.toXDR())
    xdr.append(self.ext.toXDR())

    return xdr
  }

  public enum UpdateSaleEndTimeRequestExt: XDRDiscriminatedUnion {
    case emptyVersion()

    public var discriminant: Int32 {
      switch self {
      case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .emptyVersion(): xdr.append(Data())
      }

      return xdr
    }

  }
}

// === xdr source ============================================================

//  enum WithdrawalType {
//  	AUTO_CONVERSION = 0
//  };

//  ===========================================================================
public enum WithdrawalType: Int32, XDREnum {
  case autoConversion = 0
}

// === xdr source ============================================================

//  struct AutoConversionWithdrawalDetails {
//  	AssetCode destAsset; // asset in which withdrawal will be converted
//  	uint64 expectedAmount; // expected amount to be received in specified asset
//  
//  	union switch (LedgerVersion v)
//      {
//      case EMPTY_VERSION:
//          void;
//      }
//      ext;
//  };

//  ===========================================================================
public struct AutoConversionWithdrawalDetails: XDREncodable {
  public var destAsset: AssetCode
  public var expectedAmount: Uint64
  public var ext: AutoConversionWithdrawalDetailsExt

  public init(
      destAsset: AssetCode,
      expectedAmount: Uint64,
      ext: AutoConversionWithdrawalDetailsExt) {

    self.destAsset = destAsset
    self.expectedAmount = expectedAmount
    self.ext = ext
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.destAsset.toXDR())
    xdr.append(self.expectedAmount.toXDR())
    xdr.append(self.ext.toXDR())

    return xdr
  }

  public enum AutoConversionWithdrawalDetailsExt: XDRDiscriminatedUnion {
    case emptyVersion()

    public var discriminant: Int32 {
      switch self {
      case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .emptyVersion(): xdr.append(Data())
      }

      return xdr
    }

  }
}

// === xdr source ============================================================

//  struct WithdrawalRequest {
//  	BalanceID balance; // balance id from which withdrawal will be performed
//      uint64 amount; // amount to be withdrawn
//      uint64 universalAmount; // amount in stats asset
//  	Fee fee; // expected fee to be paid
//      longstring externalDetails; // details of the withdrawal (External system id, etc.)
//  	longstring preConfirmationDetails; // details provided by PSIM if two step withdrwal is required
//  	union switch (WithdrawalType withdrawalType) {
//  	case AUTO_CONVERSION:
//  		AutoConversionWithdrawalDetails autoConversion;
//  	} details;
//  
//  	union switch (LedgerVersion v)
//      {
//      case EMPTY_VERSION:
//          void;
//      }
//      ext;
//  };

//  ===========================================================================
public struct WithdrawalRequest: XDREncodable {
  public var balance: BalanceID
  public var amount: Uint64
  public var universalAmount: Uint64
  public var fee: Fee
  public var externalDetails: Longstring
  public var preConfirmationDetails: Longstring
  public var details: WithdrawalRequestDetails
  public var ext: WithdrawalRequestExt

  public init(
      balance: BalanceID,
      amount: Uint64,
      universalAmount: Uint64,
      fee: Fee,
      externalDetails: Longstring,
      preConfirmationDetails: Longstring,
      details: WithdrawalRequestDetails,
      ext: WithdrawalRequestExt) {

    self.balance = balance
    self.amount = amount
    self.universalAmount = universalAmount
    self.fee = fee
    self.externalDetails = externalDetails
    self.preConfirmationDetails = preConfirmationDetails
    self.details = details
    self.ext = ext
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.balance.toXDR())
    xdr.append(self.amount.toXDR())
    xdr.append(self.universalAmount.toXDR())
    xdr.append(self.fee.toXDR())
    xdr.append(self.externalDetails.toXDR())
    xdr.append(self.preConfirmationDetails.toXDR())
    xdr.append(self.details.toXDR())
    xdr.append(self.ext.toXDR())

    return xdr
  }

  public enum WithdrawalRequestDetails: XDRDiscriminatedUnion {
    case autoConversion(AutoConversionWithdrawalDetails)

    public var discriminant: Int32 {
      switch self {
      case .autoConversion: return WithdrawalType.autoConversion.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .autoConversion(let data): xdr.append(data.toXDR())
      }

      return xdr
    }

  }
  public enum WithdrawalRequestExt: XDRDiscriminatedUnion {
    case emptyVersion()

    public var discriminant: Int32 {
      switch self {
      case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .emptyVersion(): xdr.append(Data())
      }

      return xdr
    }

  }
}

// === xdr source ============================================================

//  struct Operation
//  {
//      // sourceAccount is the account used to run the operation
//      // if not set, the runtime defaults to "sourceAccount" specified at
//      // the transaction level
//      AccountID* sourceAccount;
//  
//      union switch (OperationType type)
//      {
//      case CREATE_ACCOUNT:
//          CreateAccountOp createAccountOp;
//      case PAYMENT:
//          PaymentOp paymentOp;
//      case SET_OPTIONS:
//          SetOptionsOp setOptionsOp;
//  	case CREATE_ISSUANCE_REQUEST:
//  		CreateIssuanceRequestOp createIssuanceRequestOp;
//      case SET_FEES:
//          SetFeesOp setFeesOp;
//  	case MANAGE_ACCOUNT:
//  		ManageAccountOp manageAccountOp;
//  	case CREATE_WITHDRAWAL_REQUEST:
//  		CreateWithdrawalRequestOp createWithdrawalRequestOp;
//  	case MANAGE_BALANCE:
//  		ManageBalanceOp manageBalanceOp;
//      case MANAGE_ASSET:
//          ManageAssetOp manageAssetOp;
//      case CREATE_PREISSUANCE_REQUEST:
//          CreatePreIssuanceRequestOp createPreIssuanceRequest;
//      case MANAGE_LIMITS:
//          ManageLimitsOp manageLimitsOp;
//      case DIRECT_DEBIT:
//          DirectDebitOp directDebitOp;
//  	case MANAGE_ASSET_PAIR:
//  		ManageAssetPairOp manageAssetPairOp;
//  	case MANAGE_OFFER:
//  		ManageOfferOp manageOfferOp;
//      case MANAGE_INVOICE_REQUEST:
//          ManageInvoiceRequestOp manageInvoiceRequestOp;
//  	case REVIEW_REQUEST:
//  		ReviewRequestOp reviewRequestOp;
//  	case CREATE_SALE_REQUEST:
//  		CreateSaleCreationRequestOp createSaleCreationRequestOp;
//  	case CHECK_SALE_STATE:
//  		CheckSaleStateOp checkSaleStateOp;
//  	case PAYOUT:
//  	    PayoutOp payoutOp;
//  	case CREATE_AML_ALERT:
//  	    CreateAMLAlertRequestOp createAMLAlertRequestOp;
//  	case MANAGE_KEY_VALUE:
//  	    ManageKeyValueOp manageKeyValueOp;
//  	case CREATE_KYC_REQUEST:
//  		CreateUpdateKYCRequestOp createUpdateKYCRequestOp;
//      case MANAGE_EXTERNAL_SYSTEM_ACCOUNT_ID_POOL_ENTRY:
//          ManageExternalSystemAccountIdPoolEntryOp manageExternalSystemAccountIdPoolEntryOp;
//      case BIND_EXTERNAL_SYSTEM_ACCOUNT_ID:
//          BindExternalSystemAccountIdOp bindExternalSystemAccountIdOp;
//      case PAYMENT_V2:
//          PaymentOpV2 paymentOpV2;
//      case MANAGE_SALE:
//          ManageSaleOp manageSaleOp;
//      case CREATE_MANAGE_LIMITS_REQUEST:
//          CreateManageLimitsRequestOp createManageLimitsRequestOp;
//      case MANAGE_CONTRACT_REQUEST:
//          ManageContractRequestOp manageContractRequestOp;
//      case MANAGE_CONTRACT:
//          ManageContractOp manageContractOp;
//      case CANCEL_SALE_REQUEST:
//          CancelSaleCreationRequestOp cancelSaleCreationRequestOp;
//      case MANAGE_ACCOUNT_ROLE:
//          ManageAccountRoleOp manageAccountRoleOp;
//      case MANAGE_ACCOUNT_ROLE_PERMISSION:
//          ManageAccountRolePermissionOp manageAccountRolePermissionOp;
//      }
//      body;
//  };

//  ===========================================================================
public struct Operation: XDREncodable {
  public var sourceAccount: AccountID?
  public var body: OperationBody

  public init(
      sourceAccount: AccountID?,
      body: OperationBody) {

    self.sourceAccount = sourceAccount
    self.body = body
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.sourceAccount.toXDR())
    xdr.append(self.body.toXDR())

    return xdr
  }

  public enum OperationBody: XDRDiscriminatedUnion {
    case createAccount(CreateAccountOp)
    case payment(PaymentOp)
    case setOptions(SetOptionsOp)
    case createIssuanceRequest(CreateIssuanceRequestOp)
    case setFees(SetFeesOp)
    case manageAccount(ManageAccountOp)
    case createWithdrawalRequest(CreateWithdrawalRequestOp)
    case manageBalance(ManageBalanceOp)
    case manageAsset(ManageAssetOp)
    case createPreissuanceRequest(CreatePreIssuanceRequestOp)
    case manageLimits(ManageLimitsOp)
    case directDebit(DirectDebitOp)
    case manageAssetPair(ManageAssetPairOp)
    case manageOffer(ManageOfferOp)
    case manageInvoiceRequest(ManageInvoiceRequestOp)
    case reviewRequest(ReviewRequestOp)
    case createSaleRequest(CreateSaleCreationRequestOp)
    case checkSaleState(CheckSaleStateOp)
    case payout(PayoutOp)
    case createAmlAlert(CreateAMLAlertRequestOp)
    case manageKeyValue(ManageKeyValueOp)
    case createKycRequest(CreateUpdateKYCRequestOp)
    case manageExternalSystemAccountIdPoolEntry(ManageExternalSystemAccountIdPoolEntryOp)
    case bindExternalSystemAccountId(BindExternalSystemAccountIdOp)
    case paymentV2(PaymentOpV2)
    case manageSale(ManageSaleOp)
    case createManageLimitsRequest(CreateManageLimitsRequestOp)
    case manageContractRequest(ManageContractRequestOp)
    case manageContract(ManageContractOp)
    case cancelSaleRequest(CancelSaleCreationRequestOp)
    case manageAccountRole(ManageAccountRoleOp)
    case manageAccountRolePermission(ManageAccountRolePermissionOp)

    public var discriminant: Int32 {
      switch self {
      case .createAccount: return OperationType.createAccount.rawValue
      case .payment: return OperationType.payment.rawValue
      case .setOptions: return OperationType.setOptions.rawValue
      case .createIssuanceRequest: return OperationType.createIssuanceRequest.rawValue
      case .setFees: return OperationType.setFees.rawValue
      case .manageAccount: return OperationType.manageAccount.rawValue
      case .createWithdrawalRequest: return OperationType.createWithdrawalRequest.rawValue
      case .manageBalance: return OperationType.manageBalance.rawValue
      case .manageAsset: return OperationType.manageAsset.rawValue
      case .createPreissuanceRequest: return OperationType.createPreissuanceRequest.rawValue
      case .manageLimits: return OperationType.manageLimits.rawValue
      case .directDebit: return OperationType.directDebit.rawValue
      case .manageAssetPair: return OperationType.manageAssetPair.rawValue
      case .manageOffer: return OperationType.manageOffer.rawValue
      case .manageInvoiceRequest: return OperationType.manageInvoiceRequest.rawValue
      case .reviewRequest: return OperationType.reviewRequest.rawValue
      case .createSaleRequest: return OperationType.createSaleRequest.rawValue
      case .checkSaleState: return OperationType.checkSaleState.rawValue
      case .payout: return OperationType.payout.rawValue
      case .createAmlAlert: return OperationType.createAmlAlert.rawValue
      case .manageKeyValue: return OperationType.manageKeyValue.rawValue
      case .createKycRequest: return OperationType.createKycRequest.rawValue
      case .manageExternalSystemAccountIdPoolEntry: return OperationType.manageExternalSystemAccountIdPoolEntry.rawValue
      case .bindExternalSystemAccountId: return OperationType.bindExternalSystemAccountId.rawValue
      case .paymentV2: return OperationType.paymentV2.rawValue
      case .manageSale: return OperationType.manageSale.rawValue
      case .createManageLimitsRequest: return OperationType.createManageLimitsRequest.rawValue
      case .manageContractRequest: return OperationType.manageContractRequest.rawValue
      case .manageContract: return OperationType.manageContract.rawValue
      case .cancelSaleRequest: return OperationType.cancelSaleRequest.rawValue
      case .manageAccountRole: return OperationType.manageAccountRole.rawValue
      case .manageAccountRolePermission: return OperationType.manageAccountRolePermission.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .createAccount(let data): xdr.append(data.toXDR())
      case .payment(let data): xdr.append(data.toXDR())
      case .setOptions(let data): xdr.append(data.toXDR())
      case .createIssuanceRequest(let data): xdr.append(data.toXDR())
      case .setFees(let data): xdr.append(data.toXDR())
      case .manageAccount(let data): xdr.append(data.toXDR())
      case .createWithdrawalRequest(let data): xdr.append(data.toXDR())
      case .manageBalance(let data): xdr.append(data.toXDR())
      case .manageAsset(let data): xdr.append(data.toXDR())
      case .createPreissuanceRequest(let data): xdr.append(data.toXDR())
      case .manageLimits(let data): xdr.append(data.toXDR())
      case .directDebit(let data): xdr.append(data.toXDR())
      case .manageAssetPair(let data): xdr.append(data.toXDR())
      case .manageOffer(let data): xdr.append(data.toXDR())
      case .manageInvoiceRequest(let data): xdr.append(data.toXDR())
      case .reviewRequest(let data): xdr.append(data.toXDR())
      case .createSaleRequest(let data): xdr.append(data.toXDR())
      case .checkSaleState(let data): xdr.append(data.toXDR())
      case .payout(let data): xdr.append(data.toXDR())
      case .createAmlAlert(let data): xdr.append(data.toXDR())
      case .manageKeyValue(let data): xdr.append(data.toXDR())
      case .createKycRequest(let data): xdr.append(data.toXDR())
      case .manageExternalSystemAccountIdPoolEntry(let data): xdr.append(data.toXDR())
      case .bindExternalSystemAccountId(let data): xdr.append(data.toXDR())
      case .paymentV2(let data): xdr.append(data.toXDR())
      case .manageSale(let data): xdr.append(data.toXDR())
      case .createManageLimitsRequest(let data): xdr.append(data.toXDR())
      case .manageContractRequest(let data): xdr.append(data.toXDR())
      case .manageContract(let data): xdr.append(data.toXDR())
      case .cancelSaleRequest(let data): xdr.append(data.toXDR())
      case .manageAccountRole(let data): xdr.append(data.toXDR())
      case .manageAccountRolePermission(let data): xdr.append(data.toXDR())
      }

      return xdr
    }

  }
}

// === xdr source ============================================================

//  enum MemoType
//  {
//      MEMO_NONE = 0,
//      MEMO_TEXT = 1,
//      MEMO_ID = 2,
//      MEMO_HASH = 3,
//      MEMO_RETURN = 4
//  };

//  ===========================================================================
public enum MemoType: Int32, XDREnum {
  case memoNone = 0
  case memoText = 1
  case memoId = 2
  case memoHash = 3
  case memoReturn = 4
}

// === xdr source ============================================================

//  union Memo switch (MemoType type)
//  {
//  case MEMO_NONE:
//      void;
//  case MEMO_TEXT:
//      string text<28>;
//  case MEMO_ID:
//      uint64 id;
//  case MEMO_HASH:
//      Hash hash; // the hash of what to pull from the content server
//  case MEMO_RETURN:
//      Hash retHash; // the hash of the tx you are rejecting
//  };

//  ===========================================================================
public enum Memo: XDRDiscriminatedUnion {
  case memoNone()
  case memoText(String)
  case memoId(Uint64)
  case memoHash(Hash)
  case memoReturn(Hash)

  public var discriminant: Int32 {
    switch self {
    case .memoNone: return MemoType.memoNone.rawValue
    case .memoText: return MemoType.memoText.rawValue
    case .memoId: return MemoType.memoId.rawValue
    case .memoHash: return MemoType.memoHash.rawValue
    case .memoReturn: return MemoType.memoReturn.rawValue
    }
  }

  public func toXDR() -> Data {
    var xdr = Data()
          
    xdr.append(self.discriminant.toXDR())
          
    switch self {
    case .memoNone(): xdr.append(Data())
    case .memoText(let data): xdr.append(data.toXDR())
    case .memoId(let data): xdr.append(data.toXDR())
    case .memoHash(let data): xdr.append(data.toXDR())
    case .memoReturn(let data): xdr.append(data.toXDR())
    }

    return xdr
  }
}

// === xdr source ============================================================

//  struct TimeBounds
//  {
//      uint64 minTime;
//      uint64 maxTime; // 0 here means no maxTime
//  };

//  ===========================================================================
public struct TimeBounds: XDREncodable {
  public var minTime: Uint64
  public var maxTime: Uint64

  public init(
      minTime: Uint64,
      maxTime: Uint64) {

    self.minTime = minTime
    self.maxTime = maxTime
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.minTime.toXDR())
    xdr.append(self.maxTime.toXDR())

    return xdr
  }
}

// === xdr source ============================================================

//  struct Transaction
//  {
//      // account used to run the transaction
//      AccountID sourceAccount;
//  
//      Salt salt;
//  
//      // validity range (inclusive) for the last ledger close time
//      TimeBounds timeBounds;
//  
//      Memo memo;
//  
//      Operation operations<100>;
//  
//      // reserved for future use
//      union switch (LedgerVersion v)
//      {
//      case EMPTY_VERSION:
//          void;
//      case ADD_TRANSACTION_FEE:
//          uint64 maxTotalFee;
//      }
//      ext;
//  };

//  ===========================================================================
public struct Transaction: XDREncodable {
  public var sourceAccount: AccountID
  public var salt: Salt
  public var timeBounds: TimeBounds
  public var memo: Memo
  public var operations: [Operation]
  public var ext: TransactionExt

  public init(
      sourceAccount: AccountID,
      salt: Salt,
      timeBounds: TimeBounds,
      memo: Memo,
      operations: [Operation],
      ext: TransactionExt) {

    self.sourceAccount = sourceAccount
    self.salt = salt
    self.timeBounds = timeBounds
    self.memo = memo
    self.operations = operations
    self.ext = ext
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.sourceAccount.toXDR())
    xdr.append(self.salt.toXDR())
    xdr.append(self.timeBounds.toXDR())
    xdr.append(self.memo.toXDR())
    xdr.append(self.operations.toXDR())
    xdr.append(self.ext.toXDR())

    return xdr
  }

  public enum TransactionExt: XDRDiscriminatedUnion {
    case emptyVersion()
    case addTransactionFee(Uint64)

    public var discriminant: Int32 {
      switch self {
      case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
      case .addTransactionFee: return LedgerVersion.addTransactionFee.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .emptyVersion(): xdr.append(Data())
      case .addTransactionFee(let data): xdr.append(data.toXDR())
      }

      return xdr
    }

  }
}

// === xdr source ============================================================

//  struct TransactionEnvelope
//  {
//      Transaction tx;
//      DecoratedSignature signatures<20>;
//  };

//  ===========================================================================
public struct TransactionEnvelope: XDREncodable {
  public var tx: Transaction
  public var signatures: [DecoratedSignature]

  public init(
      tx: Transaction,
      signatures: [DecoratedSignature]) {

    self.tx = tx
    self.signatures = signatures
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.tx.toXDR())
    xdr.append(self.signatures.toXDR())

    return xdr
  }
}

// === xdr source ============================================================

//  enum OperationResultCode
//  {
//      opINNER = 0, // inner object result is valid
//  
//      opBAD_AUTH = -1,      // too few valid signatures / wrong network
//      opNO_ACCOUNT = -2,    // source account was not found
//  	opNOT_ALLOWED = -3,   // operation is not allowed for this type of source account
//  	opACCOUNT_BLOCKED = -4, // account is blocked
//      opNO_COUNTERPARTY = -5,
//      opCOUNTERPARTY_BLOCKED = -6,
//      opCOUNTERPARTY_WRONG_TYPE = -7,
//      opBAD_AUTH_EXTRA = -8,
//      opNO_ROLE_PERMISSION = -9 // not allowed for this role of source account
//  };

//  ===========================================================================
public enum OperationResultCode: Int32, XDREnum {
  case opinner = 0
  case opbadAuth = -1
  case opnoAccount = -2
  case opnotAllowed = -3
  case opaccountBlocked = -4
  case opnoCounterparty = -5
  case opcounterpartyBlocked = -6
  case opcounterpartyWrongType = -7
  case opbadAuthExtra = -8
  case opnoRolePermission = -9
}

// === xdr source ============================================================

//  union OperationResult switch (OperationResultCode code)
//  {
//  case opINNER:
//      union switch (OperationType type)
//      {
//      case CREATE_ACCOUNT:
//          CreateAccountResult createAccountResult;
//      case PAYMENT:
//          PaymentResult paymentResult;
//      case SET_OPTIONS:
//          SetOptionsResult setOptionsResult;
//  	case CREATE_ISSUANCE_REQUEST:
//  		CreateIssuanceRequestResult createIssuanceRequestResult;
//      case SET_FEES:
//          SetFeesResult setFeesResult;
//  	case MANAGE_ACCOUNT:
//  		ManageAccountResult manageAccountResult;
//      case CREATE_WITHDRAWAL_REQUEST:
//  		CreateWithdrawalRequestResult createWithdrawalRequestResult;
//      case MANAGE_BALANCE:
//          ManageBalanceResult manageBalanceResult;
//      case MANAGE_ASSET:
//          ManageAssetResult manageAssetResult;
//      case CREATE_PREISSUANCE_REQUEST:
//          CreatePreIssuanceRequestResult createPreIssuanceRequestResult;
//      case MANAGE_LIMITS:
//          ManageLimitsResult manageLimitsResult;
//      case DIRECT_DEBIT:
//          DirectDebitResult directDebitResult;
//  	case MANAGE_ASSET_PAIR:
//  		ManageAssetPairResult manageAssetPairResult;
//  	case MANAGE_OFFER:
//  		ManageOfferResult manageOfferResult;
//  	case MANAGE_INVOICE_REQUEST:
//  		ManageInvoiceRequestResult manageInvoiceRequestResult;
//  	case REVIEW_REQUEST:
//  		ReviewRequestResult reviewRequestResult;
//  	case CREATE_SALE_REQUEST:
//  		CreateSaleCreationRequestResult createSaleCreationRequestResult;
//  	case CHECK_SALE_STATE:
//  		CheckSaleStateResult checkSaleStateResult;
//  	case PAYOUT:
//  	    PayoutResult payoutResult;
//  	case CREATE_AML_ALERT:
//  	    CreateAMLAlertRequestResult createAMLAlertRequestResult;
//  	case MANAGE_KEY_VALUE:
//  	    ManageKeyValueResult manageKeyValueResult;
//  	case CREATE_KYC_REQUEST:
//  	    CreateUpdateKYCRequestResult createUpdateKYCRequestResult;
//      case MANAGE_EXTERNAL_SYSTEM_ACCOUNT_ID_POOL_ENTRY:
//          ManageExternalSystemAccountIdPoolEntryResult manageExternalSystemAccountIdPoolEntryResult;
//      case BIND_EXTERNAL_SYSTEM_ACCOUNT_ID:
//          BindExternalSystemAccountIdResult bindExternalSystemAccountIdResult;
//      case PAYMENT_V2:
//          PaymentV2Result paymentV2Result;
//      case MANAGE_SALE:
//          ManageSaleResult manageSaleResult;
//      case CREATE_MANAGE_LIMITS_REQUEST:
//          CreateManageLimitsRequestResult createManageLimitsRequestResult;
//      case MANAGE_CONTRACT_REQUEST:
//          ManageContractRequestResult manageContractRequestResult;
//      case MANAGE_CONTRACT:
//          ManageContractResult manageContractResult;
//      case CANCEL_SALE_REQUEST:
//          CancelSaleCreationRequestResult cancelSaleCreationRequestResult;
//      case MANAGE_ACCOUNT_ROLE:
//          ManageAccountRoleResult manageAccountRoleResult;
//      case MANAGE_ACCOUNT_ROLE_PERMISSION:
//          ManageAccountRolePermissionResult manageAccountRolePermissionResult;
//      }
//      tr;
//  default:
//      void;
//  };

//  ===========================================================================
public enum OperationResult: XDRDiscriminatedUnion {
  case opinner(OperationResultTr)

  public var discriminant: Int32 {
    switch self {
    case .opinner: return OperationResultCode.opinner.rawValue
    }
  }

  public func toXDR() -> Data {
    var xdr = Data()
          
    xdr.append(self.discriminant.toXDR())
          
    switch self {
    case .opinner(let data): xdr.append(data.toXDR())
    }

    return xdr
  }

  public enum OperationResultTr: XDRDiscriminatedUnion {
    case createAccount(CreateAccountResult)
    case payment(PaymentResult)
    case setOptions(SetOptionsResult)
    case createIssuanceRequest(CreateIssuanceRequestResult)
    case setFees(SetFeesResult)
    case manageAccount(ManageAccountResult)
    case createWithdrawalRequest(CreateWithdrawalRequestResult)
    case manageBalance(ManageBalanceResult)
    case manageAsset(ManageAssetResult)
    case createPreissuanceRequest(CreatePreIssuanceRequestResult)
    case manageLimits(ManageLimitsResult)
    case directDebit(DirectDebitResult)
    case manageAssetPair(ManageAssetPairResult)
    case manageOffer(ManageOfferResult)
    case manageInvoiceRequest(ManageInvoiceRequestResult)
    case reviewRequest(ReviewRequestResult)
    case createSaleRequest(CreateSaleCreationRequestResult)
    case checkSaleState(CheckSaleStateResult)
    case payout(PayoutResult)
    case createAmlAlert(CreateAMLAlertRequestResult)
    case manageKeyValue(ManageKeyValueResult)
    case createKycRequest(CreateUpdateKYCRequestResult)
    case manageExternalSystemAccountIdPoolEntry(ManageExternalSystemAccountIdPoolEntryResult)
    case bindExternalSystemAccountId(BindExternalSystemAccountIdResult)
    case paymentV2(PaymentV2Result)
    case manageSale(ManageSaleResult)
    case createManageLimitsRequest(CreateManageLimitsRequestResult)
    case manageContractRequest(ManageContractRequestResult)
    case manageContract(ManageContractResult)
    case cancelSaleRequest(CancelSaleCreationRequestResult)
    case manageAccountRole(ManageAccountRoleResult)
    case manageAccountRolePermission(ManageAccountRolePermissionResult)

    public var discriminant: Int32 {
      switch self {
      case .createAccount: return OperationType.createAccount.rawValue
      case .payment: return OperationType.payment.rawValue
      case .setOptions: return OperationType.setOptions.rawValue
      case .createIssuanceRequest: return OperationType.createIssuanceRequest.rawValue
      case .setFees: return OperationType.setFees.rawValue
      case .manageAccount: return OperationType.manageAccount.rawValue
      case .createWithdrawalRequest: return OperationType.createWithdrawalRequest.rawValue
      case .manageBalance: return OperationType.manageBalance.rawValue
      case .manageAsset: return OperationType.manageAsset.rawValue
      case .createPreissuanceRequest: return OperationType.createPreissuanceRequest.rawValue
      case .manageLimits: return OperationType.manageLimits.rawValue
      case .directDebit: return OperationType.directDebit.rawValue
      case .manageAssetPair: return OperationType.manageAssetPair.rawValue
      case .manageOffer: return OperationType.manageOffer.rawValue
      case .manageInvoiceRequest: return OperationType.manageInvoiceRequest.rawValue
      case .reviewRequest: return OperationType.reviewRequest.rawValue
      case .createSaleRequest: return OperationType.createSaleRequest.rawValue
      case .checkSaleState: return OperationType.checkSaleState.rawValue
      case .payout: return OperationType.payout.rawValue
      case .createAmlAlert: return OperationType.createAmlAlert.rawValue
      case .manageKeyValue: return OperationType.manageKeyValue.rawValue
      case .createKycRequest: return OperationType.createKycRequest.rawValue
      case .manageExternalSystemAccountIdPoolEntry: return OperationType.manageExternalSystemAccountIdPoolEntry.rawValue
      case .bindExternalSystemAccountId: return OperationType.bindExternalSystemAccountId.rawValue
      case .paymentV2: return OperationType.paymentV2.rawValue
      case .manageSale: return OperationType.manageSale.rawValue
      case .createManageLimitsRequest: return OperationType.createManageLimitsRequest.rawValue
      case .manageContractRequest: return OperationType.manageContractRequest.rawValue
      case .manageContract: return OperationType.manageContract.rawValue
      case .cancelSaleRequest: return OperationType.cancelSaleRequest.rawValue
      case .manageAccountRole: return OperationType.manageAccountRole.rawValue
      case .manageAccountRolePermission: return OperationType.manageAccountRolePermission.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .createAccount(let data): xdr.append(data.toXDR())
      case .payment(let data): xdr.append(data.toXDR())
      case .setOptions(let data): xdr.append(data.toXDR())
      case .createIssuanceRequest(let data): xdr.append(data.toXDR())
      case .setFees(let data): xdr.append(data.toXDR())
      case .manageAccount(let data): xdr.append(data.toXDR())
      case .createWithdrawalRequest(let data): xdr.append(data.toXDR())
      case .manageBalance(let data): xdr.append(data.toXDR())
      case .manageAsset(let data): xdr.append(data.toXDR())
      case .createPreissuanceRequest(let data): xdr.append(data.toXDR())
      case .manageLimits(let data): xdr.append(data.toXDR())
      case .directDebit(let data): xdr.append(data.toXDR())
      case .manageAssetPair(let data): xdr.append(data.toXDR())
      case .manageOffer(let data): xdr.append(data.toXDR())
      case .manageInvoiceRequest(let data): xdr.append(data.toXDR())
      case .reviewRequest(let data): xdr.append(data.toXDR())
      case .createSaleRequest(let data): xdr.append(data.toXDR())
      case .checkSaleState(let data): xdr.append(data.toXDR())
      case .payout(let data): xdr.append(data.toXDR())
      case .createAmlAlert(let data): xdr.append(data.toXDR())
      case .manageKeyValue(let data): xdr.append(data.toXDR())
      case .createKycRequest(let data): xdr.append(data.toXDR())
      case .manageExternalSystemAccountIdPoolEntry(let data): xdr.append(data.toXDR())
      case .bindExternalSystemAccountId(let data): xdr.append(data.toXDR())
      case .paymentV2(let data): xdr.append(data.toXDR())
      case .manageSale(let data): xdr.append(data.toXDR())
      case .createManageLimitsRequest(let data): xdr.append(data.toXDR())
      case .manageContractRequest(let data): xdr.append(data.toXDR())
      case .manageContract(let data): xdr.append(data.toXDR())
      case .cancelSaleRequest(let data): xdr.append(data.toXDR())
      case .manageAccountRole(let data): xdr.append(data.toXDR())
      case .manageAccountRolePermission(let data): xdr.append(data.toXDR())
      }

      return xdr
    }

  }
}

// === xdr source ============================================================

//  enum TransactionResultCode
//  {
//      txSUCCESS = 0, // all operations succeeded
//  
//      txFAILED = -1, // one of the operations failed (none were applied)
//  
//      txTOO_EARLY = -2,         // ledger closeTime before minTime
//      txTOO_LATE = -3,          // ledger closeTime after maxTime
//      txMISSING_OPERATION = -4, // no operation was specified
//  
//      txBAD_AUTH = -5,             // too few valid signatures / wrong network
//      txNO_ACCOUNT = -6,           // source account not found
//      txBAD_AUTH_EXTRA = -7,       // unused signatures attached to transaction
//      txINTERNAL_ERROR = -8,       // an unknown error occured
//  	txACCOUNT_BLOCKED = -9,      // account is blocked and cannot be source of tx
//      txDUPLICATION = -10,         // if timing is stored
//      txINSUFFICIENT_FEE = -11,    // the actual total fee amount is greater than the max total fee amount, provided by the source
//      txSOURCE_UNDERFUNDED = -12,  // not enough tx fee asset on source balance
//      txCOMMISSION_LINE_FULL = -13 // commission tx fee asset balance amount overflow
//  };

//  ===========================================================================
public enum TransactionResultCode: Int32, XDREnum {
  case txsuccess = 0
  case txfailed = -1
  case txtooEarly = -2
  case txtooLate = -3
  case txmissingOperation = -4
  case txbadAuth = -5
  case txnoAccount = -6
  case txbadAuthExtra = -7
  case txinternalError = -8
  case txaccountBlocked = -9
  case txduplication = -10
  case txinsufficientFee = -11
  case txsourceUnderfunded = -12
  case txcommissionLineFull = -13
}

// === xdr source ============================================================

//  struct OperationFee
//  {
//      OperationType operationType;
//      uint64 amount;
//  
//      // reserved for future use
//      union switch (LedgerVersion v)
//      {
//      case EMPTY_VERSION:
//          void;
//      }
//      ext;
//  };

//  ===========================================================================
public struct OperationFee: XDREncodable {
  public var operationType: OperationType
  public var amount: Uint64
  public var ext: OperationFeeExt

  public init(
      operationType: OperationType,
      amount: Uint64,
      ext: OperationFeeExt) {

    self.operationType = operationType
    self.amount = amount
    self.ext = ext
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.operationType.toXDR())
    xdr.append(self.amount.toXDR())
    xdr.append(self.ext.toXDR())

    return xdr
  }

  public enum OperationFeeExt: XDRDiscriminatedUnion {
    case emptyVersion()

    public var discriminant: Int32 {
      switch self {
      case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .emptyVersion(): xdr.append(Data())
      }

      return xdr
    }

  }
}

// === xdr source ============================================================

//  struct TransactionFee
//  {
//      AssetCode assetCode;
//      OperationFee operationFees<100>;
//  
//      // reserved for future use
//      union switch (LedgerVersion v)
//      {
//      case EMPTY_VERSION:
//          void;
//      }
//      ext;
//  };

//  ===========================================================================
public struct TransactionFee: XDREncodable {
  public var assetCode: AssetCode
  public var operationFees: [OperationFee]
  public var ext: TransactionFeeExt

  public init(
      assetCode: AssetCode,
      operationFees: [OperationFee],
      ext: TransactionFeeExt) {

    self.assetCode = assetCode
    self.operationFees = operationFees
    self.ext = ext
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.assetCode.toXDR())
    xdr.append(self.operationFees.toXDR())
    xdr.append(self.ext.toXDR())

    return xdr
  }

  public enum TransactionFeeExt: XDRDiscriminatedUnion {
    case emptyVersion()

    public var discriminant: Int32 {
      switch self {
      case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .emptyVersion(): xdr.append(Data())
      }

      return xdr
    }

  }
}

// === xdr source ============================================================

//  struct TransactionResult
//  {
//      int64 feeCharged; // actual fee charged for the transaction
//  
//      union switch (TransactionResultCode code)
//      {
//      case txSUCCESS:
//      case txFAILED:
//          OperationResult results<>;
//      default:
//          void;
//      }
//      result;
//  
//      // reserved for future use
//      union switch (LedgerVersion v)
//      {
//      case EMPTY_VERSION:
//          void;
//      case ADD_TRANSACTION_FEE:
//          TransactionFee transactionFee;
//      }
//      ext;
//  };

//  ===========================================================================
public struct TransactionResult: XDREncodable {
  public var feeCharged: Int64
  public var result: TransactionResultResult
  public var ext: TransactionResultExt

  public init(
      feeCharged: Int64,
      result: TransactionResultResult,
      ext: TransactionResultExt) {

    self.feeCharged = feeCharged
    self.result = result
    self.ext = ext
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.feeCharged.toXDR())
    xdr.append(self.result.toXDR())
    xdr.append(self.ext.toXDR())

    return xdr
  }

  public enum TransactionResultResult: XDRDiscriminatedUnion {
    case txsuccess([OperationResult])
    case txfailed([OperationResult])

    public var discriminant: Int32 {
      switch self {
      case .txsuccess: return TransactionResultCode.txsuccess.rawValue
      case .txfailed: return TransactionResultCode.txfailed.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .txsuccess(let data): xdr.append(data.toXDR())
      case .txfailed(let data): xdr.append(data.toXDR())
      }

      return xdr
    }

  }
  public enum TransactionResultExt: XDRDiscriminatedUnion {
    case emptyVersion()
    case addTransactionFee(TransactionFee)

    public var discriminant: Int32 {
      switch self {
      case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
      case .addTransactionFee: return LedgerVersion.addTransactionFee.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .emptyVersion(): xdr.append(Data())
      case .addTransactionFee(let data): xdr.append(data.toXDR())
      }

      return xdr
    }

  }
}

// === xdr source ============================================================

//  typedef opaque Hash[32];

//  ===========================================================================
public typealias Hash = XDRDataFixed32

// === xdr source ============================================================

//  typedef opaque uint256[32];

//  ===========================================================================
public typealias Uint256 = XDRDataFixed32

// === xdr source ============================================================

//  typedef unsigned int uint32;

//  ===========================================================================
public typealias Uint32 = UInt32

// === xdr source ============================================================

//  typedef int int32;

//  ===========================================================================

// === xdr source ============================================================

//  typedef unsigned hyper uint64;

//  ===========================================================================
public typealias Uint64 = UInt64

// === xdr source ============================================================

//  typedef hyper int64;

//  ===========================================================================

// === xdr source ============================================================

//  enum CryptoKeyType
//  {
//      KEY_TYPE_ED25519 = 0
//  };

//  ===========================================================================
public enum CryptoKeyType: Int32, XDREnum {
  case keyTypeEd25519 = 0
}

// === xdr source ============================================================

//  enum PublicKeyType
//  {
//  	PUBLIC_KEY_TYPE_ED25519 = 0
//  };

//  ===========================================================================
public enum PublicKeyType: Int32, XDREnum {
  case publicKeyTypeEd25519 = 0
}

// === xdr source ============================================================

//  union PublicKey switch (CryptoKeyType type)
//  {
//  case KEY_TYPE_ED25519:
//      uint256 ed25519;
//  };

//  ===========================================================================
public enum PublicKey: XDRDiscriminatedUnion {
  case keyTypeEd25519(Uint256)

  public var discriminant: Int32 {
    switch self {
    case .keyTypeEd25519: return CryptoKeyType.keyTypeEd25519.rawValue
    }
  }

  public func toXDR() -> Data {
    var xdr = Data()
          
    xdr.append(self.discriminant.toXDR())
          
    switch self {
    case .keyTypeEd25519(let data): xdr.append(data.toXDR())
    }

    return xdr
  }
}

// === xdr source ============================================================

//  enum LedgerVersion {
//  	EMPTY_VERSION = 0,
//  	PASS_EXTERNAL_SYS_ACC_ID_IN_CREATE_ACC = 1,
//  	DETAILED_LEDGER_CHANGES = 2, // write more all ledger changes to transaction meta
//  	NEW_SIGNER_TYPES = 3, // use more comprehensive list of signer types
//  	TYPED_SALE = 4, // sales can have type
//  	UNIQUE_BALANCE_CREATION = 5, // allows to specify in manage balance that balance should not be created if one for such asset and account exists
//  	ASSET_PREISSUER_MIGRATION = 6,
//  	ASSET_PREISSUER_MIGRATED = 7,
//  	USE_KYC_LEVEL = 8,
//  	ERROR_ON_NON_ZERO_TASKS_TO_REMOVE_IN_REJECT_KYC = 9,
//  	ALLOW_ACCOUNT_MANAGER_TO_CHANGE_KYC = 10,
//  	CHANGE_ASSET_ISSUER_BAD_AUTH_EXTRA_FIXED = 11,
//  	AUTO_CREATE_COMMISSION_BALANCE_ON_TRANSFER = 12,
//      ALLOW_REJECT_REQUEST_OF_BLOCKED_REQUESTOR = 13,
//  	ASSET_UPDATE_CHECK_REFERENCE_EXISTS = 14,
//  	CROSS_ASSET_FEE = 15,
//  	USE_PAYMENT_V2 = 16,
//  	ALLOW_SYNDICATE_TO_UPDATE_KYC = 17,
//  	DO_NOT_BUILD_ACCOUNT_IF_VERSION_EQUALS_OR_GREATER = 18,
//  	ALLOW_TO_SPECIFY_REQUIRED_BASE_ASSET_AMOUNT_FOR_HARD_CAP = 19,
//  	KYC_RULES = 20,
//  	ALLOW_TO_CREATE_SEVERAL_SALES = 21,
//  	KEY_VALUE_POOL_ENTRY_EXPIRES_AT = 22,
//  	KEY_VALUE_UPDATE = 23,
//  	ALLOW_TO_CANCEL_SALE_PARTICIP_WITHOUT_SPECIFING_BALANCE = 24,
//  	DETAILS_MAX_LENGTH_EXTENDED = 25,
//  	ALLOW_MASTER_TO_MANAGE_SALE = 26,
//  	USE_SALE_ANTE = 27,
//  	FIX_ASSET_PAIRS_CREATION_IN_SALE_CREATION = 28,
//  	STATABLE_SALES = 29,
//  	CREATE_ONLY_STATISTICS_V2 = 30,
//  	LIMITS_UPDATE_REQUEST_DEPRECATED_DOCUMENT_HASH = 31,
//  	FIX_PAYMENT_V2_FEE = 32,
//  	ADD_SALE_ID_REVIEW_REQUEST_RESULT = 33,
//  	FIX_SET_SALE_STATE_AND_CHECK_SALE_STATE_OPS = 34, // only master allowed to set sale state, max issuance after sale closure = pending + issued
//  	FIX_UPDATE_MAX_ISSUANCE = 35,
//  	ALLOW_CLOSE_SALE_WITH_NON_ZERO_BALANCE = 36,
//  	ALLOW_TO_UPDATE_VOTING_SALES_AS_PROMOTION = 37,
//  	ALLOW_TO_ISSUE_AFTER_SALE = 38,
//  	FIX_PAYMENT_V2_SEND_TO_SELF = 39,
//  	FIX_PAYMENT_V2_DEST_ACCOUNT_NOT_FOUND = 40,
//  	FIX_CREATE_KYC_REQUEST_AUTO_APPROVE = 41,
//  	ADD_TASKS_TO_REVIEWABLE_REQUEST = 42,
//  	USE_ONLY_PAYMENT_V2 = 43,
//      ADD_REVIEW_INVOICE_REQUEST_PAYMENT_RESPONSE = 44,
//      ADD_CONTRACT_ID_REVIEW_REQUEST_RESULT = 45,
//      ALLOW_TO_UPDATE_AND_REJECT_LIMITS_UPDATE_REQUESTS = 46,
//      ADD_CUSTOMER_DETAILS_TO_CONTRACT = 47,
//      ADD_CAPITAL_DEPLOYMENT_FEE_TYPE = 48,
//      ADD_TRANSACTION_FEE = 49,
//      REPLACE_ACCOUNT_TYPES_WITH_POLICIES = 999999 // do not use it yet, there are features to be improved
//  };

//  ===========================================================================
public enum LedgerVersion: Int32, XDREnum {
  case emptyVersion = 0
  case passExternalSysAccIdInCreateAcc = 1
  case detailedLedgerChanges = 2
  case newSignerTypes = 3
  case typedSale = 4
  case uniqueBalanceCreation = 5
  case assetPreissuerMigration = 6
  case assetPreissuerMigrated = 7
  case useKycLevel = 8
  case errorOnNonZeroTasksToRemoveInRejectKyc = 9
  case allowAccountManagerToChangeKyc = 10
  case changeAssetIssuerBadAuthExtraFixed = 11
  case autoCreateCommissionBalanceOnTransfer = 12
  case allowRejectRequestOfBlockedRequestor = 13
  case assetUpdateCheckReferenceExists = 14
  case crossAssetFee = 15
  case usePaymentV2 = 16
  case allowSyndicateToUpdateKyc = 17
  case doNotBuildAccountIfVersionEqualsOrGreater = 18
  case allowToSpecifyRequiredBaseAssetAmountForHardCap = 19
  case kycRules = 20
  case allowToCreateSeveralSales = 21
  case keyValuePoolEntryExpiresAt = 22
  case keyValueUpdate = 23
  case allowToCancelSaleParticipWithoutSpecifingBalance = 24
  case detailsMaxLengthExtended = 25
  case allowMasterToManageSale = 26
  case useSaleAnte = 27
  case fixAssetPairsCreationInSaleCreation = 28
  case statableSales = 29
  case createOnlyStatisticsV2 = 30
  case limitsUpdateRequestDeprecatedDocumentHash = 31
  case fixPaymentV2Fee = 32
  case addSaleIdReviewRequestResult = 33
  case fixSetSaleStateAndCheckSaleStateOps = 34
  case fixUpdateMaxIssuance = 35
  case allowCloseSaleWithNonZeroBalance = 36
  case allowToUpdateVotingSalesAsPromotion = 37
  case allowToIssueAfterSale = 38
  case fixPaymentV2SendToSelf = 39
  case fixPaymentV2DestAccountNotFound = 40
  case fixCreateKycRequestAutoApprove = 41
  case addTasksToReviewableRequest = 42
  case useOnlyPaymentV2 = 43
  case addReviewInvoiceRequestPaymentResponse = 44
  case addContractIdReviewRequestResult = 45
  case allowToUpdateAndRejectLimitsUpdateRequests = 46
  case addCustomerDetailsToContract = 47
  case addCapitalDeploymentFeeType = 48
  case addTransactionFee = 49
  case replaceAccountTypesWithPolicies = 999999
}

// === xdr source ============================================================

//  typedef opaque Signature<64>;

//  ===========================================================================
public typealias Signature = Data

// === xdr source ============================================================

//  typedef opaque SignatureHint[4];

//  ===========================================================================
public typealias SignatureHint = XDRDataFixed4

// === xdr source ============================================================

//  typedef PublicKey NodeID;

//  ===========================================================================
public typealias NodeID = PublicKey

// === xdr source ============================================================

//  struct Curve25519Secret
//  {
//          opaque key[32];
//  };

//  ===========================================================================
public struct Curve25519Secret: XDREncodable {
  public var key: XDRDataFixed32

  public init(
      key: XDRDataFixed32) {

    self.key = key
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.key.toXDR())

    return xdr
  }
}

// === xdr source ============================================================

//  struct Curve25519Public
//  {
//          opaque key[32];
//  };

//  ===========================================================================
public struct Curve25519Public: XDREncodable {
  public var key: XDRDataFixed32

  public init(
      key: XDRDataFixed32) {

    self.key = key
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.key.toXDR())

    return xdr
  }
}

// === xdr source ============================================================

//  struct HmacSha256Key
//  {
//          opaque key[32];
//  };

//  ===========================================================================
public struct HmacSha256Key: XDREncodable {
  public var key: XDRDataFixed32

  public init(
      key: XDRDataFixed32) {

    self.key = key
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.key.toXDR())

    return xdr
  }
}

// === xdr source ============================================================

//  struct HmacSha256Mac
//  {
//          opaque mac[32];
//  };

//  ===========================================================================
public struct HmacSha256Mac: XDREncodable {
  public var mac: XDRDataFixed32

  public init(
      mac: XDRDataFixed32) {

    self.mac = mac
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.mac.toXDR())

    return xdr
  }
}

// === xdr source ============================================================

//  typedef PublicKey AccountID;

//  ===========================================================================
public typealias AccountID = PublicKey

// === xdr source ============================================================

//  typedef PublicKey BalanceID;

//  ===========================================================================
public typealias BalanceID = PublicKey

// === xdr source ============================================================

//  typedef opaque Thresholds[4];

//  ===========================================================================
public typealias Thresholds = XDRDataFixed4

// === xdr source ============================================================

//  typedef string string32<32>;

//  ===========================================================================
public typealias String32 = String

// === xdr source ============================================================

//  typedef string string64<64>;

//  ===========================================================================
public typealias String64 = String

// === xdr source ============================================================

//  typedef string string256<256>;

//  ===========================================================================
public typealias String256 = String

// === xdr source ============================================================

//  typedef string longstring<>;

//  ===========================================================================
public typealias Longstring = String

// === xdr source ============================================================

//  typedef string AssetCode<16>;

//  ===========================================================================
public typealias AssetCode = String

// === xdr source ============================================================

//  typedef uint64 Salt;

//  ===========================================================================
public typealias Salt = Uint64

// === xdr source ============================================================

//  typedef opaque DataValue<64>;

//  ===========================================================================
public typealias DataValue = Data

// === xdr source ============================================================

//  struct Fee {
//  	uint64 fixed;
//  	uint64 percent;
//  
//      // reserved for future use
//      union switch(LedgerVersion v)
//      {
//          case EMPTY_VERSION:
//              void;
//      }
//      ext;
//  };

//  ===========================================================================
public struct Fee: XDREncodable {
  public var fixed: Uint64
  public var percent: Uint64
  public var ext: FeeExt

  public init(
      fixed: Uint64,
      percent: Uint64,
      ext: FeeExt) {

    self.fixed = fixed
    self.percent = percent
    self.ext = ext
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.fixed.toXDR())
    xdr.append(self.percent.toXDR())
    xdr.append(self.ext.toXDR())

    return xdr
  }

  public enum FeeExt: XDRDiscriminatedUnion {
    case emptyVersion()

    public var discriminant: Int32 {
      switch self {
      case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()
            
      xdr.append(self.discriminant.toXDR())
            
      switch self {
      case .emptyVersion(): xdr.append(Data())
      }

      return xdr
    }

  }
}

// === xdr source ============================================================

//  enum OperationType
//  {
//      CREATE_ACCOUNT = 0,
//      PAYMENT = 1,
//      SET_OPTIONS = 2,
//      CREATE_ISSUANCE_REQUEST = 3,
//      SET_FEES = 5,
//  	MANAGE_ACCOUNT = 6,
//      CREATE_WITHDRAWAL_REQUEST = 7,
//      MANAGE_BALANCE = 9,
//      MANAGE_ASSET = 11,
//      CREATE_PREISSUANCE_REQUEST = 12,
//      MANAGE_LIMITS = 13,
//      DIRECT_DEBIT = 14,
//  	MANAGE_ASSET_PAIR = 15,
//  	MANAGE_OFFER = 16,
//      MANAGE_INVOICE_REQUEST = 17,
//  	REVIEW_REQUEST = 18,
//  	CREATE_SALE_REQUEST = 19,
//  	CHECK_SALE_STATE = 20,
//      CREATE_AML_ALERT = 21,
//      CREATE_KYC_REQUEST = 22,
//      PAYMENT_V2 = 23,
//      MANAGE_EXTERNAL_SYSTEM_ACCOUNT_ID_POOL_ENTRY = 24,
//      BIND_EXTERNAL_SYSTEM_ACCOUNT_ID = 25,
//      MANAGE_SALE = 26,
//      MANAGE_KEY_VALUE = 27,
//      CREATE_MANAGE_LIMITS_REQUEST = 28,
//      MANAGE_CONTRACT_REQUEST = 29,
//      MANAGE_CONTRACT = 30,
//      CANCEL_SALE_REQUEST = 31,
//      PAYOUT = 32,
//      MANAGE_ACCOUNT_ROLE = 33,
//      MANAGE_ACCOUNT_ROLE_PERMISSION = 34
//  };

//  ===========================================================================
public enum OperationType: Int32, XDREnum {
  case createAccount = 0
  case payment = 1
  case setOptions = 2
  case createIssuanceRequest = 3
  case setFees = 5
  case manageAccount = 6
  case createWithdrawalRequest = 7
  case manageBalance = 9
  case manageAsset = 11
  case createPreissuanceRequest = 12
  case manageLimits = 13
  case directDebit = 14
  case manageAssetPair = 15
  case manageOffer = 16
  case manageInvoiceRequest = 17
  case reviewRequest = 18
  case createSaleRequest = 19
  case checkSaleState = 20
  case createAmlAlert = 21
  case createKycRequest = 22
  case paymentV2 = 23
  case manageExternalSystemAccountIdPoolEntry = 24
  case bindExternalSystemAccountId = 25
  case manageSale = 26
  case manageKeyValue = 27
  case createManageLimitsRequest = 28
  case manageContractRequest = 29
  case manageContract = 30
  case cancelSaleRequest = 31
  case payout = 32
  case manageAccountRole = 33
  case manageAccountRolePermission = 34
}

// === xdr source ============================================================

//  struct DecoratedSignature
//  {
//      SignatureHint hint;  // last 4 bytes of the public key, used as a hint
//      Signature signature; // actual signature
//  };

//  ===========================================================================
public struct DecoratedSignature: XDREncodable {
  public var hint: SignatureHint
  public var signature: Signature

  public init(
      hint: SignatureHint,
      signature: Signature) {

    self.hint = hint
    self.signature = signature
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.hint.toXDR())
    xdr.append(self.signature.toXDR())

    return xdr
  }
}
